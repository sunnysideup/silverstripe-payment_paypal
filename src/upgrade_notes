2025-07-14 04:18

# running php upgrade inspect see: https://github.com/silverstripe/silverstripe-upgrader
cd /var/www/upgrades/upgradeto4
php /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code inspect /var/www/upgrades/upgradeto4/payment_paypal/src  --root-dir=/var/www/upgrades/upgradeto4 --write -vvv
Array
(
    [0] => PHP Deprecated:  Nette\DI\Extensions\PhpExtension is deprecated, use Nette\Bootstrap\Extensions\PhpExtension. in /var/www/ss3/upgrader/vendor/nette/di/src/DI/Extensions/PhpExtension.php on line 29
    [1] => Running post-upgrade on "/var/www/upgrades/upgradeto4/payment_paypal/src"
    [2] => [2025-07-14 04:18:23] Applying ApiChangeWarningsRule to PayPalExpressCheckoutPayment_Handler.php...
    [3] => PHP Fatal error:  Declaration of Sunnysideup\PaymentPayPal\PayPalExpressCheckoutPayment::getPaymentFormFields($amount = 0, $order = NULL) must be compatible with Sunnysideup\Ecommerce\Model\Money\EcommercePayment::getPaymentFormFields($amount = 0, ?Sunnysideup\Ecommerce\Model\Order $order = NULL): SilverStripe\Forms\FieldList in /var/www/upgrades/upgradeto4/payment_paypal/src/PayPalExpressCheckoutPayment.php on line 107
)


------------------------------------------------------------------------
To continue, please use the following parameter: startFrom=InspectAPIChanges-1
e.g. php runme.php startFrom=InspectAPIChanges-1
------------------------------------------------------------------------
            
# running php upgrade inspect see: https://github.com/silverstripe/silverstripe-upgrader
cd /var/www/upgrades/upgradeto4
php /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code inspect /var/www/upgrades/upgradeto4/payment_paypal/src  --root-dir=/var/www/upgrades/upgradeto4 --write -vvv
Array
(
    [0] => Running post-upgrade on "/var/www/upgrades/upgradeto4/payment_paypal/src"
    [1] => [2025-07-14 04:18:43] Applying ApiChangeWarningsRule to PayPalExpressCheckoutPayment_Handler.php...
    [2] => PHP Fatal error:  Declaration of Sunnysideup\PaymentPayPal\PayPalExpressCheckoutPayment::getPaymentFormFields($amount = 0, $order = NULL) must be compatible with Sunnysideup\Ecommerce\Model\Money\EcommercePayment::getPaymentFormFields($amount = 0, ?Sunnysideup\Ecommerce\Model\Order $order = NULL): SilverStripe\Forms\FieldList in /var/www/upgrades/upgradeto4/payment_paypal/src/PayPalExpressCheckoutPayment.php on line 107
)


------------------------------------------------------------------------
To continue, please use the following parameter: startFrom=InspectAPIChanges-1
e.g. php runme.php startFrom=InspectAPIChanges-1
------------------------------------------------------------------------
            
# running php upgrade inspect see: https://github.com/silverstripe/silverstripe-upgrader
cd /var/www/upgrades/upgradeto4
php /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code inspect /var/www/upgrades/upgradeto4/payment_paypal/src  --root-dir=/var/www/upgrades/upgradeto4 --write -vvv
Array
(
    [0] => Running post-upgrade on "/var/www/upgrades/upgradeto4/payment_paypal/src"
    [1] => [2025-07-14 04:22:59] Applying ApiChangeWarningsRule to PayPalExpressCheckoutPaymentHandler.php...
    [2] => 
    [3] => In ParserAbstract.php line 293:
    [4] => 
    [5] =>   [PhpParser\Error]
    [6] =>   Syntax error, unexpected T_STRING, expecting T_FUNCTION or T_CONST on line 4265
    [7] => 
    [8] => 
    [9] => Exception trace:
    [10] =>   at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php:293
    [11] =>  PhpParser\ParserAbstract->parse() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Parser/DirectParser.php:41
    [12] =>  PHPStan\Parser\DirectParser->parseString() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Parser/DirectParser.php:32
    [13] =>  PHPStan\Parser\DirectParser->parseFile() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Parser/CachedParser.php:29
    [14] =>  PHPStan\Parser\CachedParser->parseFile() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Type/FileTypeMapper.php:110
    [15] =>  PHPStan\Type\FileTypeMapper->createResolvedPhpDocMap() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Type/FileTypeMapper.php:81
    [16] =>  PHPStan\Type\FileTypeMapper->getResolvedPhpDocMap() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Type/FileTypeMapper.php:61
    [17] =>  PHPStan\Type\FileTypeMapper->getResolvedPhpDoc() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/Annotations/AnnotationsMethodsClassReflectionExtension.php:72
    [18] =>  PHPStan\Reflection\Annotations\AnnotationsMethodsClassReflectionExtension->createMethods() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/Annotations/AnnotationsMethodsClassReflectionExtension.php:53
    [19] =>  PHPStan\Reflection\Annotations\AnnotationsMethodsClassReflectionExtension->createMethods() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/Annotations/AnnotationsMethodsClassReflectionExtension.php:53
    [20] =>  PHPStan\Reflection\Annotations\AnnotationsMethodsClassReflectionExtension->createMethods() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/Annotations/AnnotationsMethodsClassReflectionExtension.php:27
    [21] =>  PHPStan\Reflection\Annotations\AnnotationsMethodsClassReflectionExtension->hasMethod() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/Php/PhpClassReflectionExtension.php:199
    [22] =>  PHPStan\Reflection\Php\PhpClassReflectionExtension->createMethod() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/Php/PhpClassReflectionExtension.php:167
    [23] =>  PHPStan\Reflection\Php\PhpClassReflectionExtension->getMethod() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/ClassReflection.php:170
    [24] =>  PHPStan\Reflection\ClassReflection->getMethod() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Type/ObjectType.php:177
    [25] =>  PHPStan\Type\ObjectType->getMethod() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/Scope.php:691
    [26] =>  PHPStan\Analyser\Scope->resolveType() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/Scope.php:323
    [27] =>  PHPStan\Analyser\Scope->getType() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/Scope.php:640
    [28] =>  PHPStan\Analyser\Scope->resolveType() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/Scope.php:323
    [29] =>  PHPStan\Analyser\Scope->getType() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Rules/RuleLevelHelper.php:89
    [30] =>  PHPStan\Rules\RuleLevelHelper->findTypeToCheck() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Rules/Methods/CallMethodsRule.php:62
    [31] =>  PHPStan\Rules\Methods\CallMethodsRule->processNode() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/Visitor/PHPStanScopeVisitor.php:80
    [32] =>  SilverStripe\Upgrader\UpgradeRule\PHP\Visitor\PHPStanScopeVisitor->SilverStripe\Upgrader\UpgradeRule\PHP\Visitor\{closure}() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:316
    [33] =>  PHPStan\Analyser\NodeScopeResolver->processNode() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:777
    [34] =>  PHPStan\Analyser\NodeScopeResolver->processNode() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:176
    [35] =>  PHPStan\Analyser\NodeScopeResolver->processNodes() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:489
    [36] =>  PHPStan\Analyser\NodeScopeResolver->processNode() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:176
    [37] =>  PHPStan\Analyser\NodeScopeResolver->processNodes() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:699
    [38] =>  PHPStan\Analyser\NodeScopeResolver->processNode() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:176
    [39] =>  PHPStan\Analyser\NodeScopeResolver->processNodes() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:699
    [40] =>  PHPStan\Analyser\NodeScopeResolver->processNode() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:176
    [41] =>  PHPStan\Analyser\NodeScopeResolver->processNodes() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:699
    [42] =>  PHPStan\Analyser\NodeScopeResolver->processNode() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:176
    [43] =>  PHPStan\Analyser\NodeScopeResolver->processNodes() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/Visitor/PHPStanScopeVisitor.php:82
    [44] =>  SilverStripe\Upgrader\UpgradeRule\PHP\Visitor\PHPStanScopeVisitor->enterNode() at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/NodeTraverser.php:159
    [45] =>  PhpParser\NodeTraverser->traverseArray() at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/NodeTraverser.php:85
    [46] =>  PhpParser\NodeTraverser->traverse() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/PHPUpgradeRule.php:28
    [47] =>  SilverStripe\Upgrader\UpgradeRule\PHP\PHPUpgradeRule->transformWithVisitors() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/ApiChangeWarningsRule.php:88
    [48] =>  SilverStripe\Upgrader\UpgradeRule\PHP\ApiChangeWarningsRule->mutateSourceWithVisitors() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/ApiChangeWarningsRule.php:60
    [49] =>  SilverStripe\Upgrader\UpgradeRule\PHP\ApiChangeWarningsRule->upgradeFile() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Upgrader.php:61
    [50] =>  SilverStripe\Upgrader\Upgrader->upgrade() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Console/InspectCommand.php:88
    [51] =>  SilverStripe\Upgrader\Console\InspectCommand->execute() at /var/www/ss3/upgrader/vendor/symfony/console/Command/Command.php:255
    [52] =>  Symfony\Component\Console\Command\Command->run() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:1021
    [53] =>  Symfony\Component\Console\Application->doRunCommand() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:275
    [54] =>  Symfony\Component\Console\Application->doRun() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:149
    [55] =>  Symfony\Component\Console\Application->run() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code:55
    [56] => 
    [57] => inspect [-d|--root-dir ROOT-DIR] [-w|--write] [--skip-visibility] [--] <path>
    [58] => 
)


------------------------------------------------------------------------
To continue, please use the following parameter: startFrom=InspectAPIChanges-1
e.g. php runme.php startFrom=InspectAPIChanges-1
------------------------------------------------------------------------
            
# running php upgrade inspect see: https://github.com/silverstripe/silverstripe-upgrader
cd /var/www/upgrades/upgradeto4
php /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code inspect /var/www/upgrades/upgradeto4/payment_paypal/src  --root-dir=/var/www/upgrades/upgradeto4 --write -vvv
Array
(
    [0] => Running post-upgrade on "/var/www/upgrades/upgradeto4/payment_paypal/src"
    [1] => [2025-07-14 05:24:47] Applying ApiChangeWarningsRule to PayPalExpressCheckoutPaymentHandler.php...
    [2] => 
    [3] => In ParserAbstract.php line 293:
    [4] => 
    [5] =>   [PhpParser\Error]
    [6] =>   Syntax error, unexpected T_STRING, expecting T_FUNCTION or T_CONST on line 4265
    [7] => 
    [8] => 
    [9] => Exception trace:
    [10] =>   at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php:293
    [11] =>  PhpParser\ParserAbstract->parse() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Parser/DirectParser.php:41
    [12] =>  PHPStan\Parser\DirectParser->parseString() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Parser/DirectParser.php:32
    [13] =>  PHPStan\Parser\DirectParser->parseFile() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Parser/CachedParser.php:29
    [14] =>  PHPStan\Parser\CachedParser->parseFile() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Type/FileTypeMapper.php:110
    [15] =>  PHPStan\Type\FileTypeMapper->createResolvedPhpDocMap() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Type/FileTypeMapper.php:81
    [16] =>  PHPStan\Type\FileTypeMapper->getResolvedPhpDocMap() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Type/FileTypeMapper.php:61
    [17] =>  PHPStan\Type\FileTypeMapper->getResolvedPhpDoc() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/Annotations/AnnotationsMethodsClassReflectionExtension.php:72
    [18] =>  PHPStan\Reflection\Annotations\AnnotationsMethodsClassReflectionExtension->createMethods() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/Annotations/AnnotationsMethodsClassReflectionExtension.php:53
    [19] =>  PHPStan\Reflection\Annotations\AnnotationsMethodsClassReflectionExtension->createMethods() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/Annotations/AnnotationsMethodsClassReflectionExtension.php:53
    [20] =>  PHPStan\Reflection\Annotations\AnnotationsMethodsClassReflectionExtension->createMethods() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/Annotations/AnnotationsMethodsClassReflectionExtension.php:27
    [21] =>  PHPStan\Reflection\Annotations\AnnotationsMethodsClassReflectionExtension->hasMethod() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/Php/PhpClassReflectionExtension.php:199
    [22] =>  PHPStan\Reflection\Php\PhpClassReflectionExtension->createMethod() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/Php/PhpClassReflectionExtension.php:167
    [23] =>  PHPStan\Reflection\Php\PhpClassReflectionExtension->getMethod() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/ClassReflection.php:170
    [24] =>  PHPStan\Reflection\ClassReflection->getMethod() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Type/ObjectType.php:177
    [25] =>  PHPStan\Type\ObjectType->getMethod() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/Scope.php:691
    [26] =>  PHPStan\Analyser\Scope->resolveType() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/Scope.php:323
    [27] =>  PHPStan\Analyser\Scope->getType() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/Scope.php:640
    [28] =>  PHPStan\Analyser\Scope->resolveType() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/Scope.php:323
    [29] =>  PHPStan\Analyser\Scope->getType() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Rules/RuleLevelHelper.php:89
    [30] =>  PHPStan\Rules\RuleLevelHelper->findTypeToCheck() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Rules/Methods/CallMethodsRule.php:62
    [31] =>  PHPStan\Rules\Methods\CallMethodsRule->processNode() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/Visitor/PHPStanScopeVisitor.php:80
    [32] =>  SilverStripe\Upgrader\UpgradeRule\PHP\Visitor\PHPStanScopeVisitor->SilverStripe\Upgrader\UpgradeRule\PHP\Visitor\{closure}() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:316
    [33] =>  PHPStan\Analyser\NodeScopeResolver->processNode() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:777
    [34] =>  PHPStan\Analyser\NodeScopeResolver->processNode() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:176
    [35] =>  PHPStan\Analyser\NodeScopeResolver->processNodes() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:489
    [36] =>  PHPStan\Analyser\NodeScopeResolver->processNode() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:176
    [37] =>  PHPStan\Analyser\NodeScopeResolver->processNodes() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:699
    [38] =>  PHPStan\Analyser\NodeScopeResolver->processNode() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:176
    [39] =>  PHPStan\Analyser\NodeScopeResolver->processNodes() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:699
    [40] =>  PHPStan\Analyser\NodeScopeResolver->processNode() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:176
    [41] =>  PHPStan\Analyser\NodeScopeResolver->processNodes() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:699
    [42] =>  PHPStan\Analyser\NodeScopeResolver->processNode() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:176
    [43] =>  PHPStan\Analyser\NodeScopeResolver->processNodes() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/Visitor/PHPStanScopeVisitor.php:82
    [44] =>  SilverStripe\Upgrader\UpgradeRule\PHP\Visitor\PHPStanScopeVisitor->enterNode() at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/NodeTraverser.php:159
    [45] =>  PhpParser\NodeTraverser->traverseArray() at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/NodeTraverser.php:85
    [46] =>  PhpParser\NodeTraverser->traverse() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/PHPUpgradeRule.php:28
    [47] =>  SilverStripe\Upgrader\UpgradeRule\PHP\PHPUpgradeRule->transformWithVisitors() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/ApiChangeWarningsRule.php:88
    [48] =>  SilverStripe\Upgrader\UpgradeRule\PHP\ApiChangeWarningsRule->mutateSourceWithVisitors() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/ApiChangeWarningsRule.php:60
    [49] =>  SilverStripe\Upgrader\UpgradeRule\PHP\ApiChangeWarningsRule->upgradeFile() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Upgrader.php:61
    [50] =>  SilverStripe\Upgrader\Upgrader->upgrade() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Console/InspectCommand.php:88
    [51] =>  SilverStripe\Upgrader\Console\InspectCommand->execute() at /var/www/ss3/upgrader/vendor/symfony/console/Command/Command.php:255
    [52] =>  Symfony\Component\Console\Command\Command->run() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:1021
    [53] =>  Symfony\Component\Console\Application->doRunCommand() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:275
    [54] =>  Symfony\Component\Console\Application->doRun() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:149
    [55] =>  Symfony\Component\Console\Application->run() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code:55
    [56] => 
    [57] => inspect [-d|--root-dir ROOT-DIR] [-w|--write] [--skip-visibility] [--] <path>
    [58] => 
)


------------------------------------------------------------------------
To continue, please use the following parameter: startFrom=InspectAPIChanges-1
e.g. php runme.php startFrom=InspectAPIChanges-1
------------------------------------------------------------------------
            
# running php upgrade inspect see: https://github.com/silverstripe/silverstripe-upgrader
cd /var/www/upgrades/upgradeto4
php /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code inspect /var/www/upgrades/upgradeto4/payment_paypal/src  --root-dir=/var/www/upgrades/upgradeto4 --write -vvv
Array
(
    [0] => Running post-upgrade on "/var/www/upgrades/upgradeto4/payment_paypal/src"
    [1] => [2025-07-14 05:26:47] Applying ApiChangeWarningsRule to PayPalExpressCheckoutPaymentHandler.php...
    [2] => 
    [3] => In ParserAbstract.php line 293:
    [4] => 
    [5] =>   [PhpParser\Error]
    [6] =>   Syntax error, unexpected T_STRING, expecting T_FUNCTION or T_CONST on line 4265
    [7] => 
    [8] => 
    [9] => Exception trace:
    [10] =>   at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php:293
    [11] =>  PhpParser\ParserAbstract->parse() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Parser/DirectParser.php:41
    [12] =>  PHPStan\Parser\DirectParser->parseString() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Parser/DirectParser.php:32
    [13] =>  PHPStan\Parser\DirectParser->parseFile() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Parser/CachedParser.php:29
    [14] =>  PHPStan\Parser\CachedParser->parseFile() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Type/FileTypeMapper.php:110
    [15] =>  PHPStan\Type\FileTypeMapper->createResolvedPhpDocMap() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Type/FileTypeMapper.php:81
    [16] =>  PHPStan\Type\FileTypeMapper->getResolvedPhpDocMap() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Type/FileTypeMapper.php:61
    [17] =>  PHPStan\Type\FileTypeMapper->getResolvedPhpDoc() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/Annotations/AnnotationsMethodsClassReflectionExtension.php:72
    [18] =>  PHPStan\Reflection\Annotations\AnnotationsMethodsClassReflectionExtension->createMethods() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/Annotations/AnnotationsMethodsClassReflectionExtension.php:53
    [19] =>  PHPStan\Reflection\Annotations\AnnotationsMethodsClassReflectionExtension->createMethods() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/Annotations/AnnotationsMethodsClassReflectionExtension.php:53
    [20] =>  PHPStan\Reflection\Annotations\AnnotationsMethodsClassReflectionExtension->createMethods() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/Annotations/AnnotationsMethodsClassReflectionExtension.php:27
    [21] =>  PHPStan\Reflection\Annotations\AnnotationsMethodsClassReflectionExtension->hasMethod() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/Php/PhpClassReflectionExtension.php:199
    [22] =>  PHPStan\Reflection\Php\PhpClassReflectionExtension->createMethod() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/Php/PhpClassReflectionExtension.php:167
    [23] =>  PHPStan\Reflection\Php\PhpClassReflectionExtension->getMethod() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/ClassReflection.php:170
    [24] =>  PHPStan\Reflection\ClassReflection->getMethod() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Type/ObjectType.php:177
    [25] =>  PHPStan\Type\ObjectType->getMethod() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/Scope.php:691
    [26] =>  PHPStan\Analyser\Scope->resolveType() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/Scope.php:323
    [27] =>  PHPStan\Analyser\Scope->getType() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/Scope.php:640
    [28] =>  PHPStan\Analyser\Scope->resolveType() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/Scope.php:323
    [29] =>  PHPStan\Analyser\Scope->getType() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Rules/RuleLevelHelper.php:89
    [30] =>  PHPStan\Rules\RuleLevelHelper->findTypeToCheck() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Rules/Methods/CallMethodsRule.php:62
    [31] =>  PHPStan\Rules\Methods\CallMethodsRule->processNode() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/Visitor/PHPStanScopeVisitor.php:80
    [32] =>  SilverStripe\Upgrader\UpgradeRule\PHP\Visitor\PHPStanScopeVisitor->SilverStripe\Upgrader\UpgradeRule\PHP\Visitor\{closure}() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:316
    [33] =>  PHPStan\Analyser\NodeScopeResolver->processNode() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:777
    [34] =>  PHPStan\Analyser\NodeScopeResolver->processNode() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:176
    [35] =>  PHPStan\Analyser\NodeScopeResolver->processNodes() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:489
    [36] =>  PHPStan\Analyser\NodeScopeResolver->processNode() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:176
    [37] =>  PHPStan\Analyser\NodeScopeResolver->processNodes() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:699
    [38] =>  PHPStan\Analyser\NodeScopeResolver->processNode() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:176
    [39] =>  PHPStan\Analyser\NodeScopeResolver->processNodes() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:699
    [40] =>  PHPStan\Analyser\NodeScopeResolver->processNode() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:176
    [41] =>  PHPStan\Analyser\NodeScopeResolver->processNodes() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:699
    [42] =>  PHPStan\Analyser\NodeScopeResolver->processNode() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:176
    [43] =>  PHPStan\Analyser\NodeScopeResolver->processNodes() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/Visitor/PHPStanScopeVisitor.php:82
    [44] =>  SilverStripe\Upgrader\UpgradeRule\PHP\Visitor\PHPStanScopeVisitor->enterNode() at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/NodeTraverser.php:159
    [45] =>  PhpParser\NodeTraverser->traverseArray() at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/NodeTraverser.php:85
    [46] =>  PhpParser\NodeTraverser->traverse() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/PHPUpgradeRule.php:28
    [47] =>  SilverStripe\Upgrader\UpgradeRule\PHP\PHPUpgradeRule->transformWithVisitors() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/ApiChangeWarningsRule.php:88
    [48] =>  SilverStripe\Upgrader\UpgradeRule\PHP\ApiChangeWarningsRule->mutateSourceWithVisitors() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/ApiChangeWarningsRule.php:60
    [49] =>  SilverStripe\Upgrader\UpgradeRule\PHP\ApiChangeWarningsRule->upgradeFile() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Upgrader.php:61
    [50] =>  SilverStripe\Upgrader\Upgrader->upgrade() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Console/InspectCommand.php:88
    [51] =>  SilverStripe\Upgrader\Console\InspectCommand->execute() at /var/www/ss3/upgrader/vendor/symfony/console/Command/Command.php:255
    [52] =>  Symfony\Component\Console\Command\Command->run() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:1021
    [53] =>  Symfony\Component\Console\Application->doRunCommand() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:275
    [54] =>  Symfony\Component\Console\Application->doRun() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:149
    [55] =>  Symfony\Component\Console\Application->run() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code:55
    [56] => 
    [57] => inspect [-d|--root-dir ROOT-DIR] [-w|--write] [--skip-visibility] [--] <path>
    [58] => 
)


------------------------------------------------------------------------
To continue, please use the following parameter: startFrom=InspectAPIChanges-1
e.g. php runme.php startFrom=InspectAPIChanges-1
------------------------------------------------------------------------
            
# running php upgrade inspect see: https://github.com/silverstripe/silverstripe-upgrader
cd /var/www/upgrades/upgradeto4
php /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code inspect /var/www/upgrades/upgradeto4/payment_paypal/src  --root-dir=/var/www/upgrades/upgradeto4 --write -vvv
Array
(
    [0] => Running post-upgrade on "/var/www/upgrades/upgradeto4/payment_paypal/src"
    [1] => [2025-07-14 05:28:14] Applying ApiChangeWarningsRule to PayPalExpressCheckoutPaymentHandler.php...
    [2] => /var/www/upgrades/upgradeto4/vendor/silverstripe/framework/src/ORM/DataObject.php
    [3] => 
    [4] => In ParserAbstract.php line 293:
    [5] => 
    [6] =>   [PhpParser\Error]
    [7] =>   Syntax error, unexpected T_STRING, expecting T_FUNCTION or T_CONST on line 4265
    [8] => 
    [9] => 
    [10] => Exception trace:
    [11] =>   at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php:293
    [12] =>  PhpParser\ParserAbstract->parse() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Parser/DirectParser.php:44
    [13] =>  PHPStan\Parser\DirectParser->parseString() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Parser/DirectParser.php:35
    [14] =>  PHPStan\Parser\DirectParser->parseFile() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Parser/CachedParser.php:29
    [15] =>  PHPStan\Parser\CachedParser->parseFile() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Type/FileTypeMapper.php:110
    [16] =>  PHPStan\Type\FileTypeMapper->createResolvedPhpDocMap() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Type/FileTypeMapper.php:81
    [17] =>  PHPStan\Type\FileTypeMapper->getResolvedPhpDocMap() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Type/FileTypeMapper.php:61
    [18] =>  PHPStan\Type\FileTypeMapper->getResolvedPhpDoc() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/Annotations/AnnotationsMethodsClassReflectionExtension.php:72
    [19] =>  PHPStan\Reflection\Annotations\AnnotationsMethodsClassReflectionExtension->createMethods() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/Annotations/AnnotationsMethodsClassReflectionExtension.php:53
    [20] =>  PHPStan\Reflection\Annotations\AnnotationsMethodsClassReflectionExtension->createMethods() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/Annotations/AnnotationsMethodsClassReflectionExtension.php:53
    [21] =>  PHPStan\Reflection\Annotations\AnnotationsMethodsClassReflectionExtension->createMethods() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/Annotations/AnnotationsMethodsClassReflectionExtension.php:27
    [22] =>  PHPStan\Reflection\Annotations\AnnotationsMethodsClassReflectionExtension->hasMethod() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/Php/PhpClassReflectionExtension.php:199
    [23] =>  PHPStan\Reflection\Php\PhpClassReflectionExtension->createMethod() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/Php/PhpClassReflectionExtension.php:167
    [24] =>  PHPStan\Reflection\Php\PhpClassReflectionExtension->getMethod() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/ClassReflection.php:170
    [25] =>  PHPStan\Reflection\ClassReflection->getMethod() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Type/ObjectType.php:177
    [26] =>  PHPStan\Type\ObjectType->getMethod() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/Scope.php:691
    [27] =>  PHPStan\Analyser\Scope->resolveType() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/Scope.php:323
    [28] =>  PHPStan\Analyser\Scope->getType() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/Scope.php:640
    [29] =>  PHPStan\Analyser\Scope->resolveType() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/Scope.php:323
    [30] =>  PHPStan\Analyser\Scope->getType() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Rules/RuleLevelHelper.php:89
    [31] =>  PHPStan\Rules\RuleLevelHelper->findTypeToCheck() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Rules/Methods/CallMethodsRule.php:62
    [32] =>  PHPStan\Rules\Methods\CallMethodsRule->processNode() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/Visitor/PHPStanScopeVisitor.php:80
    [33] =>  SilverStripe\Upgrader\UpgradeRule\PHP\Visitor\PHPStanScopeVisitor->SilverStripe\Upgrader\UpgradeRule\PHP\Visitor\{closure}() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:316
    [34] =>  PHPStan\Analyser\NodeScopeResolver->processNode() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:777
    [35] =>  PHPStan\Analyser\NodeScopeResolver->processNode() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:176
    [36] =>  PHPStan\Analyser\NodeScopeResolver->processNodes() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:489
    [37] =>  PHPStan\Analyser\NodeScopeResolver->processNode() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:176
    [38] =>  PHPStan\Analyser\NodeScopeResolver->processNodes() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:699
    [39] =>  PHPStan\Analyser\NodeScopeResolver->processNode() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:176
    [40] =>  PHPStan\Analyser\NodeScopeResolver->processNodes() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:699
    [41] =>  PHPStan\Analyser\NodeScopeResolver->processNode() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:176
    [42] =>  PHPStan\Analyser\NodeScopeResolver->processNodes() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:699
    [43] =>  PHPStan\Analyser\NodeScopeResolver->processNode() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:176
    [44] =>  PHPStan\Analyser\NodeScopeResolver->processNodes() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/Visitor/PHPStanScopeVisitor.php:82
    [45] =>  SilverStripe\Upgrader\UpgradeRule\PHP\Visitor\PHPStanScopeVisitor->enterNode() at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/NodeTraverser.php:159
    [46] =>  PhpParser\NodeTraverser->traverseArray() at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/NodeTraverser.php:85
    [47] =>  PhpParser\NodeTraverser->traverse() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/PHPUpgradeRule.php:28
    [48] =>  SilverStripe\Upgrader\UpgradeRule\PHP\PHPUpgradeRule->transformWithVisitors() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/ApiChangeWarningsRule.php:88
    [49] =>  SilverStripe\Upgrader\UpgradeRule\PHP\ApiChangeWarningsRule->mutateSourceWithVisitors() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/ApiChangeWarningsRule.php:60
    [50] =>  SilverStripe\Upgrader\UpgradeRule\PHP\ApiChangeWarningsRule->upgradeFile() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Upgrader.php:61
    [51] =>  SilverStripe\Upgrader\Upgrader->upgrade() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Console/InspectCommand.php:88
    [52] =>  SilverStripe\Upgrader\Console\InspectCommand->execute() at /var/www/ss3/upgrader/vendor/symfony/console/Command/Command.php:255
    [53] =>  Symfony\Component\Console\Command\Command->run() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:1021
    [54] =>  Symfony\Component\Console\Application->doRunCommand() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:275
    [55] =>  Symfony\Component\Console\Application->doRun() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:149
    [56] =>  Symfony\Component\Console\Application->run() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code:55
    [57] => 
    [58] => inspect [-d|--root-dir ROOT-DIR] [-w|--write] [--skip-visibility] [--] <path>
    [59] => 
)


------------------------------------------------------------------------
To continue, please use the following parameter: startFrom=InspectAPIChanges-1
e.g. php runme.php startFrom=InspectAPIChanges-1
------------------------------------------------------------------------
            
# running php upgrade inspect see: https://github.com/silverstripe/silverstripe-upgrader
cd /var/www/upgrades/upgradeto4
php /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code inspect /var/www/upgrades/upgradeto4/payment_paypal/src  --root-dir=/var/www/upgrades/upgradeto4 --write -vvv
Array
(
    [0] => Running post-upgrade on "/var/www/upgrades/upgradeto4/payment_paypal/src"
    [1] => [2025-07-14 05:28:52] Applying ApiChangeWarningsRule to PayPalExpressCheckoutPaymentHandler.php...
    [2] => /var/www/upgrades/upgradeto4/vendor/silverstripe/framework/src/ORM/DataObject.php
    [3] => <?php
    [4] => 
    [5] => namespace SilverStripe\ORM;
    [6] => 
    [7] => use BadMethodCallException;
    [8] => use Exception;
    [9] => use InvalidArgumentException;
    [10] => use LogicException;
    [11] => use SilverStripe\Core\ClassInfo;
    [12] => use SilverStripe\Core\Config\Config;
    [13] => use SilverStripe\Core\Injector\Injector;
    [14] => use SilverStripe\Core\Resettable;
    [15] => use SilverStripe\Dev\Debug;
    [16] => use SilverStripe\Dev\Deprecation;
    [17] => use SilverStripe\Forms\FieldList;
    [18] => use SilverStripe\Forms\FormField;
    [19] => use SilverStripe\Forms\FormScaffolder;
    [20] => use SilverStripe\Forms\CompositeValidator;
    [21] => use SilverStripe\Forms\FieldsValidator;
    [22] => use SilverStripe\Forms\HiddenField;
    [23] => use SilverStripe\i18n\i18n;
    [24] => use SilverStripe\i18n\i18nEntityProvider;
    [25] => use SilverStripe\ORM\Connect\MySQLSchemaManager;
    [26] => use SilverStripe\ORM\FieldType\DBComposite;
    [27] => use SilverStripe\ORM\FieldType\DBDatetime;
    [28] => use SilverStripe\ORM\FieldType\DBEnum;
    [29] => use SilverStripe\ORM\FieldType\DBField;
    [30] => use SilverStripe\ORM\Filters\PartialMatchFilter;
    [31] => use SilverStripe\ORM\Filters\SearchFilter;
    [32] => use SilverStripe\ORM\Queries\SQLDelete;
    [33] => use SilverStripe\ORM\Search\SearchContext;
    [34] => use SilverStripe\ORM\RelatedData\RelatedDataService;
    [35] => use SilverStripe\ORM\UniqueKey\UniqueKeyInterface;
    [36] => use SilverStripe\ORM\UniqueKey\UniqueKeyService;
    [37] => use SilverStripe\Security\Member;
    [38] => use SilverStripe\Security\Permission;
    [39] => use SilverStripe\Security\Security;
    [40] => use SilverStripe\View\SSViewer;
    [41] => use SilverStripe\View\ViewableData;
    [42] => use stdClass;
    [43] => 
    [44] => /**
    [45] =>  * A single database record & abstract class for the data-access-model.
    [46] =>  *
    [47] =>  * <h2>Extensions</h2>
    [48] =>  *
    [49] =>  * See {@link Extension} and {@link DataExtension}.
    [50] =>  *
    [51] =>  * <h2>Permission Control</h2>
    [52] =>  *
    [53] =>  * Object-level access control by {@link Permission}. Permission codes are arbitrary
    [54] =>  * strings which can be selected on a group-by-group basis.
    [55] =>  *
    [56] =>  * <code>
    [57] =>  * class Article extends DataObject implements PermissionProvider {
    [58] =>  *  static $api_access = true;
    [59] =>  *
    [60] =>  *  function canView($member = false) {
    [61] =>  *    return Permission::check('ARTICLE_VIEW');
    [62] =>  *  }
    [63] =>  *  function canEdit($member = false) {
    [64] =>  *    return Permission::check('ARTICLE_EDIT');
    [65] =>  *  }
    [66] =>  *  function canDelete() {
    [67] =>  *    return Permission::check('ARTICLE_DELETE');
    [68] =>  *  }
    [69] =>  *  function canCreate() {
    [70] =>  *    return Permission::check('ARTICLE_CREATE');
    [71] =>  *  }
    [72] =>  *  function providePermissions() {
    [73] =>  *    return array(
    [74] =>  *      'ARTICLE_VIEW' => 'Read an article object',
    [75] =>  *      'ARTICLE_EDIT' => 'Edit an article object',
    [76] =>  *      'ARTICLE_DELETE' => 'Delete an article object',
    [77] =>  *      'ARTICLE_CREATE' => 'Create an article object',
    [78] =>  *    );
    [79] =>  *  }
    [80] =>  * }
    [81] =>  * </code>
    [82] =>  *
    [83] =>  * Object-level access control by {@link Group} membership:
    [84] =>  * <code>
    [85] =>  * class Article extends DataObject {
    [86] =>  *   static $api_access = true;
    [87] =>  *
    [88] =>  *   function canView($member = false) {
    [89] =>  *     if (!$member) $member = Security::getCurrentUser();
    [90] =>  *     return $member->inGroup('Subscribers');
    [91] =>  *   }
    [92] =>  *   function canEdit($member = false) {
    [93] =>  *     if (!$member) $member = Security::getCurrentUser();
    [94] =>  *     return $member->inGroup('Editors');
    [95] =>  *   }
    [96] =>  *
    [97] =>  *   // ...
    [98] =>  * }
    [99] =>  * </code>
    [100] =>  *
    [101] =>  * If any public method on this class is prefixed with an underscore,
    [102] =>  * the results are cached in memory through {@link cachedCall()}.
    [103] =>  *
    [104] =>  *
    [105] =>  * @todo Add instance specific removeExtension() which undos loadExtraStatics()
    [106] =>  *  and defineMethods()
    [107] =>  *
    [108] =>  * @property int $ID ID of the DataObject, 0 if the DataObject doesn't exist in database.
    [109] =>  * @property int $OldID ID of object, if deleted
    [110] =>  * @property string $Title
    [111] =>  * @property string $ClassName Class name of the DataObject
    [112] =>  * @property string $LastEdited Date and time of DataObject's last modification.
    [113] =>  * @property string $Created Date and time of DataObject creation.
    [114] =>  * @property string $ObsoleteClassName If ClassName no longer exists this will be set to the legacy value
    [115] =>  */
    [116] => class DataObject extends ViewableData implements DataObjectInterface, i18nEntityProvider, Resettable
    [117] => {
    [118] => 
    [119] =>     /**
    [120] =>      * Human-readable singular name.
    [121] =>      * @var string
    [122] =>      * @config
    [123] =>      */
    [124] =>     private static $singular_name = null;
    [125] => 
    [126] =>     /**
    [127] =>      * Human-readable plural name
    [128] =>      * @var string
    [129] =>      * @config
    [130] =>      */
    [131] =>     private static $plural_name = null;
    [132] => 
    [133] =>     /**
    [134] =>      * Allow API access to this object?
    [135] =>      * @todo Define the options that can be set here
    [136] =>      * @config
    [137] =>      */
    [138] =>     private static $api_access = false;
    [139] => 
    [140] =>     /**
    [141] =>      * Allows specification of a default value for the ClassName field.
    [142] =>      * Configure this value only in subclasses of DataObject.
    [143] =>      *
    [144] =>      * @config
    [145] =>      * @var string
    [146] =>      */
    [147] =>     private static $default_classname = null;
    [148] => 
    [149] =>     /**
    [150] =>      * @deprecated 4.0.0:5.0.0
    [151] =>      * @var bool
    [152] =>      */
    [153] =>     public $destroyed = false;
    [154] => 
    [155] =>     /**
    [156] =>      * Data stored in this objects database record. An array indexed by fieldname.
    [157] =>      *
    [158] =>      * Use {@link toMap()} if you want an array representation
    [159] =>      * of this object, as the $record array might contain lazy loaded field aliases.
    [160] =>      *
    [161] =>      * @var array
    [162] =>      */
    [163] =>     protected $record;
    [164] => 
    [165] =>     /**
    [166] =>      * If selected through a many_many through relation, this is the instance of the through record
    [167] =>      *
    [168] =>      * @var DataObject
    [169] =>      */
    [170] =>     protected $joinRecord;
    [171] => 
    [172] =>     /**
    [173] =>      * Represents a field that hasn't changed (before === after, thus before == after)
    [174] =>      */
    [175] =>     const CHANGE_NONE = 0;
    [176] => 
    [177] =>     /**
    [178] =>      * Represents a field that has changed type, although not the loosely defined value.
    [179] =>      * (before !== after && before == after)
    [180] =>      * E.g. change 1 to true or "true" to true, but not true to 0.
    [181] =>      * Value changes are by nature also considered strict changes.
    [182] =>      */
    [183] =>     const CHANGE_STRICT = 1;
    [184] => 
    [185] =>     /**
    [186] =>      * Represents a field that has changed the loosely defined value
    [187] =>      * (before != after, thus, before !== after))
    [188] =>      * E.g. change false to true, but not false to 0
    [189] =>      */
    [190] =>     const CHANGE_VALUE = 2;
    [191] => 
    [192] =>     /**
    [193] =>      * Value for 2nd argument to constructor, indicating that a new record is being created
    [194] =>      * Setters will be called on fields passed, and defaults will be populated
    [195] =>      */
    [196] =>     const CREATE_OBJECT = 0;
    [197] => 
    [198] =>     /**
    [199] =>      * Value for 2nd argument to constructor, indicating that a record is a singleton representing the whole type,
    [200] =>      * e.g. to call requireTable() in dev/build
    [201] =>      * Defaults will not be populated and data passed will be ignored
    [202] =>      */
    [203] =>     const CREATE_SINGLETON = 1;
    [204] => 
    [205] =>     /**
    [206] =>      * Value for 2nd argument to constructor, indicating that a record is being hydrated from the database
    [207] =>      * Setter methods are not called, and population via private static $defaults will not occur.
    [208] =>      */
    [209] =>     const CREATE_HYDRATED = 2;
    [210] => 
    [211] =>     /**
    [212] =>      * Value for 2nd argument to constructor, indicating that a record is being hydrated from memory. This can be used
    [213] =>      * to initialised a record that doesn't yet have an ID. Setter methods are not called, and population via private
    [214] =>      * static $defaults will not occur.
    [215] =>      */
    [216] =>     const CREATE_MEMORY_HYDRATED = 3;
    [217] => 
    [218] =>     /**
    [219] =>      * An array indexed by fieldname, true if the field has been changed.
    [220] =>      * Use {@link getChangedFields()} and {@link isChanged()} to inspect
    [221] =>      * the changed state.
    [222] =>      *
    [223] =>      * @var array
    [224] =>      */
    [225] =>     private $changed = [];
    [226] => 
    [227] =>     /**
    [228] =>      * A flag to indicate that a "strict" change of the entire record been forced
    [229] =>      * Use {@link getChangedFields()} and {@link isChanged()} to inspect
    [230] =>      * the changed state.
    [231] =>      *
    [232] =>      * @var boolean
    [233] =>      */
    [234] =>     private $changeForced = false;
    [235] => 
    [236] =>     /**
    [237] =>      * The database record (in the same format as $record), before
    [238] =>      * any changes.
    [239] =>      * @var array
    [240] =>      */
    [241] =>     protected $original = [];
    [242] => 
    [243] =>     /**
    [244] =>      * Used by onBeforeDelete() to ensure child classes call parent::onBeforeDelete()
    [245] =>      * @var boolean
    [246] =>      */
    [247] =>     protected $brokenOnDelete = false;
    [248] => 
    [249] =>     /**
    [250] =>      * Used by onBeforeWrite() to ensure child classes call parent::onBeforeWrite()
    [251] =>      * @var boolean
    [252] =>      */
    [253] =>     protected $brokenOnWrite = false;
    [254] => 
    [255] =>     /**
    [256] =>      * Should dataobjects be validated before they are written?
    [257] =>      *
    [258] =>      * Caution: Validation can contain safeguards against invalid/malicious data,
    [259] =>      * and check permission levels (e.g. on {@link Group}). Therefore it is recommended
    [260] =>      * to only disable validation for very specific use cases.
    [261] =>      *
    [262] =>      * @config
    [263] =>      * @var boolean
    [264] =>      */
    [265] =>     private static $validation_enabled = true;
    [266] => 
    [267] =>     /**
    [268] =>      * Static caches used by relevant functions.
    [269] =>      *
    [270] =>      * @var array
    [271] =>      */
    [272] =>     protected static $_cache_get_one;
    [273] => 
    [274] =>     /**
    [275] =>      * Cache of field labels
    [276] =>      *
    [277] =>      * @var array
    [278] =>      */
    [279] =>     protected static $_cache_field_labels = [];
    [280] => 
    [281] =>     /**
    [282] =>      * Base fields which are not defined in static $db
    [283] =>      *
    [284] =>      * @config
    [285] =>      * @var array
    [286] =>      */
    [287] =>     private static $fixed_fields = [
    [288] =>         'ID' => 'PrimaryKey',
    [289] =>         'ClassName' => 'DBClassName',
    [290] =>         'LastEdited' => 'DBDatetime',
    [291] =>         'Created' => 'DBDatetime',
    [292] =>     ];
    [293] => 
    [294] =>     /**
    [295] =>      * Override table name for this class. If ignored will default to FQN of class.
    [296] =>      * This option is not inheritable, and must be set on each class.
    [297] =>      * If left blank naming will default to the legacy (3.x) behaviour.
    [298] =>      *
    [299] =>      * @var string
    [300] =>      */
    [301] =>     private static $table_name = null;
    [302] => 
    [303] =>     /**
    [304] =>      * Non-static relationship cache, indexed by component name.
    [305] =>      *
    [306] =>      * @var DataObject[]
    [307] =>      */
    [308] =>     protected $components = [];
    [309] => 
    [310] =>     /**
    [311] =>      * Non-static cache of has_many and many_many relations that can't be written until this object is saved.
    [312] =>      *
    [313] =>      * @var UnsavedRelationList[]
    [314] =>      */
    [315] =>     protected $unsavedRelations;
    [316] => 
    [317] =>     /**
    [318] =>      * List of relations that should be cascade deleted, similar to `owns`
    [319] =>      * Note: This will trigger delete on many_many objects, not only the mapping table.
    [320] =>      * For many_many through you can specify the components you want to delete separately
    [321] =>      * (many_many or has_many sub-component)
    [322] =>      *
    [323] =>      * @config
    [324] =>      * @var array
    [325] =>      */
    [326] =>     private static $cascade_deletes = [];
    [327] => 
    [328] =>     /**
    [329] =>      * List of relations that should be cascade duplicate.
    [330] =>      * many_many duplications are shallow only.
    [331] =>      *
    [332] =>      * Note: If duplicating a many_many through you should refer to the
    [333] =>      * has_many intermediary relation instead, otherwise extra fields
    [334] =>      * will be omitted from the duplicated relation.
    [335] =>      *
    [336] =>      * @var array
    [337] =>      */
    [338] =>     private static $cascade_duplicates = [];
    [339] => 
    [340] =>     /**
    [341] =>      * Get schema object
    [342] =>      *
    [343] =>      * @return DataObjectSchema
    [344] =>      */
    [345] =>     public static function getSchema()
    [346] =>     {
    [347] =>         return Injector::inst()->get(DataObjectSchema::class);
    [348] =>     }
    [349] => 
    [350] =>     /**
    [351] =>      * Construct a new DataObject.
    [352] =>      *
    [353] =>      * @param array $record Initial record content, or rehydrated record content, depending on $creationType
    [354] =>      * @param int|boolean $creationType Set to DataObject::CREATE_OBJECT, DataObject::CREATE_HYDRATED,
    [355] =>      *   DataObject::CREATE_MEMORY_HYDRATED or DataObject::CREATE_SINGLETON. Used by Silverstripe internals and best
    [356] =>      *   left as the default by regular users.
    [357] =>      * @param array $queryParams List of DataQuery params necessary to lazy load, or load related objects.
    [358] =>      */
    [359] =>     public function __construct($record = [], $creationType = self::CREATE_OBJECT, $queryParams = [])
    [360] =>     {
    [361] =>         parent::__construct();
    [362] => 
    [363] =>         // Legacy $record default
    [364] =>         if ($record === null) {
    [365] =>             $record = [];
    [366] =>         }
    [367] => 
    [368] =>         // Legacy $isSingleton boolean
    [369] =>         if (!is_int($creationType)) {
    [370] =>             if (!is_bool($creationType)) {
    [371] =>                 user_error('Creation type is neither boolean (old isSingleton arg) nor integer (new arg), please review your code', E_USER_WARNING);
    [372] =>             }
    [373] =>             $creationType = $creationType ? self::CREATE_SINGLETON : self::CREATE_OBJECT;
    [374] =>         }
    [375] => 
    [376] =>         // Set query params on the DataObject to tell the lazy loading mechanism the context the object creation context
    [377] =>         $this->setSourceQueryParams($queryParams);
    [378] => 
    [379] =>         // Set $this->record to $record, but ignore NULLs
    [380] =>         $this->record = [];
    [381] => 
    [382] =>         switch ($creationType) {
    [383] =>             // Hydrate a record
    [384] =>             case self::CREATE_HYDRATED:
    [385] =>             case self::CREATE_MEMORY_HYDRATED:
    [386] =>                 $this->hydrate($record, $creationType === self::CREATE_HYDRATED);
    [387] =>                 break;
    [388] => 
    [389] =>             // Create a new object, using the constructor argument as the initial content
    [390] =>             case self::CREATE_OBJECT:
    [391] =>                 if ($record instanceof stdClass) {
    [392] =>                     $record = (array)$record;
    [393] =>                 }
    [394] => 
    [395] =>                 if (!is_array($record)) {
    [396] =>                     if (is_object($record)) {
    [397] =>                         $passed = "an object of type '" . get_class($record) . "'";
    [398] =>                     } else {
    [399] =>                         $passed = "The value '$record'";
    [400] =>                     }
    [401] => 
    [402] =>                     user_error(
    [403] =>                         "DataObject::__construct passed $passed.  It's supposed to be passed an array,"
    [404] =>                         . " taken straight from the database.  Perhaps you should use DataList::create()->First(); instead?",
    [405] =>                         E_USER_WARNING
    [406] =>                     );
    [407] =>                     $record = [];
    [408] =>                 }
    [409] => 
    [410] =>                 // Default columns
    [411] =>                 $this->record['ID'] = empty($record['ID']) ? 0 : $record['ID'];
    [412] =>                 $this->record['ClassName'] = static::class;
    [413] =>                 $this->record['RecordClassName'] = static::class;
    [414] =>                 unset($record['ID']);
    [415] =>                 $this->original = $this->record;
    [416] => 
    [417] =>                 $this->populateDefaults();
    [418] => 
    [419] =>                 // prevent populateDefaults() and setField() from marking overwritten defaults as changed
    [420] =>                 $this->changed = [];
    [421] =>                 $this->changeForced = false;
    [422] => 
    [423] =>                 // Set the data passed in the constructor, allowing for defaults and calling setters
    [424] =>                 // This will mark fields as changed
    [425] =>                 if ($record) {
    [426] =>                     $this->update($record);
    [427] =>                 }
    [428] =>                 break;
    [429] => 
    [430] =>             case self::CREATE_SINGLETON:
    [431] =>                 // No setting happens for a singleton
    [432] =>                 $this->record['ID'] = 0;
    [433] =>                 $this->record['ClassName'] = static::class;
    [434] =>                 $this->record['RecordClassName'] = static::class;
    [435] =>                 $this->original = $this->record;
    [436] =>                 $this->changed = [];
    [437] =>                 $this->changeForced = false;
    [438] =>                 break;
    [439] => 
    [440] =>             default:
    [441] =>                 throw new \LogicException('Bad creationType ' . $this->creationType);
    [442] =>         }
    [443] =>     }
    [444] => 
    [445] =>     /**
    [446] =>      * Constructor hydration logic for CREATE_HYDRATED and CREATE_MEMORY_HYDRATED.
    [447] =>      * @param array $record
    [448] =>      * @param bool $mustHaveID If true, an exception will be thrown if $record doesn't have an ID.
    [449] =>      */
    [450] =>     private function hydrate(array $record, bool $mustHaveID)
    [451] =>     {
    [452] =>         if ($mustHaveID && empty($record['ID'])) {
    [453] =>             // CREATE_HYDRATED requires an ID to be included in the record
    [454] =>             throw new \InvalidArgumentException(
    [455] =>                 "Hydrated records must be passed a record array including an ID."
    [456] =>             );
    [457] =>         } elseif (empty($record['ID'])) {
    [458] =>             // CREATE_MEMORY_HYDRATED implicitly set the record ID to 0 if not provided
    [459] =>             $record['ID'] = 0;
    [460] =>         }
    [461] => 
    [462] =>         $this->record = $record;
    [463] => 
    [464] =>         // Identify fields that should be lazy loaded, but only on existing records
    [465] =>         // Get all field specs scoped to class for later lazy loading
    [466] =>         $fields = static::getSchema()->fieldSpecs(
    [467] =>             static::class,
    [468] =>             DataObjectSchema::INCLUDE_CLASS | DataObjectSchema::DB_ONLY
    [469] =>         );
    [470] => 
    [471] =>         foreach ($fields as $field => $fieldSpec) {
    [472] =>             $fieldClass = strtok($fieldSpec ?? '', ".");
    [473] =>             if (!array_key_exists($field, $record ?? [])) {
    [474] =>                 $this->record[$field . '_Lazy'] = $fieldClass;
    [475] =>             }
    [476] =>         }
    [477] => 
    [478] =>         // Extension point to hydrate additional fields into this object during construction.
    [479] =>         // Return an array of field names => raw values from your augmentHydrateFields extension method.
    [480] =>         $extendedAdditionalFields = $this->extend('augmentHydrateFields');
    [481] =>         foreach ($extendedAdditionalFields as $additionalFields) {
    [482] =>             foreach ($additionalFields as $field => $value) {
    [483] =>                 $this->record[$field] = $value;
    [484] => 
    [485] =>                 // If a corresponding lazy-load field exists, remove it as the value has been provided
    [486] =>                 $lazyName = $field . '_Lazy';
    [487] =>                 if (array_key_exists($lazyName, $this->record ?? [])) {
    [488] =>                     unset($this->record[$lazyName]);
    [489] =>                 }
    [490] =>             }
    [491] =>         }
    [492] => 
    [493] =>         $this->original = $this->record;
    [494] =>         $this->changed = [];
    [495] =>         $this->changeForced = false;
    [496] =>     }
    [497] => 
    [498] =>     /**
    [499] =>      * Destroy all of this objects dependent objects and local caches.
    [500] =>      * You'll need to call this to get the memory of an object that has components or extensions freed.
    [501] =>      */
    [502] =>     public function destroy()
    [503] =>     {
    [504] =>         $this->flushCache(false);
    [505] =>     }
    [506] => 
    [507] =>     /**
    [508] =>      * Create a duplicate of this node. Can duplicate many_many relations
    [509] =>      *
    [510] =>      * @param bool $doWrite Perform a write() operation before returning the object.
    [511] =>      * If this is true, it will create the duplicate in the database.
    [512] =>      * @param array|null|false $relations List of relations to duplicate.
    [513] =>      * Will default to `cascade_duplicates` if null.
    [514] =>      * Set to 'false' to force none.
    [515] =>      * Set to specific array of names to duplicate to override these.
    [516] =>      * Note: If using versioned, this will additionally failover to `owns` config.
    [517] =>      * @return static A duplicate of this node. The exact type will be the type of this node.
    [518] =>      */
    [519] =>     public function duplicate($doWrite = true, $relations = null)
    [520] =>     {
    [521] =>         // Handle legacy behaviour
    [522] =>         if (is_string($relations) || $relations === true) {
    [523] =>             if ($relations === true) {
    [524] =>                 $relations = 'many_many';
    [525] =>             }
    [526] =>             Deprecation::notice('5.0', 'Use cascade_duplicates config instead of providing a string to duplicate()');
    [527] =>             $relations = array_keys($this->config()->get($relations) ?? []) ?: [];
    [528] =>         }
    [529] => 
    [530] =>         // Get duplicates
    [531] =>         if ($relations === null) {
    [532] =>             $relations = $this->config()->get('cascade_duplicates');
    [533] =>             // Remove any duplicate entries before duplicating them
    [534] =>             if (is_array($relations)) {
    [535] =>                 $relations = array_unique($relations ?? []);
    [536] =>             }
    [537] =>         }
    [538] => 
    [539] =>         // Create unsaved raw duplicate
    [540] =>         $map = $this->toMap();
    [541] =>         unset($map['Created']);
    [542] =>         /** @var static $clone */
    [543] =>         $clone = Injector::inst()->create(static::class, $map, false, $this->getSourceQueryParams());
    [544] =>         $clone->ID = 0;
    [545] => 
    [546] =>         // Note: Extensions such as versioned may update $relations here
    [547] =>         $clone->invokeWithExtensions('onBeforeDuplicate', $this, $doWrite, $relations);
    [548] =>         if ($relations) {
    [549] =>             $this->duplicateRelations($this, $clone, $relations);
    [550] =>         }
    [551] =>         if ($doWrite) {
    [552] =>             $clone->write();
    [553] =>         }
    [554] =>         $clone->invokeWithExtensions('onAfterDuplicate', $this, $doWrite, $relations);
    [555] => 
    [556] =>         return $clone;
    [557] =>     }
    [558] => 
    [559] =>     /**
    [560] =>      * Copies the given relations from this object to the destination
    [561] =>      *
    [562] =>      * @param DataObject $sourceObject the source object to duplicate from
    [563] =>      * @param DataObject $destinationObject the destination object to populate with the duplicated relations
    [564] =>      * @param array $relations List of relations
    [565] =>      */
    [566] =>     protected function duplicateRelations($sourceObject, $destinationObject, $relations)
    [567] =>     {
    [568] =>         // Get list of duplicable relation types
    [569] =>         $manyMany = $sourceObject->manyMany();
    [570] =>         $hasMany = $sourceObject->hasMany();
    [571] =>         $hasOne = $sourceObject->hasOne();
    [572] =>         $belongsTo = $sourceObject->belongsTo();
    [573] => 
    [574] =>         // Duplicate each relation based on type
    [575] =>         foreach ($relations as $relation) {
    [576] =>             switch (true) {
    [577] =>                 case array_key_exists($relation, $manyMany): {
    [578] =>                     $this->duplicateManyManyRelation($sourceObject, $destinationObject, $relation);
    [579] =>                     break;
    [580] =>                 }
    [581] =>                 case array_key_exists($relation, $hasMany): {
    [582] =>                     $this->duplicateHasManyRelation($sourceObject, $destinationObject, $relation);
    [583] =>                     break;
    [584] =>                 }
    [585] =>                 case array_key_exists($relation, $hasOne): {
    [586] =>                     $this->duplicateHasOneRelation($sourceObject, $destinationObject, $relation);
    [587] =>                     break;
    [588] =>                 }
    [589] =>                 case array_key_exists($relation, $belongsTo): {
    [590] =>                     $this->duplicateBelongsToRelation($sourceObject, $destinationObject, $relation);
    [591] =>                     break;
    [592] =>                 }
    [593] =>                 default: {
    [594] =>                     $sourceType = get_class($sourceObject);
    [595] =>                     throw new InvalidArgumentException(
    [596] =>                         "Cannot duplicate unknown relation {$relation} on parent type {$sourceType}"
    [597] =>                     );
    [598] =>                 }
    [599] =>             }
    [600] =>         }
    [601] =>     }
    [602] => 
    [603] =>     /**
    [604] =>      * Copies the many_many and belongs_many_many relations from one object to another instance of the name of object.
    [605] =>      *
    [606] =>      * @deprecated 4.1.0 Use duplicateRelations() instead
    [607] =>      * @param DataObject $sourceObject the source object to duplicate from
    [608] =>      * @param DataObject $destinationObject the destination object to populate with the duplicated relations
    [609] =>      * @param bool|string $filter
    [610] =>      */
    [611] =>     protected function duplicateManyManyRelations($sourceObject, $destinationObject, $filter)
    [612] =>     {
    [613] =>         Deprecation::notice('4.1.0', 'Use duplicateRelations() instead');
    [614] => 
    [615] =>         // Get list of relations to duplicate
    [616] =>         if ($filter === 'many_many' || $filter === 'belongs_many_many') {
    [617] =>             $relations = $sourceObject->config()->get($filter);
    [618] =>         } elseif ($filter === true) {
    [619] =>             $relations = $sourceObject->manyMany();
    [620] =>         } else {
    [621] =>             throw new InvalidArgumentException("Invalid many_many duplication filter");
    [622] =>         }
    [623] =>         foreach ($relations as $manyManyName => $type) {
    [624] =>             $this->duplicateManyManyRelation($sourceObject, $destinationObject, $manyManyName);
    [625] =>         }
    [626] =>     }
    [627] => 
    [628] =>     /**
    [629] =>      * Duplicates a single many_many relation from one object to another.
    [630] =>      *
    [631] =>      * @param DataObject $sourceObject
    [632] =>      * @param DataObject $destinationObject
    [633] =>      * @param string $relation
    [634] =>      */
    [635] =>     protected function duplicateManyManyRelation($sourceObject, $destinationObject, $relation)
    [636] =>     {
    [637] =>         // Copy all components from source to destination
    [638] =>         $source = $sourceObject->getManyManyComponents($relation);
    [639] =>         $dest = $destinationObject->getManyManyComponents($relation);
    [640] => 
    [641] =>         if ($source instanceof ManyManyList) {
    [642] =>             $extraFieldNames = $source->getExtraFields();
    [643] =>         } else {
    [644] =>             $extraFieldNames = [];
    [645] =>         }
    [646] => 
    [647] =>         foreach ($source as $item) {
    [648] =>             // Merge extra fields
    [649] =>             $extraFields = [];
    [650] =>             foreach ($extraFieldNames as $fieldName => $fieldType) {
    [651] =>                 $extraFields[$fieldName] = $item->getField($fieldName);
    [652] =>             }
    [653] =>             $dest->add($item, $extraFields);
    [654] =>         }
    [655] =>     }
    [656] => 
    [657] =>     /**
    [658] =>      * Duplicates a single many_many relation from one object to another.
    [659] =>      *
    [660] =>      * @param DataObject $sourceObject
    [661] =>      * @param DataObject $destinationObject
    [662] =>      * @param string $relation
    [663] =>      */
    [664] =>     protected function duplicateHasManyRelation($sourceObject, $destinationObject, $relation)
    [665] =>     {
    [666] =>         // Copy all components from source to destination
    [667] =>         $source = $sourceObject->getComponents($relation);
    [668] =>         $dest = $destinationObject->getComponents($relation);
    [669] => 
    [670] =>         /** @var DataObject $item */
    [671] =>         foreach ($source as $item) {
    [672] =>             // Don't write on duplicate; Wait until ParentID is available later.
    [673] =>             // writeRelations() will eventually write these records when converting
    [674] =>             // from UnsavedRelationList
    [675] =>             $clonedItem = $item->duplicate(false);
    [676] =>             $dest->add($clonedItem);
    [677] =>         }
    [678] =>     }
    [679] => 
    [680] =>     /**
    [681] =>      * Duplicates a single has_one relation from one object to another.
    [682] =>      * Note: Child object will be force written.
    [683] =>      *
    [684] =>      * @param DataObject $sourceObject
    [685] =>      * @param DataObject $destinationObject
    [686] =>      * @param string $relation
    [687] =>      */
    [688] =>     protected function duplicateHasOneRelation($sourceObject, $destinationObject, $relation)
    [689] =>     {
    [690] =>         // Check if original object exists
    [691] =>         $item = $sourceObject->getComponent($relation);
    [692] =>         if (!$item->isInDB()) {
    [693] =>             return;
    [694] =>         }
    [695] => 
    [696] =>         $clonedItem = $item->duplicate(false);
    [697] =>         $destinationObject->setComponent($relation, $clonedItem);
    [698] =>     }
    [699] => 
    [700] =>     /**
    [701] =>      * Duplicates a single belongs_to relation from one object to another.
    [702] =>      * Note: This will force a write on both parent / child objects.
    [703] =>      *
    [704] =>      * @param DataObject $sourceObject
    [705] =>      * @param DataObject $destinationObject
    [706] =>      * @param string $relation
    [707] =>      */
    [708] =>     protected function duplicateBelongsToRelation($sourceObject, $destinationObject, $relation)
    [709] =>     {
    [710] =>         // Check if original object exists
    [711] =>         $item = $sourceObject->getComponent($relation);
    [712] =>         if (!$item->isInDB()) {
    [713] =>             return;
    [714] =>         }
    [715] => 
    [716] =>         $clonedItem = $item->duplicate(false);
    [717] =>         $destinationObject->setComponent($relation, $clonedItem);
    [718] =>         // After $clonedItem is assigned the appropriate FieldID / FieldClass, force write
    [719] =>         // @todo Write this component in onAfterWrite instead, assigning the FieldID then
    [720] =>         // https://github.com/silverstripe/silverstripe-framework/issues/7818
    [721] =>         $clonedItem->write();
    [722] =>     }
    [723] => 
    [724] =>     /**
    [725] =>      * Return obsolete class name, if this is no longer a valid class
    [726] =>      *
    [727] =>      * @return string
    [728] =>      */
    [729] =>     public function getObsoleteClassName()
    [730] =>     {
    [731] =>         $className = $this->getField("ClassName");
    [732] =>         if (!ClassInfo::exists($className)) {
    [733] =>             return $className;
    [734] =>         }
    [735] =>         return null;
    [736] =>     }
    [737] => 
    [738] =>     /**
    [739] =>      * Gets name of this class
    [740] =>      *
    [741] =>      * @return string
    [742] =>      */
    [743] =>     public function getClassName()
    [744] =>     {
    [745] =>         $className = $this->getField("ClassName");
    [746] =>         if (!ClassInfo::exists($className)) {
    [747] =>             return static::class;
    [748] =>         }
    [749] =>         return $className;
    [750] =>     }
    [751] => 
    [752] =>     /**
    [753] =>      * Set the ClassName attribute. {@link $class} is also updated.
    [754] =>      * Warning: This will produce an inconsistent record, as the object
    [755] =>      * instance will not automatically switch to the new subclass.
    [756] =>      * Please use {@link newClassInstance()} for this purpose,
    [757] =>      * or destroy and reinstanciate the record.
    [758] =>      *
    [759] =>      * @param string $className The new ClassName attribute (a subclass of {@link DataObject})
    [760] =>      * @return $this
    [761] =>      */
    [762] =>     public function setClassName($className)
    [763] =>     {
    [764] =>         $className = trim($className ?? '');
    [765] =>         if (!$className || !is_subclass_of($className, self::class)) {
    [766] =>             return $this;
    [767] =>         }
    [768] => 
    [769] =>         $this->setField("ClassName", $className);
    [770] =>         $this->setField('RecordClassName', $className);
    [771] =>         return $this;
    [772] =>     }
    [773] => 
    [774] =>     /**
    [775] =>      * Create a new instance of a different class from this object's record.
    [776] =>      * This is useful when dynamically changing the type of an instance. Specifically,
    [777] =>      * it ensures that the instance of the class is a match for the className of the
    [778] =>      * record. Don't set the {@link DataObject->class} or {@link DataObject->ClassName}
    [779] =>      * property manually before calling this method, as it will confuse change detection.
    [780] =>      *
    [781] =>      * If the new class is different to the original class, defaults are populated again
    [782] =>      * because this will only occur automatically on instantiation of a DataObject if
    [783] =>      * there is no record, or the record has no ID. In this case, we do have an ID but
    [784] =>      * we still need to repopulate the defaults.
    [785] =>      *
    [786] =>      * @param string $newClassName The name of the new class
    [787] =>      *
    [788] =>      * @return DataObject The new instance of the new class, The exact type will be of the class name provided.
    [789] =>      */
    [790] =>     public function newClassInstance($newClassName)
    [791] =>     {
    [792] =>         if (!is_subclass_of($newClassName, self::class)) {
    [793] =>             throw new InvalidArgumentException("$newClassName is not a valid subclass of DataObject");
    [794] =>         }
    [795] => 
    [796] =>         $originalClass = $this->ClassName;
    [797] => 
    [798] =>         /** @var DataObject $newInstance */
    [799] =>         $newInstance = Injector::inst()->create($newClassName, $this->record, self::CREATE_MEMORY_HYDRATED);
    [800] => 
    [801] =>         // Modify ClassName
    [802] =>         if ($newClassName != $originalClass) {
    [803] =>             $newInstance->setClassName($newClassName);
    [804] =>             $newInstance->populateDefaults();
    [805] =>             $newInstance->forceChange();
    [806] =>         }
    [807] => 
    [808] =>         return $newInstance;
    [809] =>     }
    [810] => 
    [811] =>     /**
    [812] =>      * Adds methods from the extensions.
    [813] =>      * Called by Object::__construct() once per class.
    [814] =>      */
    [815] =>     public function defineMethods()
    [816] =>     {
    [817] =>         parent::defineMethods();
    [818] => 
    [819] =>         if (static::class === self::class) {
    [820] =>             return;
    [821] =>         }
    [822] => 
    [823] =>         // Set up accessors for joined items
    [824] =>         if ($manyMany = $this->manyMany()) {
    [825] =>             foreach ($manyMany as $relationship => $class) {
    [826] =>                 $this->addWrapperMethod($relationship, 'getManyManyComponents');
    [827] =>             }
    [828] =>         }
    [829] =>         if ($hasMany = $this->hasMany()) {
    [830] =>             foreach ($hasMany as $relationship => $class) {
    [831] =>                 $this->addWrapperMethod($relationship, 'getComponents');
    [832] =>             }
    [833] =>         }
    [834] =>         if ($hasOne = $this->hasOne()) {
    [835] =>             foreach ($hasOne as $relationship => $class) {
    [836] =>                 $this->addWrapperMethod($relationship, 'getComponent');
    [837] =>             }
    [838] =>         }
    [839] =>         if ($belongsTo = $this->belongsTo()) {
    [840] =>             foreach (array_keys($belongsTo ?? []) as $relationship) {
    [841] =>                 $this->addWrapperMethod($relationship, 'getComponent');
    [842] =>             }
    [843] =>         }
    [844] =>     }
    [845] => 
    [846] =>     /**
    [847] =>      * Returns true if this object "exists", i.e., has a sensible value.
    [848] =>      * The default behaviour for a DataObject is to return true if
    [849] =>      * the object exists in the database, you can override this in subclasses.
    [850] =>      *
    [851] =>      * @return boolean true if this object exists
    [852] =>      */
    [853] =>     public function exists()
    [854] =>     {
    [855] =>         return $this->isInDB();
    [856] =>     }
    [857] => 
    [858] =>     /**
    [859] =>      * Returns TRUE if all values (other than "ID") are
    [860] =>      * considered empty (by weak boolean comparison).
    [861] =>      *
    [862] =>      * @return boolean
    [863] =>      */
    [864] =>     public function isEmpty()
    [865] =>     {
    [866] =>         $fixed = DataObject::config()->uninherited('fixed_fields');
    [867] =>         foreach ($this->toMap() as $field => $value) {
    [868] =>             // only look at custom fields
    [869] =>             if (isset($fixed[$field])) {
    [870] =>                 continue;
    [871] =>             }
    [872] => 
    [873] =>             $dbObject = $this->dbObject($field);
    [874] =>             if (!$dbObject) {
    [875] =>                 continue;
    [876] =>             }
    [877] =>             if ($dbObject->exists()) {
    [878] =>                 return false;
    [879] =>             }
    [880] =>         }
    [881] =>         return true;
    [882] =>     }
    [883] => 
    [884] =>     /**
    [885] =>      * Pluralise this item given a specific count.
    [886] =>      *
    [887] =>      * E.g. "0 Pages", "1 File", "3 Images"
    [888] =>      *
    [889] =>      * @param string $count
    [890] =>      * @return string
    [891] =>      */
    [892] =>     public function i18n_pluralise($count)
    [893] =>     {
    [894] =>         $default = 'one ' . $this->i18n_singular_name() . '|{count} ' . $this->i18n_plural_name();
    [895] =>         return i18n::_t(
    [896] =>             static::class . '.PLURALS',
    [897] =>             $default,
    [898] =>             ['count' => $count]
    [899] =>         );
    [900] =>     }
    [901] => 
    [902] =>     /**
    [903] =>      * Get the user friendly singular name of this DataObject.
    [904] =>      * If the name is not defined (by redefining $singular_name in the subclass),
    [905] =>      * this returns the class name.
    [906] =>      *
    [907] =>      * @return string User friendly singular name of this DataObject
    [908] =>      */
    [909] =>     public function singular_name()
    [910] =>     {
    [911] =>         $name = $this->config()->get('singular_name');
    [912] =>         if ($name) {
    [913] =>             return $name;
    [914] =>         }
    [915] =>         return ucwords(trim(strtolower(preg_replace(
    [916] =>             '/_?([A-Z])/',
    [917] =>             ' $1',
    [918] =>             ClassInfo::shortName($this) ?? ''
    [919] =>         ) ?? '')));
    [920] =>     }
    [921] => 
    [922] =>     /**
    [923] =>      * Get the translated user friendly singular name of this DataObject
    [924] =>      * same as singular_name() but runs it through the translating function
    [925] =>      *
    [926] =>      * Translating string is in the form:
    [927] =>      *     $this->class.SINGULARNAME
    [928] =>      * Example:
    [929] =>      *     Page.SINGULARNAME
    [930] =>      *
    [931] =>      * @return string User friendly translated singular name of this DataObject
    [932] =>      */
    [933] =>     public function i18n_singular_name()
    [934] =>     {
    [935] =>         return _t(static::class . '.SINGULARNAME', $this->singular_name());
    [936] =>     }
    [937] => 
    [938] =>     /**
    [939] =>      * Get the user friendly plural name of this DataObject
    [940] =>      * If the name is not defined (by renaming $plural_name in the subclass),
    [941] =>      * this returns a pluralised version of the class name.
    [942] =>      *
    [943] =>      * @return string User friendly plural name of this DataObject
    [944] =>      */
    [945] =>     public function plural_name()
    [946] =>     {
    [947] =>         if ($name = $this->config()->get('plural_name')) {
    [948] =>             return $name;
    [949] =>         }
    [950] =>         $name = $this->singular_name();
    [951] =>         //if the penultimate character is not a vowel, replace "y" with "ies"
    [952] =>         if (preg_match('/[^aeiou]y$/i', $name ?? '')) {
    [953] =>             $name = substr($name ?? '', 0, -1) . 'ie';
    [954] =>         }
    [955] =>         return ucfirst($name . 's');
    [956] =>     }
    [957] => 
    [958] =>     /**
    [959] =>      * Get the translated user friendly plural name of this DataObject
    [960] =>      * Same as plural_name but runs it through the translation function
    [961] =>      * Translation string is in the form:
    [962] =>      *      $this->class.PLURALNAME
    [963] =>      * Example:
    [964] =>      *      Page.PLURALNAME
    [965] =>      *
    [966] =>      * @return string User friendly translated plural name of this DataObject
    [967] =>      */
    [968] =>     public function i18n_plural_name()
    [969] =>     {
    [970] =>         return _t(static::class . '.PLURALNAME', $this->plural_name());
    [971] =>     }
    [972] => 
    [973] =>     /**
    [974] =>      * Standard implementation of a title/label for a specific
    [975] =>      * record. Tries to find properties 'Title' or 'Name',
    [976] =>      * and falls back to the 'ID'. Useful to provide
    [977] =>      * user-friendly identification of a record, e.g. in errormessages
    [978] =>      * or UI-selections.
    [979] =>      *
    [980] =>      * Overload this method to have a more specialized implementation,
    [981] =>      * e.g. for an Address record this could be:
    [982] =>      * <code>
    [983] =>      * function getTitle() {
    [984] =>      *   return "{$this->StreetNumber} {$this->StreetName} {$this->City}";
    [985] =>      * }
    [986] =>      * </code>
    [987] =>      *
    [988] =>      * @return string
    [989] =>      */
    [990] =>     public function getTitle()
    [991] =>     {
    [992] =>         $schema = static::getSchema();
    [993] =>         if ($schema->fieldSpec($this, 'Title')) {
    [994] =>             return $this->getField('Title');
    [995] =>         }
    [996] =>         if ($schema->fieldSpec($this, 'Name')) {
    [997] =>             return $this->getField('Name');
    [998] =>         }
    [999] => 
    [1000] =>         return "#{$this->ID}";
    [1001] =>     }
    [1002] => 
    [1003] =>     /**
    [1004] =>      * Returns the associated database record - in this case, the object itself.
    [1005] =>      * This is included so that you can call $dataOrController->data() and get a DataObject all the time.
    [1006] =>      *
    [1007] =>      * @return DataObject Associated database record
    [1008] =>      */
    [1009] =>     public function data()
    [1010] =>     {
    [1011] =>         return $this;
    [1012] =>     }
    [1013] => 
    [1014] =>     /**
    [1015] =>      * Convert this object to a map.
    [1016] =>      * Note that it has the following quirks:
    [1017] =>      *  - custom getters, including those that adjust the result of database fields, won't be executed
    [1018] =>      *  - NULL values won't be returned.
    [1019] =>      *
    [1020] =>      * @return array The data as a map.
    [1021] =>      */
    [1022] =>     public function toMap()
    [1023] =>     {
    [1024] =>         $this->loadLazyFields();
    [1025] =>         return array_filter($this->record ?? [], function ($val) {
    [1026] =>             return $val !== null;
    [1027] =>         });
    [1028] =>     }
    [1029] => 
    [1030] =>     /**
    [1031] =>      * Return all currently fetched database fields.
    [1032] =>      *
    [1033] =>      * This function is similar to toMap() but doesn't trigger the lazy-loading of all unfetched fields.
    [1034] =>      * Obviously, this makes it a lot faster.
    [1035] =>      *
    [1036] =>      * @return array The data as a map.
    [1037] =>      */
    [1038] =>     public function getQueriedDatabaseFields()
    [1039] =>     {
    [1040] =>         return $this->record;
    [1041] =>     }
    [1042] => 
    [1043] =>     /**
    [1044] =>      * Update a number of fields on this object, given a map of the desired changes.
    [1045] =>      *
    [1046] =>      * The field names can be simple names, or you can use a dot syntax to access $has_one relations.
    [1047] =>      * For example, array("Author.FirstName" => "Jim") will set $this->Author()->FirstName to "Jim".
    [1048] =>      *
    [1049] =>      * Doesn't write the main object, but if you use the dot syntax, it will write()
    [1050] =>      * the related objects that it alters.
    [1051] =>      *
    [1052] =>      * When using this method with user supplied data, it's very important to
    [1053] =>      * whitelist the allowed keys.
    [1054] =>      *
    [1055] =>      * @param array $data A map of field name to data values to update.
    [1056] =>      * @return DataObject $this
    [1057] =>      */
    [1058] =>     public function update($data)
    [1059] =>     {
    [1060] =>         foreach ($data as $key => $value) {
    [1061] =>             // Implement dot syntax for updates
    [1062] =>             if (strpos($key ?? '', '.') !== false) {
    [1063] =>                 $relations = explode('.', $key ?? '');
    [1064] =>                 $fieldName = array_pop($relations);
    [1065] =>                 /** @var static $relObj */
    [1066] =>                 $relObj = $this;
    [1067] =>                 $relation = null;
    [1068] =>                 foreach ($relations as $i => $relation) {
    [1069] =>                     // no support for has_many or many_many relationships,
    [1070] =>                     // as the updater wouldn't know which object to write to (or create)
    [1071] =>                     if ($relObj->$relation() instanceof DataObject) {
    [1072] =>                         $parentObj = $relObj;
    [1073] =>                         $relObj = $relObj->$relation();
    [1074] =>                         // If the intermediate relationship objects haven't been created, then write them
    [1075] =>                         if ($i < sizeof($relations ?? []) - 1 && !$relObj->ID || (!$relObj->ID && $parentObj !== $this)) {
    [1076] =>                             $relObj->write();
    [1077] =>                             $relatedFieldName = $relation . "ID";
    [1078] =>                             $parentObj->$relatedFieldName = $relObj->ID;
    [1079] =>                             $parentObj->write();
    [1080] =>                         }
    [1081] =>                     } else {
    [1082] =>                         user_error(
    [1083] =>                             "DataObject::update(): Can't traverse relationship '$relation'," .
    [1084] =>                             "it has to be a has_one relationship or return a single DataObject",
    [1085] =>                             E_USER_NOTICE
    [1086] =>                         );
    [1087] =>                         // unset relation object so we don't write properties to the wrong object
    [1088] =>                         $relObj = null;
    [1089] =>                         break;
    [1090] =>                     }
    [1091] =>                 }
    [1092] => 
    [1093] =>                 if ($relObj) {
    [1094] =>                     $relObj->$fieldName = $value;
    [1095] =>                     $relObj->write();
    [1096] =>                     $relatedFieldName = $relation . "ID";
    [1097] =>                     $this->$relatedFieldName = $relObj->ID;
    [1098] =>                     $relObj->flushCache();
    [1099] =>                 } else {
    [1100] =>                     $class = static::class;
    [1101] =>                     user_error("Couldn't follow dot syntax '{$key}' on '{$class}' object", E_USER_WARNING);
    [1102] =>                 }
    [1103] =>             } else {
    [1104] =>                 $this->$key = $value;
    [1105] =>             }
    [1106] =>         }
    [1107] =>         return $this;
    [1108] =>     }
    [1109] => 
    [1110] =>     /**
    [1111] =>      * Pass changes as a map, and try to
    [1112] =>      * get automatic casting for these fields.
    [1113] =>      * Doesn't write to the database. To write the data,
    [1114] =>      * use the write() method.
    [1115] =>      *
    [1116] =>      * @param array $data A map of field name to data values to update.
    [1117] =>      * @return DataObject $this
    [1118] =>      */
    [1119] =>     public function castedUpdate($data)
    [1120] =>     {
    [1121] =>         foreach ($data as $k => $v) {
    [1122] =>             $this->setCastedField($k, $v);
    [1123] =>         }
    [1124] =>         return $this;
    [1125] =>     }
    [1126] => 
    [1127] =>     /**
    [1128] =>      * Merges data and relations from another object of same class,
    [1129] =>      * without conflict resolution. Allows to specify which
    [1130] =>      * dataset takes priority in case its not empty.
    [1131] =>      * has_one-relations are just transferred with priority 'right'.
    [1132] =>      * has_many and many_many-relations are added regardless of priority.
    [1133] =>      *
    [1134] =>      * Caution: has_many/many_many relations are moved rather than duplicated,
    [1135] =>      * meaning they are not connected to the merged object any longer.
    [1136] =>      * Caution: Just saves updated has_many/many_many relations to the database,
    [1137] =>      * doesn't write the updated object itself (just writes the object-properties).
    [1138] =>      * Caution: Does not delete the merged object.
    [1139] =>      * Caution: Does now overwrite Created date on the original object.
    [1140] =>      *
    [1141] =>      * @param DataObject $rightObj
    [1142] =>      * @param string $priority left|right Determines who wins in case of a conflict (optional)
    [1143] =>      * @param bool $includeRelations Merge any existing relations (optional)
    [1144] =>      * @param bool $overwriteWithEmpty Overwrite existing left values with empty right values.
    [1145] =>      *                            Only applicable with $priority='right'. (optional)
    [1146] =>      * @return Boolean
    [1147] =>      */
    [1148] =>     public function merge($rightObj, $priority = 'right', $includeRelations = true, $overwriteWithEmpty = false)
    [1149] =>     {
    [1150] =>         $leftObj = $this;
    [1151] => 
    [1152] =>         if ($leftObj->ClassName != $rightObj->ClassName) {
    [1153] =>             // we can't merge similar subclasses because they might have additional relations
    [1154] =>             user_error("DataObject->merge(): Invalid object class '{$rightObj->ClassName}'
    [1155] => 			(expected '{$leftObj->ClassName}').", E_USER_WARNING);
    [1156] =>             return false;
    [1157] =>         }
    [1158] => 
    [1159] =>         if (!$rightObj->ID) {
    [1160] =>             user_error("DataObject->merge(): Please write your merged-in object to the database before merging,
    [1161] => 				to make sure all relations are transferred properly.').", E_USER_WARNING);
    [1162] =>             return false;
    [1163] =>         }
    [1164] => 
    [1165] =>         // makes sure we don't merge data like ID or ClassName
    [1166] =>         $rightData = DataObject::getSchema()->fieldSpecs(get_class($rightObj));
    [1167] =>         foreach ($rightData as $key => $rightSpec) {
    [1168] =>             // Don't merge ID
    [1169] =>             if ($key === 'ID') {
    [1170] =>                 continue;
    [1171] =>             }
    [1172] => 
    [1173] =>             // Only merge relations if allowed
    [1174] =>             if ($rightSpec === 'ForeignKey' && !$includeRelations) {
    [1175] =>                 continue;
    [1176] =>             }
    [1177] => 
    [1178] =>             // don't merge conflicting values if priority is 'left'
    [1179] =>             if ($priority == 'left' && $leftObj->{$key} !== $rightObj->{$key}) {
    [1180] =>                 continue;
    [1181] =>             }
    [1182] => 
    [1183] =>             // don't overwrite existing left values with empty right values (if $overwriteWithEmpty is set)
    [1184] =>             if ($priority == 'right' && !$overwriteWithEmpty && empty($rightObj->{$key})) {
    [1185] =>                 continue;
    [1186] =>             }
    [1187] => 
    [1188] =>             // TODO remove redundant merge of has_one fields
    [1189] =>             $leftObj->{$key} = $rightObj->{$key};
    [1190] =>         }
    [1191] => 
    [1192] =>         // merge relations
    [1193] =>         if ($includeRelations) {
    [1194] =>             if ($manyMany = $this->manyMany()) {
    [1195] =>                 foreach ($manyMany as $relationship => $class) {
    [1196] =>                     /** @var DataObject $leftComponents */
    [1197] =>                     $leftComponents = $leftObj->getManyManyComponents($relationship);
    [1198] =>                     $rightComponents = $rightObj->getManyManyComponents($relationship);
    [1199] =>                     if ($rightComponents && $rightComponents->exists()) {
    [1200] =>                         $leftComponents->addMany($rightComponents->column('ID'));
    [1201] =>                     }
    [1202] =>                     $leftComponents->write();
    [1203] =>                 }
    [1204] =>             }
    [1205] => 
    [1206] =>             if ($hasMany = $this->hasMany()) {
    [1207] =>                 foreach ($hasMany as $relationship => $class) {
    [1208] =>                     $leftComponents = $leftObj->getComponents($relationship);
    [1209] =>                     $rightComponents = $rightObj->getComponents($relationship);
    [1210] =>                     if ($rightComponents && $rightComponents->exists()) {
    [1211] =>                         $leftComponents->addMany($rightComponents->column('ID'));
    [1212] =>                     }
    [1213] =>                     $leftComponents->write();
    [1214] =>                 }
    [1215] =>             }
    [1216] =>         }
    [1217] => 
    [1218] =>         return true;
    [1219] =>     }
    [1220] => 
    [1221] =>     /**
    [1222] =>      * Forces the record to think that all its data has changed.
    [1223] =>      * Doesn't write to the database. Force-change preserved until
    [1224] =>      * next write. Existing CHANGE_VALUE or CHANGE_STRICT values
    [1225] =>      * are preserved.
    [1226] =>      *
    [1227] =>      * @return $this
    [1228] =>      */
    [1229] =>     public function forceChange()
    [1230] =>     {
    [1231] =>         // Ensure lazy fields loaded
    [1232] =>         $this->loadLazyFields();
    [1233] => 
    [1234] =>         // Populate the null values in record so that they actually get written
    [1235] =>         foreach (array_keys(static::getSchema()->fieldSpecs(static::class) ?? []) as $fieldName) {
    [1236] =>             if (!isset($this->record[$fieldName])) {
    [1237] =>                 $this->record[$fieldName] = null;
    [1238] =>             }
    [1239] =>         }
    [1240] => 
    [1241] =>         $this->changeForced = true;
    [1242] => 
    [1243] =>         return $this;
    [1244] =>     }
    [1245] => 
    [1246] =>     /**
    [1247] =>      * Validate the current object.
    [1248] =>      *
    [1249] =>      * By default, there is no validation - objects are always valid!  However, you can overload this method in your
    [1250] =>      * DataObject sub-classes to specify custom validation, or use the hook through DataExtension.
    [1251] =>      *
    [1252] =>      * Invalid objects won't be able to be written - a warning will be thrown and no write will occur.  onBeforeWrite()
    [1253] =>      * and onAfterWrite() won't get called either.
    [1254] =>      *
    [1255] =>      * It is expected that you call validate() in your own application to test that an object is valid before
    [1256] =>      * attempting a write, and respond appropriately if it isn't.
    [1257] =>      *
    [1258] =>      * @see {@link ValidationResult}
    [1259] =>      * @return ValidationResult
    [1260] =>      */
    [1261] =>     public function validate()
    [1262] =>     {
    [1263] =>         $result = ValidationResult::create();
    [1264] =>         $this->extend('validate', $result);
    [1265] =>         return $result;
    [1266] =>     }
    [1267] => 
    [1268] =>     /**
    [1269] =>      * Public accessor for {@see DataObject::validate()}
    [1270] =>      *
    [1271] =>      * @return ValidationResult
    [1272] =>      * @deprecated 4.12.0 Use validate() instead
    [1273] =>      */
    [1274] =>     public function doValidate()
    [1275] =>     {
    [1276] =>         Deprecation::notice('4.12.0', 'Use validate() instead');
    [1277] =>         return $this->validate();
    [1278] =>     }
    [1279] => 
    [1280] =>     /**
    [1281] =>      * Event handler called before writing to the database.
    [1282] =>      * You can overload this to clean up or otherwise process data before writing it to the
    [1283] =>      * database.  Don't forget to call parent::onBeforeWrite(), though!
    [1284] =>      *
    [1285] =>      * This called after {@link $this->validate()}, so you can be sure that your data is valid.
    [1286] =>      *
    [1287] =>      * @uses DataExtension::onBeforeWrite()
    [1288] =>      */
    [1289] =>     protected function onBeforeWrite()
    [1290] =>     {
    [1291] =>         $this->brokenOnWrite = false;
    [1292] => 
    [1293] =>         $dummy = null;
    [1294] =>         $this->extend('onBeforeWrite', $dummy);
    [1295] =>     }
    [1296] => 
    [1297] =>     /**
    [1298] =>      * Event handler called after writing to the database.
    [1299] =>      * You can overload this to act upon changes made to the data after it is written.
    [1300] =>      * $this->changed will have a record
    [1301] =>      * database.  Don't forget to call parent::onAfterWrite(), though!
    [1302] =>      *
    [1303] =>      * @uses DataExtension::onAfterWrite()
    [1304] =>      */
    [1305] =>     protected function onAfterWrite()
    [1306] =>     {
    [1307] =>         $dummy = null;
    [1308] =>         $this->extend('onAfterWrite', $dummy);
    [1309] =>     }
    [1310] => 
    [1311] =>     /**
    [1312] =>      * Find all objects that will be cascade deleted if this object is deleted
    [1313] =>      *
    [1314] =>      * Notes:
    [1315] =>      *   - If this object is versioned, objects will only be searched in the same stage as the given record.
    [1316] =>      *   - This will only be useful prior to deletion, as post-deletion this record will no longer exist.
    [1317] =>      *
    [1318] =>      * @param bool $recursive True if recursive
    [1319] =>      * @param ArrayList $list Optional list to add items to
    [1320] =>      * @return ArrayList list of objects
    [1321] =>      */
    [1322] =>     public function findCascadeDeletes($recursive = true, $list = null)
    [1323] =>     {
    [1324] =>         // Find objects in these relationships
    [1325] =>         return $this->findRelatedObjects('cascade_deletes', $recursive, $list);
    [1326] =>     }
    [1327] => 
    [1328] =>     /**
    [1329] =>      * Event handler called before deleting from the database.
    [1330] =>      * You can overload this to clean up or otherwise process data before delete this
    [1331] =>      * record.  Don't forget to call parent::onBeforeDelete(), though!
    [1332] =>      *
    [1333] =>      * @uses DataExtension::onBeforeDelete()
    [1334] =>      */
    [1335] =>     protected function onBeforeDelete()
    [1336] =>     {
    [1337] =>         $this->brokenOnDelete = false;
    [1338] => 
    [1339] =>         $dummy = null;
    [1340] =>         $this->extend('onBeforeDelete', $dummy);
    [1341] => 
    [1342] =>         // Cascade deletes
    [1343] =>         $deletes = $this->findCascadeDeletes(false);
    [1344] =>         foreach ($deletes as $delete) {
    [1345] =>             $delete->delete();
    [1346] =>         }
    [1347] =>     }
    [1348] => 
    [1349] =>     protected function onAfterDelete()
    [1350] =>     {
    [1351] =>         $this->extend('onAfterDelete');
    [1352] =>     }
    [1353] => 
    [1354] =>     /**
    [1355] =>      * Load the default values in from the self::$defaults array.
    [1356] =>      * Will traverse the defaults of the current class and all its parent classes.
    [1357] =>      * Called by the constructor when creating new records.
    [1358] =>      *
    [1359] =>      * @uses DataExtension::populateDefaults()
    [1360] =>      * @return DataObject $this
    [1361] =>      */
    [1362] =>     public function populateDefaults()
    [1363] =>     {
    [1364] =>         $classes = array_reverse(ClassInfo::ancestry($this) ?? []);
    [1365] => 
    [1366] =>         foreach ($classes as $class) {
    [1367] =>             $defaults = Config::inst()->get($class, 'defaults', Config::UNINHERITED);
    [1368] => 
    [1369] =>             if ($defaults && !is_array($defaults)) {
    [1370] =>                 user_error(
    [1371] =>                     "Bad '" . static::class . "' defaults given: " . var_export($defaults, true),
    [1372] =>                     E_USER_WARNING
    [1373] =>                 );
    [1374] =>                 $defaults = null;
    [1375] =>             }
    [1376] => 
    [1377] =>             if ($defaults) {
    [1378] =>                 foreach ($defaults as $fieldName => $fieldValue) {
    [1379] =>                     // SRM 2007-03-06: Stricter check
    [1380] =>                     if (!isset($this->$fieldName) || $this->$fieldName === null) {
    [1381] =>                         $this->$fieldName = $fieldValue;
    [1382] =>                     }
    [1383] =>                     // Set many-many defaults with an array of ids
    [1384] =>                     if (is_array($fieldValue) && $this->getSchema()->manyManyComponent(static::class, $fieldName)) {
    [1385] =>                         /** @var ManyManyList $manyManyJoin */
    [1386] =>                         $manyManyJoin = $this->$fieldName();
    [1387] =>                         $manyManyJoin->setByIDList($fieldValue);
    [1388] =>                     }
    [1389] =>                 }
    [1390] =>             }
    [1391] =>             if ($class == self::class) {
    [1392] =>                 break;
    [1393] =>             }
    [1394] =>         }
    [1395] => 
    [1396] =>         $this->extend('populateDefaults');
    [1397] =>         return $this;
    [1398] =>     }
    [1399] => 
    [1400] =>     /**
    [1401] =>      * Determine validation of this object prior to write
    [1402] =>      *
    [1403] =>      * @return ValidationException Exception generated by this write, or null if valid
    [1404] =>      */
    [1405] =>     protected function validateWrite()
    [1406] =>     {
    [1407] =>         if ($this->ObsoleteClassName) {
    [1408] =>             return new ValidationException(
    [1409] =>                 "Object is of class '{$this->ObsoleteClassName}' which doesn't exist - " .
    [1410] =>                 "you need to change the ClassName before you can write it"
    [1411] =>             );
    [1412] =>         }
    [1413] => 
    [1414] =>         // Note: Validation can only be disabled at the global level, not per-model
    [1415] =>         if (DataObject::config()->uninherited('validation_enabled')) {
    [1416] =>             $result = $this->validate();
    [1417] =>             if (!$result->isValid()) {
    [1418] =>                 return new ValidationException($result);
    [1419] =>             }
    [1420] =>         }
    [1421] =>         return null;
    [1422] =>     }
    [1423] => 
    [1424] =>     /**
    [1425] =>      * Prepare an object prior to write
    [1426] =>      *
    [1427] =>      * @throws ValidationException
    [1428] =>      */
    [1429] =>     protected function preWrite()
    [1430] =>     {
    [1431] =>         // Validate this object
    [1432] =>         if ($writeException = $this->validateWrite()) {
    [1433] =>             // Used by DODs to clean up after themselves, eg, Versioned
    [1434] =>             $this->invokeWithExtensions('onAfterSkippedWrite');
    [1435] =>             throw $writeException;
    [1436] =>         }
    [1437] => 
    [1438] =>         // Check onBeforeWrite
    [1439] =>         $this->brokenOnWrite = true;
    [1440] =>         $this->onBeforeWrite();
    [1441] =>         if ($this->brokenOnWrite) {
    [1442] =>             throw new LogicException(
    [1443] =>                 static::class . " has a broken onBeforeWrite() function."
    [1444] =>                 . " Make sure that you call parent::onBeforeWrite()."
    [1445] =>             );
    [1446] =>         }
    [1447] =>     }
    [1448] => 
    [1449] =>     /**
    [1450] =>      * Detects and updates all changes made to this object
    [1451] =>      *
    [1452] =>      * @param bool $forceChanges If set to true, force all fields to be treated as changed
    [1453] =>      * @return bool True if any changes are detected
    [1454] =>      */
    [1455] =>     protected function updateChanges($forceChanges = false)
    [1456] =>     {
    [1457] =>         if ($forceChanges) {
    [1458] =>             // Force changes, but only for loaded fields
    [1459] =>             foreach ($this->record as $field => $value) {
    [1460] =>                 $this->changed[$field] = static::CHANGE_VALUE;
    [1461] =>             }
    [1462] =>             return true;
    [1463] =>         }
    [1464] =>         return $this->isChanged();
    [1465] =>     }
    [1466] => 
    [1467] =>     /**
    [1468] =>      * Writes a subset of changes for a specific table to the given manipulation
    [1469] =>      *
    [1470] =>      * @param string $baseTable Base table
    [1471] =>      * @param string $now Timestamp to use for the current time
    [1472] =>      * @param bool $isNewRecord Whether this should be treated as a new record write
    [1473] =>      * @param array $manipulation Manipulation to write to
    [1474] =>      * @param string $class Class of table to manipulate
    [1475] =>      */
    [1476] =>     protected function prepareManipulationTable($baseTable, $now, $isNewRecord, &$manipulation, $class)
    [1477] =>     {
    [1478] =>         $schema = $this->getSchema();
    [1479] =>         $table = $schema->tableName($class);
    [1480] =>         $manipulation[$table] = [];
    [1481] => 
    [1482] =>         $changed = $this->getChangedFields();
    [1483] => 
    [1484] =>         // Extract records for this table
    [1485] =>         foreach ($this->record as $fieldName => $fieldValue) {
    [1486] =>             // we're not attempting to reset the BaseTable->ID
    [1487] =>             // Ignore unchanged fields or attempts to reset the BaseTable->ID
    [1488] =>             if (empty($changed[$fieldName]) || ($table === $baseTable && $fieldName === 'ID')) {
    [1489] =>                 continue;
    [1490] =>             }
    [1491] => 
    [1492] =>             // Ensure this field pertains to this table
    [1493] =>             $specification = $schema->fieldSpec(
    [1494] =>                 $class,
    [1495] =>                 $fieldName,
    [1496] =>                 DataObjectSchema::UNINHERITED
    [1497] =>             );
    [1498] =>             if (!$specification) {
    [1499] =>                 continue;
    [1500] =>             }
    [1501] => 
    [1502] =>             // if database column doesn't correlate to a DBField instance...
    [1503] =>             $fieldObj = $this->dbObject($fieldName);
    [1504] =>             if (!$fieldObj) {
    [1505] =>                 $fieldObj = DBField::create_field('Varchar', $fieldValue, $fieldName);
    [1506] =>             }
    [1507] => 
    [1508] =>             // Write to manipulation
    [1509] =>             $fieldObj->writeToManipulation($manipulation[$table]);
    [1510] =>         }
    [1511] => 
    [1512] =>         // Ensure update of Created and LastEdited columns
    [1513] =>         if ($baseTable === $table) {
    [1514] =>             $manipulation[$table]['fields']['LastEdited'] = $now;
    [1515] =>             if ($isNewRecord) {
    [1516] =>                 $manipulation[$table]['fields']['Created'] = empty($this->record['Created'])
    [1517] =>                     ? $now
    [1518] =>                     : $this->record['Created'];
    [1519] =>                 $manipulation[$table]['fields']['ClassName'] = static::class;
    [1520] =>             }
    [1521] =>         }
    [1522] => 
    [1523] =>         // Inserts done one the base table are performed in another step, so the manipulation should instead
    [1524] =>         // attempt an update, as though it were a normal update.
    [1525] =>         $manipulation[$table]['command'] = $isNewRecord ? 'insert' : 'update';
    [1526] =>         $manipulation[$table]['class'] = $class;
    [1527] =>         if ($this->isInDB()) {
    [1528] =>             $manipulation[$table]['id'] = $this->record['ID'];
    [1529] =>         }
    [1530] =>     }
    [1531] => 
    [1532] =>     /**
    [1533] =>      * Ensures that a blank base record exists with the basic fixed fields for this dataobject
    [1534] =>      *
    [1535] =>      * Does nothing if an ID is already assigned for this record
    [1536] =>      *
    [1537] =>      * @param string $baseTable Base table
    [1538] =>      * @param string $now Timestamp to use for the current time
    [1539] =>      */
    [1540] =>     protected function writeBaseRecord($baseTable, $now)
    [1541] =>     {
    [1542] =>         // Generate new ID if not specified
    [1543] =>         if ($this->isInDB()) {
    [1544] =>             return;
    [1545] =>         }
    [1546] => 
    [1547] =>         // Perform an insert on the base table
    [1548] =>         $manipulation = [];
    [1549] =>         $this->prepareManipulationTable($baseTable, $now, true, $manipulation, $this->baseClass());
    [1550] =>         DB::manipulate($manipulation);
    [1551] => 
    [1552] =>         $this->changed['ID'] = self::CHANGE_VALUE;
    [1553] =>         $this->record['ID'] = DB::get_generated_id($baseTable);
    [1554] =>     }
    [1555] => 
    [1556] =>     /**
    [1557] =>      * Generate and write the database manipulation for all changed fields
    [1558] =>      *
    [1559] =>      * @param string $baseTable Base table
    [1560] =>      * @param string $now Timestamp to use for the current time
    [1561] =>      * @param bool $isNewRecord If this is a new record
    [1562] =>      * @throws InvalidArgumentException
    [1563] =>      */
    [1564] =>     protected function writeManipulation($baseTable, $now, $isNewRecord)
    [1565] =>     {
    [1566] =>         // Generate database manipulations for each class
    [1567] =>         $manipulation = [];
    [1568] =>         foreach (ClassInfo::ancestry(static::class, true) as $class) {
    [1569] =>             $this->prepareManipulationTable($baseTable, $now, $isNewRecord, $manipulation, $class);
    [1570] =>         }
    [1571] => 
    [1572] =>         // Allow extensions to extend this manipulation
    [1573] =>         $this->extend('augmentWrite', $manipulation);
    [1574] => 
    [1575] =>         // New records have their insert into the base data table done first, so that they can pass the
    [1576] =>         // generated ID on to the rest of the manipulation
    [1577] =>         if ($isNewRecord) {
    [1578] =>             $manipulation[$baseTable]['command'] = 'update';
    [1579] =>         }
    [1580] => 
    [1581] =>         // Make sure none of our field assignment are arrays
    [1582] =>         foreach ($manipulation as $tableManipulation) {
    [1583] =>             if (!isset($tableManipulation['fields'])) {
    [1584] =>                 continue;
    [1585] =>             }
    [1586] =>             foreach ($tableManipulation['fields'] as $fieldName => $fieldValue) {
    [1587] =>                 if (is_array($fieldValue)) {
    [1588] =>                     $dbObject = $this->dbObject($fieldName);
    [1589] =>                     // If the field allows non-scalar values we'll let it do dynamic assignments
    [1590] =>                     if ($dbObject && $dbObject->scalarValueOnly()) {
    [1591] =>                         throw new InvalidArgumentException(
    [1592] =>                             'DataObject::writeManipulation: parameterised field assignments are disallowed'
    [1593] =>                         );
    [1594] =>                     }
    [1595] =>                 }
    [1596] =>             }
    [1597] =>         }
    [1598] => 
    [1599] =>         // Perform the manipulation
    [1600] =>         DB::manipulate($manipulation);
    [1601] =>     }
    [1602] => 
    [1603] =>     /**
    [1604] =>      * Writes all changes to this object to the database.
    [1605] =>      *  - It will insert a record whenever ID isn't set, otherwise update.
    [1606] =>      *  - All relevant tables will be updated.
    [1607] =>      *  - $this->onBeforeWrite() gets called beforehand.
    [1608] =>      *  - Extensions such as Versioned will amend the database-write to ensure that a version is saved.
    [1609] =>      *
    [1610] =>      * @uses DataExtension::augmentWrite()
    [1611] =>      *
    [1612] =>      * @param boolean       $showDebug Show debugging information
    [1613] =>      * @param boolean       $forceInsert Run INSERT command rather than UPDATE, even if record already exists
    [1614] =>      * @param boolean       $forceWrite Write to database even if there are no changes
    [1615] =>      * @param boolean|array $writeComponents Call write() on all associated component instances which were previously
    [1616] =>      *                      retrieved through {@link getComponent()}, {@link getComponents()} or
    [1617] =>      *                      {@link getManyManyComponents()}. Default to `false`. The parameter can also be provided in
    [1618] =>      *                      the form of an array: `['recursive' => true, skip => ['Page'=>[1,2,3]]`. This avoid infinite
    [1619] =>      *                      loops when one DataObject are components of each other.
    [1620] =>      * @return int The ID of the record
    [1621] =>      * @throws ValidationException Exception that can be caught and handled by the calling function
    [1622] =>      */
    [1623] =>     public function write($showDebug = false, $forceInsert = false, $forceWrite = false, $writeComponents = false)
    [1624] =>     {
    [1625] =>         $now = DBDatetime::now()->Rfc2822();
    [1626] => 
    [1627] =>         // Execute pre-write tasks
    [1628] =>         $this->preWrite();
    [1629] => 
    [1630] =>         // Check if we are doing an update or an insert
    [1631] =>         $isNewRecord = !$this->isInDB() || $forceInsert;
    [1632] => 
    [1633] =>         // Check changes exist, abort if there are none
    [1634] =>         $hasChanges = $this->updateChanges($isNewRecord);
    [1635] =>         if ($hasChanges || $forceWrite || $isNewRecord) {
    [1636] =>             // Ensure Created and LastEdited are populated
    [1637] =>             if (!isset($this->record['Created'])) {
    [1638] =>                 $this->record['Created'] = $now;
    [1639] =>             }
    [1640] =>             $this->record['LastEdited'] = $now;
    [1641] => 
    [1642] =>             // New records have their insert into the base data table done first, so that they can pass the
    [1643] =>             // generated primary key on to the rest of the manipulation
    [1644] =>             $baseTable = $this->baseTable();
    [1645] =>             $this->writeBaseRecord($baseTable, $now);
    [1646] => 
    [1647] =>             // Write the DB manipulation for all changed fields
    [1648] =>             $this->writeManipulation($baseTable, $now, $isNewRecord);
    [1649] => 
    [1650] =>             // If there's any relations that couldn't be saved before, save them now (we have an ID here)
    [1651] =>             $this->writeRelations();
    [1652] =>             $this->onAfterWrite();
    [1653] => 
    [1654] =>             // Reset isChanged data
    [1655] =>             // DBComposites properly bound to the parent record will also have their isChanged value reset
    [1656] =>             $this->changed = [];
    [1657] =>             $this->changeForced = false;
    [1658] =>             $this->original = $this->record;
    [1659] =>         } else {
    [1660] =>             if ($showDebug) {
    [1661] =>                 Debug::message("no changes for DataObject");
    [1662] =>             }
    [1663] => 
    [1664] =>             // Used by DODs to clean up after themselves, eg, Versioned
    [1665] =>             $this->invokeWithExtensions('onAfterSkippedWrite');
    [1666] =>         }
    [1667] => 
    [1668] =>         // Write relations as necessary
    [1669] =>         if ($writeComponents) {
    [1670] =>             $recursive = true;
    [1671] =>             $skip = [];
    [1672] =>             if (is_array($writeComponents)) {
    [1673] =>                 $recursive = isset($writeComponents['recursive']) && $writeComponents['recursive'];
    [1674] =>                 $skip = isset($writeComponents['skip']) && is_array($writeComponents['skip'])
    [1675] =>                     ? $writeComponents['skip']
    [1676] =>                     : [];
    [1677] =>             }
    [1678] =>             $this->writeComponents($recursive, $skip);
    [1679] =>         }
    [1680] => 
    [1681] =>         // Clears the cache for this object so get_one returns the correct object.
    [1682] =>         $this->flushCache();
    [1683] => 
    [1684] =>         return $this->record['ID'];
    [1685] =>     }
    [1686] => 
    [1687] =>     /**
    [1688] =>      * Writes cached relation lists to the database, if possible
    [1689] =>      */
    [1690] =>     public function writeRelations()
    [1691] =>     {
    [1692] =>         if (!$this->isInDB()) {
    [1693] =>             return;
    [1694] =>         }
    [1695] => 
    [1696] =>         // If there's any relations that couldn't be saved before, save them now (we have an ID here)
    [1697] =>         if ($this->unsavedRelations) {
    [1698] =>             foreach ($this->unsavedRelations as $name => $list) {
    [1699] =>                 $list->changeToList($this->$name());
    [1700] =>             }
    [1701] =>             $this->unsavedRelations = [];
    [1702] =>         }
    [1703] =>     }
    [1704] => 
    [1705] =>     /**
    [1706] =>      * Write the cached components to the database. Cached components could refer to two different instances of the
    [1707] =>      * same record.
    [1708] =>      *
    [1709] =>      * @param bool $recursive Recursively write components
    [1710] =>      * @param array $skip List of DataObject references to skip
    [1711] =>      * @return DataObject $this
    [1712] =>      */
    [1713] =>     public function writeComponents($recursive = false, $skip = [])
    [1714] =>     {
    [1715] =>         // Make sure we add our current object to the skip list
    [1716] =>         $this->skipWriteComponents($recursive, $this, $skip);
    [1717] => 
    [1718] =>         // All our write calls have the same arguments ... just need make sure the skip list is pass by reference
    [1719] =>         $args = [
    [1720] =>             false, false, false,
    [1721] =>             $recursive ? ["recursive" => $recursive, "skip" => &$skip] : false
    [1722] =>         ];
    [1723] => 
    [1724] =>         foreach ($this->components as $component) {
    [1725] =>             if (!$this->skipWriteComponents($recursive, $component, $skip)) {
    [1726] =>                 $component->write(...$args);
    [1727] =>             }
    [1728] =>         }
    [1729] => 
    [1730] =>         if ($join = $this->getJoin()) {
    [1731] =>             if (!$this->skipWriteComponents($recursive, $join, $skip)) {
    [1732] =>                 $join->write(...$args);
    [1733] =>             }
    [1734] =>         }
    [1735] => 
    [1736] =>         return $this;
    [1737] =>     }
    [1738] => 
    [1739] =>     /**
    [1740] =>      * Check if target is in the skip list and add it if it isn't.
    [1741] =>      * @param bool $recursive
    [1742] =>      * @param DataObject $target
    [1743] =>      * @param array $skip
    [1744] =>      * @return bool Whether the target is already in the list
    [1745] =>      */
    [1746] =>     private function skipWriteComponents($recursive, DataObject $target, array &$skip)
    [1747] =>     {
    [1748] =>         // skip writing component if it doesn't exist
    [1749] =>         if (!$target->exists()) {
    [1750] =>             return true;
    [1751] =>         }
    [1752] => 
    [1753] =>         // We only care about the skip list if our call is meant to be recursive
    [1754] =>         if (!$recursive) {
    [1755] =>             return false;
    [1756] =>         }
    [1757] => 
    [1758] =>         // Get our Skip array keys
    [1759] =>         $classname = get_class($target);
    [1760] =>         $id = $target->ID;
    [1761] => 
    [1762] =>         // Check if the target is in the skip list
    [1763] =>         if (isset($skip[$classname])) {
    [1764] =>             if (in_array($id, $skip[$classname] ?? [])) {
    [1765] =>                 // Skip the object
    [1766] =>                 return true;
    [1767] =>             }
    [1768] =>         } else {
    [1769] =>             // This is the first object of this class
    [1770] =>             $skip[$classname] = [];
    [1771] =>         }
    [1772] => 
    [1773] =>         // Add the target to our skip list
    [1774] =>         $skip[$classname][] = $id;
    [1775] => 
    [1776] =>         return false;
    [1777] =>     }
    [1778] => 
    [1779] =>     /**
    [1780] =>      * Delete this data object.
    [1781] =>      * $this->onBeforeDelete() gets called.
    [1782] =>      * Note that in Versioned objects, both Stage and Live will be deleted.
    [1783] =>      * @uses DataExtension::augmentSQL()
    [1784] =>      */
    [1785] =>     public function delete()
    [1786] =>     {
    [1787] =>         $this->brokenOnDelete = true;
    [1788] =>         $this->onBeforeDelete();
    [1789] =>         if ($this->brokenOnDelete) {
    [1790] =>             throw new LogicException(
    [1791] =>                 static::class . " has a broken onBeforeDelete() function."
    [1792] =>                 . " Make sure that you call parent::onBeforeDelete()."
    [1793] =>             );
    [1794] =>         }
    [1795] => 
    [1796] =>         // Deleting a record without an ID shouldn't do anything
    [1797] =>         if (!$this->ID) {
    [1798] =>             throw new LogicException("DataObject::delete() called on a DataObject without an ID");
    [1799] =>         }
    [1800] => 
    [1801] =>         // TODO: This is quite ugly.  To improve:
    [1802] =>         //  - move the details of the delete code in the DataQuery system
    [1803] =>         //  - update the code to just delete the base table, and rely on cascading deletes in the DB to do the rest
    [1804] =>         //    obviously, that means getting requireTable() to configure cascading deletes ;-)
    [1805] =>         $srcQuery = DataList::create(static::class)
    [1806] =>             ->filter('ID', $this->ID)
    [1807] =>             ->dataQuery()
    [1808] =>             ->query();
    [1809] =>         $queriedTables = $srcQuery->queriedTables();
    [1810] =>         $this->extend('updateDeleteTables', $queriedTables, $srcQuery);
    [1811] =>         foreach ($queriedTables as $table) {
    [1812] =>             $delete = SQLDelete::create("\"$table\"", ['"ID"' => $this->ID]);
    [1813] =>             $this->extend('updateDeleteTable', $delete, $table, $queriedTables, $srcQuery);
    [1814] =>             $delete->execute();
    [1815] =>         }
    [1816] =>         // Remove this item out of any caches
    [1817] =>         $this->flushCache();
    [1818] => 
    [1819] =>         $this->onAfterDelete();
    [1820] => 
    [1821] =>         $this->OldID = $this->ID;
    [1822] =>         $this->ID = 0;
    [1823] =>     }
    [1824] => 
    [1825] =>     /**
    [1826] =>      * Delete the record with the given ID.
    [1827] =>      *
    [1828] =>      * @param string $className The class name of the record to be deleted
    [1829] =>      * @param int $id ID of record to be deleted
    [1830] =>      */
    [1831] =>     public static function delete_by_id($className, $id)
    [1832] =>     {
    [1833] =>         $obj = DataObject::get_by_id($className, $id);
    [1834] =>         if ($obj) {
    [1835] =>             $obj->delete();
    [1836] =>         } else {
    [1837] =>             user_error("$className object #$id wasn't found when calling DataObject::delete_by_id", E_USER_WARNING);
    [1838] =>         }
    [1839] =>     }
    [1840] => 
    [1841] =>     /**
    [1842] =>      * Get the class ancestry, including the current class name.
    [1843] =>      * The ancestry will be returned as an array of class names, where the 0th element
    [1844] =>      * will be the class that inherits directly from DataObject, and the last element
    [1845] =>      * will be the current class.
    [1846] =>      *
    [1847] =>      * @return array Class ancestry
    [1848] =>      */
    [1849] =>     public function getClassAncestry()
    [1850] =>     {
    [1851] =>         return ClassInfo::ancestry(static::class);
    [1852] =>     }
    [1853] => 
    [1854] =>     /**
    [1855] =>      * Return a unary component object from a one to one relationship, as a DataObject.
    [1856] =>      * If no component is available, an 'empty component' will be returned for
    [1857] =>      * non-polymorphic relations, or for polymorphic relations with a class set.
    [1858] =>      *
    [1859] =>      * @param string $componentName Name of the component
    [1860] =>      * @return DataObject The component object. It's exact type will be that of the component.
    [1861] =>      * @throws Exception
    [1862] =>      */
    [1863] =>     public function getComponent($componentName)
    [1864] =>     {
    [1865] =>         if (isset($this->components[$componentName])) {
    [1866] =>             return $this->components[$componentName];
    [1867] =>         }
    [1868] => 
    [1869] =>         // The join object can be returned as a component, named for its alias
    [1870] =>         if (isset($this->record[$componentName]) && $this->record[$componentName] === $this->joinRecord) {
    [1871] =>             return $this->record[$componentName];
    [1872] =>         }
    [1873] => 
    [1874] =>         $schema = static::getSchema();
    [1875] =>         if ($class = $schema->hasOneComponent(static::class, $componentName)) {
    [1876] =>             $joinField = $componentName . 'ID';
    [1877] =>             $joinID = $this->getField($joinField);
    [1878] => 
    [1879] =>             // Extract class name for polymorphic relations
    [1880] =>             if ($class === self::class) {
    [1881] =>                 $class = $this->getField($componentName . 'Class');
    [1882] =>                 if (empty($class)) {
    [1883] =>                     return null;
    [1884] =>                 }
    [1885] =>             }
    [1886] => 
    [1887] =>             if ($joinID) {
    [1888] =>                 // Ensure that the selected object originates from the same stage, subsite, etc
    [1889] =>                 $component = DataObject::get($class)
    [1890] =>                     ->filter('ID', $joinID)
    [1891] =>                     ->setDataQueryParam($this->getInheritableQueryParams())
    [1892] =>                     ->first();
    [1893] =>             }
    [1894] => 
    [1895] =>             if (empty($component)) {
    [1896] =>                 $component = Injector::inst()->create($class);
    [1897] =>             }
    [1898] =>         } elseif ($class = $schema->belongsToComponent(static::class, $componentName)) {
    [1899] =>             $joinField = $schema->getRemoteJoinField(static::class, $componentName, 'belongs_to', $polymorphic);
    [1900] =>             $joinID = $this->ID;
    [1901] => 
    [1902] =>             if ($joinID) {
    [1903] =>                 // Prepare filter for appropriate join type
    [1904] =>                 if ($polymorphic) {
    [1905] =>                     $filter = [
    [1906] =>                         "{$joinField}ID" => $joinID,
    [1907] =>                         "{$joinField}Class" => static::class,
    [1908] =>                     ];
    [1909] =>                 } else {
    [1910] =>                     $filter = [
    [1911] =>                         $joinField => $joinID
    [1912] =>                     ];
    [1913] =>                 }
    [1914] => 
    [1915] =>                 // Ensure that the selected object originates from the same stage, subsite, etc
    [1916] =>                 $component = DataObject::get($class)
    [1917] =>                     ->filter($filter)
    [1918] =>                     ->setDataQueryParam($this->getInheritableQueryParams())
    [1919] =>                     ->first();
    [1920] =>             }
    [1921] => 
    [1922] =>             if (empty($component)) {
    [1923] =>                 $component = Injector::inst()->create($class);
    [1924] =>                 if ($polymorphic) {
    [1925] =>                     $component->{$joinField . 'ID'} = $this->ID;
    [1926] =>                     $component->{$joinField . 'Class'} = static::class;
    [1927] =>                 } else {
    [1928] =>                     $component->$joinField = $this->ID;
    [1929] =>                 }
    [1930] =>             }
    [1931] =>         } else {
    [1932] =>             throw new InvalidArgumentException(
    [1933] =>                 "DataObject->getComponent(): Could not find component '$componentName'."
    [1934] =>             );
    [1935] =>         }
    [1936] => 
    [1937] =>         $this->components[$componentName] = $component;
    [1938] =>         return $component;
    [1939] =>     }
    [1940] => 
    [1941] =>     /**
    [1942] =>      * Assign an item to the given component
    [1943] =>      *
    [1944] =>      * @param string $componentName
    [1945] =>      * @param DataObject|null $item
    [1946] =>      * @return $this
    [1947] =>      */
    [1948] =>     public function setComponent($componentName, $item)
    [1949] =>     {
    [1950] =>         // Validate component
    [1951] =>         $schema = static::getSchema();
    [1952] =>         if ($class = $schema->hasOneComponent(static::class, $componentName)) {
    [1953] =>             // Force item to be written if not by this point
    [1954] =>             // @todo This could be lazy-written in a beforeWrite hook, but force write here for simplicity
    [1955] =>             // https://github.com/silverstripe/silverstripe-framework/issues/7818
    [1956] =>             if ($item && !$item->isInDB()) {
    [1957] =>                 $item->write();
    [1958] =>             }
    [1959] => 
    [1960] =>             // Update local ID
    [1961] =>             $joinField = $componentName . 'ID';
    [1962] =>             $this->setField($joinField, $item ? $item->ID : null);
    [1963] =>             // Update Class (Polymorphic has_one)
    [1964] =>             // Extract class name for polymorphic relations
    [1965] =>             if ($class === self::class) {
    [1966] =>                 $this->setField($componentName . 'Class', $item ? get_class($item) : null);
    [1967] =>             }
    [1968] =>         } elseif ($class = $schema->belongsToComponent(static::class, $componentName)) {
    [1969] =>             if ($item) {
    [1970] =>                 // For belongs_to, add to has_one on other component
    [1971] =>                 $joinField = $schema->getRemoteJoinField(static::class, $componentName, 'belongs_to', $polymorphic);
    [1972] =>                 if (!$polymorphic) {
    [1973] =>                     $joinField = substr($joinField ?? '', 0, -2);
    [1974] =>                 }
    [1975] =>                 $item->setComponent($joinField, $this);
    [1976] =>             }
    [1977] =>         } else {
    [1978] =>             throw new InvalidArgumentException(
    [1979] =>                 "DataObject->setComponent(): Could not find component '$componentName'."
    [1980] =>             );
    [1981] =>         }
    [1982] => 
    [1983] =>         $this->components[$componentName] = $item;
    [1984] =>         return $this;
    [1985] =>     }
    [1986] => 
    [1987] =>     /**
    [1988] =>      * Returns a one-to-many relation as a HasManyList
    [1989] =>      *
    [1990] =>      * @param string $componentName Name of the component
    [1991] =>      * @param int|array $id Optional ID(s) for parent of this relation, if not the current record
    [1992] =>      * @return HasManyList|UnsavedRelationList The components of the one-to-many relationship.
    [1993] =>      */
    [1994] =>     public function getComponents($componentName, $id = null)
    [1995] =>     {
    [1996] =>         if (!isset($id)) {
    [1997] =>             $id = $this->ID;
    [1998] =>         }
    [1999] =>         $result = null;
    [2000] => 
    [2001] =>         $schema = $this->getSchema();
    [2002] =>         $componentClass = $schema->hasManyComponent(static::class, $componentName);
    [2003] =>         if (!$componentClass) {
    [2004] =>             throw new InvalidArgumentException(sprintf(
    [2005] =>                 "DataObject::getComponents(): Unknown 1-to-many component '%s' on class '%s'",
    [2006] =>                 $componentName,
    [2007] =>                 static::class
    [2008] =>             ));
    [2009] =>         }
    [2010] => 
    [2011] =>         // If we haven't been written yet, we can't save these relations, so use a list that handles this case
    [2012] =>         if (!$id) {
    [2013] =>             if (!isset($this->unsavedRelations[$componentName])) {
    [2014] =>                 $this->unsavedRelations[$componentName] =
    [2015] =>                     new UnsavedRelationList(static::class, $componentName, $componentClass);
    [2016] =>             }
    [2017] =>             return $this->unsavedRelations[$componentName];
    [2018] =>         }
    [2019] => 
    [2020] =>         // Determine type and nature of foreign relation
    [2021] =>         $joinField = $schema->getRemoteJoinField(static::class, $componentName, 'has_many', $polymorphic);
    [2022] =>         /** @var HasManyList $result */
    [2023] =>         if ($polymorphic) {
    [2024] =>             $result = PolymorphicHasManyList::create($componentClass, $joinField, static::class);
    [2025] =>         } else {
    [2026] =>             $result = HasManyList::create($componentClass, $joinField);
    [2027] =>         }
    [2028] => 
    [2029] =>         return $result
    [2030] =>             ->setDataQueryParam($this->getInheritableQueryParams())
    [2031] =>             ->forForeignID($id);
    [2032] =>     }
    [2033] => 
    [2034] =>     /**
    [2035] =>      * Find the foreign class of a relation on this DataObject, regardless of the relation type.
    [2036] =>      *
    [2037] =>      * @param string $relationName Relation name.
    [2038] =>      * @return string Class name, or null if not found.
    [2039] =>      */
    [2040] =>     public function getRelationClass($relationName)
    [2041] =>     {
    [2042] =>         // Parse many_many
    [2043] =>         $manyManyComponent = $this->getSchema()->manyManyComponent(static::class, $relationName);
    [2044] =>         if ($manyManyComponent) {
    [2045] =>             return $manyManyComponent['childClass'];
    [2046] =>         }
    [2047] => 
    [2048] =>         // Go through all relationship configuration fields.
    [2049] =>         $config = $this->config();
    [2050] =>         $candidates = array_merge(
    [2051] =>             ($relations = $config->get('has_one')) ? $relations : [],
    [2052] =>             ($relations = $config->get('has_many')) ? $relations : [],
    [2053] =>             ($relations = $config->get('belongs_to')) ? $relations : []
    [2054] =>         );
    [2055] => 
    [2056] =>         if (isset($candidates[$relationName])) {
    [2057] =>             $remoteClass = $candidates[$relationName];
    [2058] => 
    [2059] =>             // If dot notation is present, extract just the first part that contains the class.
    [2060] =>             if (($fieldPos = strpos($remoteClass ?? '', '.')) !== false) {
    [2061] =>                 return substr($remoteClass ?? '', 0, $fieldPos);
    [2062] =>             }
    [2063] => 
    [2064] =>             // Otherwise just return the class
    [2065] =>             return $remoteClass;
    [2066] =>         }
    [2067] => 
    [2068] =>         return null;
    [2069] =>     }
    [2070] => 
    [2071] =>     /**
    [2072] =>      * Given a relation name, determine the relation type
    [2073] =>      *
    [2074] =>      * @param string $component Name of component
    [2075] =>      * @return string has_one, has_many, many_many, belongs_many_many or belongs_to
    [2076] =>      */
    [2077] =>     public function getRelationType($component)
    [2078] =>     {
    [2079] =>         $types = ['has_one', 'has_many', 'many_many', 'belongs_many_many', 'belongs_to'];
    [2080] =>         $config = $this->config();
    [2081] =>         foreach ($types as $type) {
    [2082] =>             $relations = $config->get($type);
    [2083] =>             if ($relations && isset($relations[$component])) {
    [2084] =>                 return $type;
    [2085] =>             }
    [2086] =>         }
    [2087] =>         return null;
    [2088] =>     }
    [2089] => 
    [2090] =>     /**
    [2091] =>      * Given a relation declared on a remote class, generate a substitute component for the opposite
    [2092] =>      * side of the relation.
    [2093] =>      *
    [2094] =>      * Notes on behaviour:
    [2095] =>      *  - This can still be used on components that are defined on both sides, but do not need to be.
    [2096] =>      *  - All has_ones on remote class will be treated as local has_many, even if they are belongs_to
    [2097] =>      *  - Polymorphic relationships do not have two natural endpoints (only on one side)
    [2098] =>      *   and thus attempting to infer them will return nothing.
    [2099] =>      *  - Cannot be used on unsaved objects.
    [2100] =>      *
    [2101] =>      * @param string $remoteClass
    [2102] =>      * @param string $remoteRelation
    [2103] =>      * @return DataList|DataObject The component, either as a list or single object
    [2104] =>      * @throws BadMethodCallException
    [2105] =>      * @throws InvalidArgumentException
    [2106] =>      */
    [2107] =>     public function inferReciprocalComponent($remoteClass, $remoteRelation)
    [2108] =>     {
    [2109] =>         $remote = DataObject::singleton($remoteClass);
    [2110] =>         $class = $remote->getRelationClass($remoteRelation);
    [2111] =>         $schema = static::getSchema();
    [2112] => 
    [2113] =>         // Validate arguments
    [2114] =>         if (!$this->isInDB()) {
    [2115] =>             throw new BadMethodCallException(__METHOD__ . " cannot be called on unsaved objects");
    [2116] =>         }
    [2117] =>         if (empty($class)) {
    [2118] =>             throw new InvalidArgumentException(sprintf(
    [2119] =>                 "%s invoked with invalid relation %s.%s",
    [2120] =>                 __METHOD__,
    [2121] =>                 $remoteClass,
    [2122] =>                 $remoteRelation
    [2123] =>             ));
    [2124] =>         }
    [2125] =>         // If relation is polymorphic, do not infer recriprocal relationship
    [2126] =>         if ($class === self::class) {
    [2127] =>             return null;
    [2128] =>         }
    [2129] =>         if (!is_a($this, $class ?? '', true)) {
    [2130] =>             throw new InvalidArgumentException(sprintf(
    [2131] =>                 "Relation %s on %s does not refer to objects of type %s",
    [2132] =>                 $remoteRelation,
    [2133] =>                 $remoteClass,
    [2134] =>                 static::class
    [2135] =>             ));
    [2136] =>         }
    [2137] => 
    [2138] =>         // Check the relation type to mock
    [2139] =>         $relationType = $remote->getRelationType($remoteRelation);
    [2140] =>         switch ($relationType) {
    [2141] =>             case 'has_one': {
    [2142] =>                 // Mock has_many
    [2143] =>                 $joinField = "{$remoteRelation}ID";
    [2144] =>                 $componentClass = $schema->classForField($remoteClass, $joinField);
    [2145] =>                 $result = HasManyList::create($componentClass, $joinField);
    [2146] =>                 return $result
    [2147] =>                     ->setDataQueryParam($this->getInheritableQueryParams())
    [2148] =>                     ->forForeignID($this->ID);
    [2149] =>             }
    [2150] =>             case 'belongs_to':
    [2151] =>             case 'has_many': {
    [2152] =>                 // These relations must have a has_one on the other end, so find it
    [2153] =>                 $joinField = $schema->getRemoteJoinField(
    [2154] =>                     $remoteClass,
    [2155] =>                     $remoteRelation,
    [2156] =>                     $relationType,
    [2157] =>                     $polymorphic
    [2158] =>                 );
    [2159] =>                 // If relation is polymorphic, do not infer recriprocal relationship automatically
    [2160] =>                 if ($polymorphic) {
    [2161] =>                     return null;
    [2162] =>                 }
    [2163] =>                 $joinID = $this->getField($joinField);
    [2164] =>                 if (empty($joinID)) {
    [2165] =>                     return null;
    [2166] =>                 }
    [2167] =>                 // Get object by joined ID
    [2168] =>                 return DataObject::get($remoteClass)
    [2169] =>                     ->filter('ID', $joinID)
    [2170] =>                     ->setDataQueryParam($this->getInheritableQueryParams())
    [2171] =>                     ->first();
    [2172] =>             }
    [2173] =>             case 'many_many':
    [2174] =>             case 'belongs_many_many': {
    [2175] =>                 // Get components and extra fields from parent
    [2176] =>                 $manyMany = $remote->getSchema()->manyManyComponent($remoteClass, $remoteRelation);
    [2177] =>                 $extraFields = $schema->manyManyExtraFieldsForComponent($remoteClass, $remoteRelation) ?: [];
    [2178] => 
    [2179] =>                 // Reverse parent and component fields and create an inverse ManyManyList
    [2180] =>                 /** @var RelationList $result */
    [2181] =>                 $result = Injector::inst()->create(
    [2182] =>                     $manyMany['relationClass'],
    [2183] =>                     $manyMany['parentClass'], // Substitute parent class for dataClass
    [2184] =>                     $manyMany['join'],
    [2185] =>                     $manyMany['parentField'], // Reversed parent / child field
    [2186] =>                     $manyMany['childField'], // Reversed parent / child field
    [2187] =>                     $extraFields,
    [2188] =>                     $manyMany['childClass'], // substitute child class for parentClass
    [2189] =>                     $remoteClass // In case ManyManyThroughList needs to use PolymorphicHasManyList internally
    [2190] =>                 );
    [2191] =>                 $this->extend('updateManyManyComponents', $result);
    [2192] => 
    [2193] =>                 // If this is called on a singleton, then we return an 'orphaned relation' that can have the
    [2194] =>                 // foreignID set elsewhere.
    [2195] =>                 return $result
    [2196] =>                     ->setDataQueryParam($this->getInheritableQueryParams())
    [2197] =>                     ->forForeignID($this->ID);
    [2198] =>             }
    [2199] =>             default: {
    [2200] =>                 return null;
    [2201] =>             }
    [2202] =>         }
    [2203] =>     }
    [2204] => 
    [2205] =>     /**
    [2206] =>      * Returns a many-to-many component, as a ManyManyList.
    [2207] =>      * @param string $componentName Name of the many-many component
    [2208] =>      * @param int|array $id Optional ID for parent of this relation, if not the current record
    [2209] =>      * @return ManyManyList|UnsavedRelationList The set of components
    [2210] =>      */
    [2211] =>     public function getManyManyComponents($componentName, $id = null)
    [2212] =>     {
    [2213] =>         if (!isset($id)) {
    [2214] =>             $id = $this->ID;
    [2215] =>         }
    [2216] =>         $schema = static::getSchema();
    [2217] =>         $manyManyComponent = $schema->manyManyComponent(static::class, $componentName);
    [2218] =>         if (!$manyManyComponent) {
    [2219] =>             throw new InvalidArgumentException(sprintf(
    [2220] =>                 "DataObject::getComponents(): Unknown many-to-many component '%s' on class '%s'",
    [2221] =>                 $componentName,
    [2222] =>                 static::class
    [2223] =>             ));
    [2224] =>         }
    [2225] => 
    [2226] =>         // If we haven't been written yet, we can't save these relations, so use a list that handles this case
    [2227] =>         if (!$id) {
    [2228] =>             if (!isset($this->unsavedRelations[$componentName])) {
    [2229] =>                 $this->unsavedRelations[$componentName] = new UnsavedRelationList(
    [2230] =>                     $manyManyComponent['parentClass'],
    [2231] =>                     $componentName,
    [2232] =>                     $manyManyComponent['childClass']
    [2233] =>                 );
    [2234] =>             }
    [2235] =>             return $this->unsavedRelations[$componentName];
    [2236] =>         }
    [2237] => 
    [2238] =>         $extraFields = $schema->manyManyExtraFieldsForComponent(static::class, $componentName) ?: [];
    [2239] =>         /** @var RelationList $result */
    [2240] =>         $result = Injector::inst()->create(
    [2241] =>             $manyManyComponent['relationClass'],
    [2242] =>             $manyManyComponent['childClass'],
    [2243] =>             $manyManyComponent['join'],
    [2244] =>             $manyManyComponent['childField'],
    [2245] =>             $manyManyComponent['parentField'],
    [2246] =>             $extraFields,
    [2247] =>             $manyManyComponent['parentClass'],
    [2248] =>             static::class // In case ManyManyThroughList needs to use PolymorphicHasManyList internally
    [2249] =>         );
    [2250] => 
    [2251] =>         // Store component data in query meta-data
    [2252] =>         $result = $result->alterDataQuery(function ($query) use ($extraFields) {
    [2253] =>             /** @var DataQuery $query */
    [2254] =>             $query->setQueryParam('Component.ExtraFields', $extraFields);
    [2255] =>         });
    [2256] => 
    [2257] =>         // If we have a default sort set for our "join" then we should overwrite any default already set.
    [2258] =>         $joinSort = Config::inst()->get($manyManyComponent['join'], 'default_sort');
    [2259] =>         if (!empty($joinSort)) {
    [2260] =>             $result = $result->sort($joinSort);
    [2261] =>         }
    [2262] => 
    [2263] =>         $this->extend('updateManyManyComponents', $result);
    [2264] => 
    [2265] =>         // If this is called on a singleton, then we return an 'orphaned relation' that can have the
    [2266] =>         // foreignID set elsewhere.
    [2267] =>         return $result
    [2268] =>             ->setDataQueryParam($this->getInheritableQueryParams())
    [2269] =>             ->forForeignID($id);
    [2270] =>     }
    [2271] => 
    [2272] =>     /**
    [2273] =>      * Return the class of a one-to-one component.  If $component is null, return all of the one-to-one components and
    [2274] =>      * their classes. If the selected has_one is a polymorphic field then 'DataObject' will be returned for the type.
    [2275] =>      *
    [2276] =>      * @return string|array The class of the one-to-one component, or an array of all one-to-one components and
    [2277] =>      *                          their classes.
    [2278] =>      */
    [2279] =>     public function hasOne()
    [2280] =>     {
    [2281] =>         return (array)$this->config()->get('has_one');
    [2282] =>     }
    [2283] => 
    [2284] =>     /**
    [2285] =>      * Returns the class of a remote belongs_to relationship. If no component is specified a map of all components and
    [2286] =>      * their class name will be returned.
    [2287] =>      *
    [2288] =>      * @param bool $classOnly If this is TRUE, than any has_many relationships in the form "ClassName.Field" will have
    [2289] =>      *        the field data stripped off. It defaults to TRUE.
    [2290] =>      * @return string|array
    [2291] =>      */
    [2292] =>     public function belongsTo($classOnly = true)
    [2293] =>     {
    [2294] =>         $belongsTo = (array)$this->config()->get('belongs_to');
    [2295] =>         if ($belongsTo && $classOnly) {
    [2296] =>             return preg_replace('/(.+)?\..+/', '$1', $belongsTo ?? '');
    [2297] =>         } else {
    [2298] =>             return $belongsTo ? $belongsTo : [];
    [2299] =>         }
    [2300] =>     }
    [2301] => 
    [2302] =>     /**
    [2303] =>      * Gets the class of a one-to-many relationship. If no $component is specified then an array of all the one-to-many
    [2304] =>      * relationships and their classes will be returned.
    [2305] =>      *
    [2306] =>      * @param bool $classOnly If this is TRUE, than any has_many relationships in the form "ClassName.Field" will have
    [2307] =>      *        the field data stripped off. It defaults to TRUE.
    [2308] =>      * @return string|array|false
    [2309] =>      */
    [2310] =>     public function hasMany($classOnly = true)
    [2311] =>     {
    [2312] =>         $hasMany = (array)$this->config()->get('has_many');
    [2313] =>         if ($hasMany && $classOnly) {
    [2314] =>             return preg_replace('/(.+)?\..+/', '$1', $hasMany ?? '');
    [2315] =>         } else {
    [2316] =>             return $hasMany ? $hasMany : [];
    [2317] =>         }
    [2318] =>     }
    [2319] => 
    [2320] =>     /**
    [2321] =>      * Return the many-to-many extra fields specification.
    [2322] =>      *
    [2323] =>      * If you don't specify a component name, it returns all
    [2324] =>      * extra fields for all components available.
    [2325] =>      *
    [2326] =>      * @return array|null
    [2327] =>      */
    [2328] =>     public function manyManyExtraFields()
    [2329] =>     {
    [2330] =>         return $this->config()->get('many_many_extraFields');
    [2331] =>     }
    [2332] => 
    [2333] =>     /**
    [2334] =>      * Return information about a many-to-many component.
    [2335] =>      * The return value is an array of (parentclass, childclass).  If $component is null, then all many-many
    [2336] =>      * components are returned.
    [2337] =>      *
    [2338] =>      * @see DataObjectSchema::manyManyComponent()
    [2339] =>      * @return array|null An array of (parentclass, childclass), or an array of all many-many components
    [2340] =>      */
    [2341] =>     public function manyMany()
    [2342] =>     {
    [2343] =>         $config = $this->config();
    [2344] =>         $manyManys = (array)$config->get('many_many');
    [2345] =>         $belongsManyManys = (array)$config->get('belongs_many_many');
    [2346] =>         $items = array_merge($manyManys, $belongsManyManys);
    [2347] =>         return $items;
    [2348] =>     }
    [2349] => 
    [2350] =>     /**
    [2351] =>      * This returns an array (if it exists) describing the database extensions that are required, or false if none
    [2352] =>      *
    [2353] =>      * This is experimental, and is currently only a Postgres-specific enhancement.
    [2354] =>      *
    [2355] =>      * @param string $class
    [2356] =>      * @return array|false
    [2357] =>      */
    [2358] =>     public function database_extensions($class)
    [2359] =>     {
    [2360] =>         $extensions = Config::inst()->get($class, 'database_extensions', Config::UNINHERITED);
    [2361] =>         if ($extensions) {
    [2362] =>             return $extensions;
    [2363] =>         } else {
    [2364] =>             return false;
    [2365] =>         }
    [2366] =>     }
    [2367] => 
    [2368] =>     /**
    [2369] =>      * Generates a SearchContext to be used for building and processing
    [2370] =>      * a generic search form for properties on this object.
    [2371] =>      *
    [2372] =>      * @return SearchContext
    [2373] =>      */
    [2374] =>     public function getDefaultSearchContext()
    [2375] =>     {
    [2376] =>         return SearchContext::create(
    [2377] =>             static::class,
    [2378] =>             $this->scaffoldSearchFields(),
    [2379] =>             $this->defaultSearchFilters()
    [2380] =>         );
    [2381] =>     }
    [2382] => 
    [2383] =>     /**
    [2384] =>      * Name of the field which is used as a stand-in for searching across all searchable fields.
    [2385] =>      *
    [2386] =>      * If this is a blank string, general search functionality is disabled
    [2387] =>      * and the general search field falls back to using the first field in
    [2388] =>      * the searchable fields array.
    [2389] =>      */
    [2390] =>     public function getGeneralSearchFieldName(): string
    [2391] =>     {
    [2392] =>         return $this->config()->get('general_search_field_name');
    [2393] =>     }
    [2394] => 
    [2395] =>     /**
    [2396] =>      * Determine which properties on the DataObject are
    [2397] =>      * searchable, and map them to their default {@link FormField}
    [2398] =>      * representations. Used for scaffolding a searchform for {@link ModelAdmin}.
    [2399] =>      *
    [2400] =>      * Some additional logic is included for switching field labels, based on
    [2401] =>      * how generic or specific the field type is.
    [2402] =>      *
    [2403] =>      * Used by {@link SearchContext}.
    [2404] =>      *
    [2405] =>      * @param array $_params
    [2406] =>      *   'fieldClasses': Associative array of field names as keys and FormField classes as values
    [2407] =>      *   'restrictFields': Numeric array of a field name whitelist
    [2408] =>      * @return FieldList
    [2409] =>      */
    [2410] =>     public function scaffoldSearchFields($_params = null)
    [2411] =>     {
    [2412] =>         $params = array_merge(
    [2413] =>             [
    [2414] =>                 'fieldClasses' => false,
    [2415] =>                 'restrictFields' => false
    [2416] =>             ],
    [2417] =>             (array)$_params
    [2418] =>         );
    [2419] =>         $fields = new FieldList();
    [2420] => 
    [2421] =>         foreach ($this->searchableFields() as $fieldName => $spec) {
    [2422] =>             if ($params['restrictFields'] && !in_array($fieldName, $params['restrictFields'] ?? [])) {
    [2423] =>                 continue;
    [2424] =>             }
    [2425] => 
    [2426] =>             // If a custom fieldclass is provided as a string, use it
    [2427] =>             $field = null;
    [2428] =>             if ($params['fieldClasses'] && isset($params['fieldClasses'][$fieldName])) {
    [2429] =>                 $fieldClass = $params['fieldClasses'][$fieldName];
    [2430] =>                 $field = new $fieldClass($fieldName);
    [2431] =>             // If we explicitly set a field, then construct that
    [2432] =>             } elseif (isset($spec['field'])) {
    [2433] =>                 // If it's a string, use it as a class name and construct
    [2434] =>                 if (is_string($spec['field'])) {
    [2435] =>                     $fieldClass = $spec['field'];
    [2436] =>                     $field = new $fieldClass($fieldName);
    [2437] => 
    [2438] =>                 // If it's a FormField object, then just use that object directly.
    [2439] =>                 } elseif ($spec['field'] instanceof FormField) {
    [2440] =>                     $field = $spec['field'];
    [2441] => 
    [2442] =>                 // Otherwise we have a bug
    [2443] =>                 } else {
    [2444] =>                     user_error("Bad value for searchable_fields, 'field' value: "
    [2445] =>                         . var_export($spec['field'], true), E_USER_WARNING);
    [2446] =>                 }
    [2447] => 
    [2448] =>             // Otherwise, use the database field's scaffolder
    [2449] =>             } elseif ($object = $this->relObject($fieldName)) {
    [2450] =>                 if (is_object($object) && $object->hasMethod('scaffoldSearchField')) {
    [2451] =>                     $field = $object->scaffoldSearchField();
    [2452] =>                 } else {
    [2453] =>                     throw new Exception(sprintf(
    [2454] =>                         "SearchField '%s' on '%s' does not return a valid DBField instance.",
    [2455] =>                         $fieldName,
    [2456] =>                         get_class($this)
    [2457] =>                     ));
    [2458] =>                 }
    [2459] =>             }
    [2460] => 
    [2461] =>             // Allow fields to opt out of search
    [2462] =>             if (!$field) {
    [2463] =>                 continue;
    [2464] =>             }
    [2465] => 
    [2466] =>             if (strstr($fieldName ?? '', '.')) {
    [2467] =>                 $field->setName(str_replace('.', '__', $fieldName ?? ''));
    [2468] =>             }
    [2469] =>             $field->setTitle($spec['title']);
    [2470] => 
    [2471] =>             $fields->push($field);
    [2472] =>         }
    [2473] => 
    [2474] =>         // Only include general search if there are fields it can search on
    [2475] =>         $generalSearch = $this->getGeneralSearchFieldName();
    [2476] =>         if ($generalSearch !== '' && $fields->count() > 0) {
    [2477] =>             if ($fields->fieldByName($generalSearch) || $fields->dataFieldByName($generalSearch)) {
    [2478] =>                 throw new LogicException('General search field name must be unique.');
    [2479] =>             }
    [2480] =>             $fields->unshift(HiddenField::create($generalSearch, _t(self::class . '.GENERALSEARCH', 'General Search')));
    [2481] =>         }
    [2482] => 
    [2483] =>         return $fields;
    [2484] =>     }
    [2485] => 
    [2486] =>     /**
    [2487] =>      * Scaffold a simple edit form for all properties on this dataobject,
    [2488] =>      * based on default {@link FormField} mapping in {@link DBField::scaffoldFormField()}.
    [2489] =>      * Field labels/titles will be auto generated from {@link DataObject::fieldLabels()}.
    [2490] =>      *
    [2491] =>      * @uses FormScaffolder
    [2492] =>      *
    [2493] =>      * @param array $_params Associative array passing through properties to {@link FormScaffolder}.
    [2494] =>      * @return FieldList
    [2495] =>      */
    [2496] =>     public function scaffoldFormFields($_params = null)
    [2497] =>     {
    [2498] =>         $params = array_merge(
    [2499] =>             [
    [2500] =>                 'tabbed' => false,
    [2501] =>                 'includeRelations' => false,
    [2502] =>                 'restrictFields' => false,
    [2503] =>                 'fieldClasses' => false,
    [2504] =>                 'ajaxSafe' => false
    [2505] =>             ],
    [2506] =>             (array)$_params
    [2507] =>         );
    [2508] => 
    [2509] =>         $fs = FormScaffolder::create($this);
    [2510] =>         $fs->tabbed = $params['tabbed'];
    [2511] =>         $fs->includeRelations = $params['includeRelations'];
    [2512] =>         $fs->restrictFields = $params['restrictFields'];
    [2513] =>         $fs->fieldClasses = $params['fieldClasses'];
    [2514] =>         $fs->ajaxSafe = $params['ajaxSafe'];
    [2515] => 
    [2516] =>         $this->extend('updateFormScaffolder', $fs, $this);
    [2517] => 
    [2518] =>         return $fs->getFieldList();
    [2519] =>     }
    [2520] => 
    [2521] =>     /**
    [2522] =>      * Allows user code to hook into DataObject::getCMSFields prior to updateCMSFields
    [2523] =>      * being called on extensions
    [2524] =>      *
    [2525] =>      * @param callable $callback The callback to execute
    [2526] =>      */
    [2527] =>     protected function beforeUpdateCMSFields($callback)
    [2528] =>     {
    [2529] =>         $this->beforeExtending('updateCMSFields', $callback);
    [2530] =>     }
    [2531] => 
    [2532] =>     /**
    [2533] =>      * Allows user code to hook into DataObject::getCMSFields after updateCMSFields
    [2534] =>      * being called on extensions
    [2535] =>      *
    [2536] =>      * @param callable $callback The callback to execute
    [2537] =>      */
    [2538] =>     protected function afterUpdateCMSFields(callable $callback)
    [2539] =>     {
    [2540] =>         $this->afterExtending('updateCMSFields', $callback);
    [2541] =>     }
    [2542] => 
    [2543] =>     /**
    [2544] =>      * Centerpiece of every data administration interface in Silverstripe,
    [2545] =>      * which returns a {@link FieldList} suitable for a {@link Form} object.
    [2546] =>      * If not overloaded, we're using {@link scaffoldFormFields()} to automatically
    [2547] =>      * generate this set. To customize, overload this method in a subclass
    [2548] =>      * or extended onto it by using {@link DataExtension->updateCMSFields()}.
    [2549] =>      *
    [2550] =>      * <code>
    [2551] =>      * class MyCustomClass extends DataObject {
    [2552] =>      *  static $db = array('CustomProperty'=>'Boolean');
    [2553] =>      *
    [2554] =>      *  function getCMSFields() {
    [2555] =>      *    $fields = parent::getCMSFields();
    [2556] =>      *    $fields->addFieldToTab('Root.Content',new CheckboxField('CustomProperty'));
    [2557] =>      *    return $fields;
    [2558] =>      *  }
    [2559] =>      * }
    [2560] =>      * </code>
    [2561] =>      *
    [2562] =>      * @see Good example of complex FormField building: SiteTree::getCMSFields()
    [2563] =>      *
    [2564] =>      * @return FieldList Returns a TabSet for usage within the CMS - don't use for frontend forms.
    [2565] =>      */
    [2566] =>     public function getCMSFields()
    [2567] =>     {
    [2568] =>         $tabbedFields = $this->scaffoldFormFields([
    [2569] =>             // Don't allow has_many/many_many relationship editing before the record is first saved
    [2570] =>             'includeRelations' => ($this->ID > 0),
    [2571] =>             'tabbed' => true,
    [2572] =>             'ajaxSafe' => true
    [2573] =>         ]);
    [2574] => 
    [2575] =>         $this->extend('updateCMSFields', $tabbedFields);
    [2576] => 
    [2577] =>         return $tabbedFields;
    [2578] =>     }
    [2579] => 
    [2580] =>     /**
    [2581] =>      * need to be overload by solid dataobject, so that the customised actions of that dataobject,
    [2582] =>      * including that dataobject's extensions customised actions could be added to the EditForm.
    [2583] =>      *
    [2584] =>      * @return FieldList an Empty FieldList(); need to be overload by solid subclass
    [2585] =>      */
    [2586] =>     public function getCMSActions()
    [2587] =>     {
    [2588] =>         $actions = new FieldList();
    [2589] =>         $this->extend('updateCMSActions', $actions);
    [2590] =>         return $actions;
    [2591] =>     }
    [2592] => 
    [2593] =>     /**
    [2594] =>      * When extending this class and overriding this method, you will need to instantiate the CompositeValidator by
    [2595] =>      * calling parent::getCMSCompositeValidator(). This will ensure that the appropriate extension point is also
    [2596] =>      * invoked.
    [2597] =>      *
    [2598] =>      * You can also update the CompositeValidator by creating an Extension and implementing the
    [2599] =>      * updateCMSCompositeValidator(CompositeValidator $compositeValidator) method.
    [2600] =>      *
    [2601] =>      * @see CompositeValidator for examples of implementation
    [2602] =>      * @return CompositeValidator
    [2603] =>      */
    [2604] =>     public function getCMSCompositeValidator(): CompositeValidator
    [2605] =>     {
    [2606] =>         $compositeValidator = CompositeValidator::create([FieldsValidator::create()]);
    [2607] => 
    [2608] =>         // Support for the old method during the deprecation period
    [2609] =>         if ($this->hasMethod('getCMSValidator')) {
    [2610] =>             $compositeValidator->addValidator($this->getCMSValidator());
    [2611] =>         }
    [2612] => 
    [2613] =>         // Extend validator - forward support, will be supported beyond 5.0.0
    [2614] =>         $this->invokeWithExtensions('updateCMSCompositeValidator', $compositeValidator);
    [2615] => 
    [2616] =>         return $compositeValidator;
    [2617] =>     }
    [2618] => 
    [2619] =>     /**
    [2620] =>      * Used for simple frontend forms without relation editing
    [2621] =>      * or {@link TabSet} behaviour. Uses {@link scaffoldFormFields()}
    [2622] =>      * by default. To customize, either overload this method in your
    [2623] =>      * subclass, or extend it by {@link DataExtension->updateFrontEndFields()}.
    [2624] =>      *
    [2625] =>      * @todo Decide on naming for "website|frontend|site|page" and stick with it in the API
    [2626] =>      *
    [2627] =>      * @param array $params See {@link scaffoldFormFields()}
    [2628] =>      * @return FieldList Always returns a simple field collection without TabSet.
    [2629] =>      */
    [2630] =>     public function getFrontEndFields($params = null)
    [2631] =>     {
    [2632] =>         $untabbedFields = $this->scaffoldFormFields($params);
    [2633] =>         $this->extend('updateFrontEndFields', $untabbedFields);
    [2634] => 
    [2635] =>         return $untabbedFields;
    [2636] =>     }
    [2637] => 
    [2638] =>     public function getViewerTemplates($suffix = '')
    [2639] =>     {
    [2640] =>         return SSViewer::get_templates_by_class(static::class, $suffix, $this->baseClass());
    [2641] =>     }
    [2642] => 
    [2643] =>     /**
    [2644] =>      * Gets the value of a field.
    [2645] =>      * Called by {@link __get()} and any getFieldName() methods you might create.
    [2646] =>      *
    [2647] =>      * @param string $field The name of the field
    [2648] =>      * @return mixed The field value
    [2649] =>      */
    [2650] =>     public function getField($field)
    [2651] =>     {
    [2652] =>         // If we already have a value in $this->record, then we should just return that
    [2653] =>         if (isset($this->record[$field])) {
    [2654] =>             return $this->record[$field];
    [2655] =>         }
    [2656] => 
    [2657] =>         // Do we have a field that needs to be lazy loaded?
    [2658] =>         if (isset($this->record[$field . '_Lazy'])) {
    [2659] =>             $tableClass = $this->record[$field . '_Lazy'];
    [2660] =>             $this->loadLazyFields($tableClass);
    [2661] =>         }
    [2662] =>         $schema = static::getSchema();
    [2663] => 
    [2664] =>         // Support unary relations as fields
    [2665] =>         if ($schema->unaryComponent(static::class, $field)) {
    [2666] =>             return $this->getComponent($field);
    [2667] =>         }
    [2668] => 
    [2669] =>         // In case of complex fields, return the DBField object
    [2670] =>         if ($schema->compositeField(static::class, $field)) {
    [2671] =>             $this->record[$field] = $this->dbObject($field);
    [2672] =>         }
    [2673] => 
    [2674] =>         return isset($this->record[$field]) ? $this->record[$field] : null;
    [2675] =>     }
    [2676] => 
    [2677] =>     /**
    [2678] =>      * Loads all the stub fields that an initial lazy load didn't load fully.
    [2679] =>      *
    [2680] =>      * @param string $class Class to load the values from. Others are joined as required.
    [2681] =>      * Not specifying a tableClass will load all lazy fields from all tables.
    [2682] =>      * @return bool Flag if lazy loading succeeded
    [2683] =>      */
    [2684] =>     protected function loadLazyFields($class = null)
    [2685] =>     {
    [2686] =>         if (!$this->isInDB() || !is_numeric($this->ID)) {
    [2687] =>             return false;
    [2688] =>         }
    [2689] => 
    [2690] =>         if (!$class) {
    [2691] =>             $loaded = [];
    [2692] => 
    [2693] =>             foreach ($this->record as $key => $value) {
    [2694] =>                 if (strlen($key ?? '') > 5 && substr($key ?? '', -5) == '_Lazy' && !array_key_exists($value, $loaded ?? [])) {
    [2695] =>                     $this->loadLazyFields($value);
    [2696] =>                     $loaded[$value] = $value;
    [2697] =>                 }
    [2698] =>             }
    [2699] => 
    [2700] =>             return false;
    [2701] =>         }
    [2702] => 
    [2703] =>         $dataQuery = new DataQuery($class);
    [2704] => 
    [2705] =>         // Reset query parameter context to that of this DataObject
    [2706] =>         if ($params = $this->getSourceQueryParams()) {
    [2707] =>             foreach ($params as $key => $value) {
    [2708] =>                 $dataQuery->setQueryParam($key, $value);
    [2709] =>             }
    [2710] =>         }
    [2711] => 
    [2712] =>         // Limit query to the current record, unless it has the Versioned extension,
    [2713] =>         // in which case it requires special handling through augmentLoadLazyFields()
    [2714] =>         $schema = static::getSchema();
    [2715] =>         $baseIDColumn = $schema->sqlColumnForField($this, 'ID');
    [2716] =>         $dataQuery->where([
    [2717] =>             $baseIDColumn => $this->record['ID']
    [2718] =>         ])->limit(1);
    [2719] => 
    [2720] =>         $columns = [];
    [2721] => 
    [2722] =>         // Add SQL for fields, both simple & multi-value
    [2723] =>         // TODO: This is copy & pasted from buildSQL(), it could be moved into a method
    [2724] =>         $databaseFields = $schema->databaseFields($class, false);
    [2725] =>         foreach ($databaseFields as $k => $v) {
    [2726] =>             if (!isset($this->record[$k]) || $this->record[$k] === null) {
    [2727] =>                 $columns[] = $k;
    [2728] =>             }
    [2729] =>         }
    [2730] => 
    [2731] =>         if ($columns) {
    [2732] =>             $query = $dataQuery->query();
    [2733] =>             $this->extend('augmentLoadLazyFields', $query, $dataQuery, $this);
    [2734] =>             $this->extend('augmentSQL', $query, $dataQuery);
    [2735] => 
    [2736] =>             $dataQuery->setQueriedColumns($columns);
    [2737] =>             $newData = $dataQuery->execute()->record();
    [2738] => 
    [2739] =>             // Load the data into record
    [2740] =>             if ($newData) {
    [2741] =>                 foreach ($newData as $k => $v) {
    [2742] =>                     if (in_array($k, $columns ?? [])) {
    [2743] =>                         $this->record[$k] = $v;
    [2744] =>                         $this->original[$k] = $v;
    [2745] =>                         unset($this->record[$k . '_Lazy']);
    [2746] =>                     }
    [2747] =>                 }
    [2748] => 
    [2749] =>             // No data means that the query returned nothing; assign 'null' to all the requested fields
    [2750] =>             } else {
    [2751] =>                 foreach ($columns as $k) {
    [2752] =>                     $this->record[$k] = null;
    [2753] =>                     $this->original[$k] = null;
    [2754] =>                     unset($this->record[$k . '_Lazy']);
    [2755] =>                 }
    [2756] =>             }
    [2757] =>         }
    [2758] =>         return true;
    [2759] =>     }
    [2760] => 
    [2761] =>     /**
    [2762] =>      * Return the fields that have changed since the last write.
    [2763] =>      *
    [2764] =>      * The change level affects what the functions defines as "changed":
    [2765] =>      * - Level CHANGE_STRICT (integer 1) will return strict changes, even !== ones.
    [2766] =>      * - Level CHANGE_VALUE (integer 2) is more lenient, it will only return real data changes,
    [2767] =>      *   for example a change from 0 to null would not be included.
    [2768] =>      *
    [2769] =>      * Example return:
    [2770] =>      * <code>
    [2771] =>      * array(
    [2772] =>      *   'Title' = array('before' => 'Home', 'after' => 'Home-Changed', 'level' => DataObject::CHANGE_VALUE)
    [2773] =>      * )
    [2774] =>      * </code>
    [2775] =>      *
    [2776] =>      * @param boolean|array $databaseFieldsOnly Filter to determine which fields to return. Set to true
    [2777] =>      * to return all database fields, or an array for an explicit filter. false returns all fields.
    [2778] =>      * @param int $changeLevel The strictness of what is defined as change. Defaults to strict
    [2779] =>      * @return array
    [2780] =>      */
    [2781] =>     public function getChangedFields($databaseFieldsOnly = false, $changeLevel = self::CHANGE_STRICT)
    [2782] =>     {
    [2783] =>         $changedFields = [];
    [2784] => 
    [2785] =>         // Update the changed array with references to changed obj-fields
    [2786] =>         foreach ($this->record as $k => $v) {
    [2787] =>             // Prevents DBComposite infinite looping on isChanged
    [2788] =>             if (is_array($databaseFieldsOnly) && !in_array($k, $databaseFieldsOnly ?? [])) {
    [2789] =>                 continue;
    [2790] =>             }
    [2791] =>             if (is_object($v) && method_exists($v, 'isChanged') && $v->isChanged()) {
    [2792] =>                 $this->changed[$k] = self::CHANGE_VALUE;
    [2793] =>             }
    [2794] =>         }
    [2795] => 
    [2796] =>         // If change was forced, then derive change data from $this->record
    [2797] =>         if ($this->changeForced && $changeLevel <= self::CHANGE_STRICT) {
    [2798] =>             $changed = array_combine(
    [2799] =>                 array_keys($this->record ?? []),
    [2800] =>                 array_fill(0, count($this->record ?? []), self::CHANGE_STRICT)
    [2801] =>             );
    [2802] =>             // @todo Find better way to allow versioned to write a new version after forceChange
    [2803] =>             unset($changed['Version']);
    [2804] =>         } else {
    [2805] =>             $changed = $this->changed;
    [2806] =>         }
    [2807] => 
    [2808] =>         if (is_array($databaseFieldsOnly)) {
    [2809] =>             $fields = array_intersect_key($changed ?? [], array_flip($databaseFieldsOnly ?? []));
    [2810] =>         } elseif ($databaseFieldsOnly) {
    [2811] =>             $fieldsSpecs = static::getSchema()->fieldSpecs(static::class);
    [2812] =>             $fields = array_intersect_key($changed ?? [], $fieldsSpecs);
    [2813] =>         } else {
    [2814] =>             $fields = $changed;
    [2815] =>         }
    [2816] => 
    [2817] =>         // Filter the list to those of a certain change level
    [2818] =>         if ($changeLevel > self::CHANGE_STRICT) {
    [2819] =>             if ($fields) {
    [2820] =>                 foreach ($fields as $name => $level) {
    [2821] =>                     if ($level < $changeLevel) {
    [2822] =>                         unset($fields[$name]);
    [2823] =>                     }
    [2824] =>                 }
    [2825] =>             }
    [2826] =>         }
    [2827] => 
    [2828] =>         if ($fields) {
    [2829] =>             foreach ($fields as $name => $level) {
    [2830] =>                 $changedFields[$name] = [
    [2831] =>                     'before' => array_key_exists($name, $this->original ?? []) ? $this->original[$name] : null,
    [2832] =>                     'after' => array_key_exists($name, $this->record ?? []) ? $this->record[$name] : null,
    [2833] =>                     'level' => $level
    [2834] =>                 ];
    [2835] =>             }
    [2836] =>         }
    [2837] => 
    [2838] =>         return $changedFields;
    [2839] =>     }
    [2840] => 
    [2841] =>     /**
    [2842] =>      * Uses {@link getChangedFields()} to determine if fields have been changed
    [2843] =>      * since loading them from the database.
    [2844] =>      *
    [2845] =>      * @param string $fieldName Name of the database field to check, will check for any if not given
    [2846] =>      * @param int $changeLevel See {@link getChangedFields()}
    [2847] =>      * @return boolean
    [2848] =>      */
    [2849] =>     public function isChanged($fieldName = null, $changeLevel = self::CHANGE_STRICT)
    [2850] =>     {
    [2851] =>         $fields = $fieldName ? [$fieldName] : true;
    [2852] =>         $changed = $this->getChangedFields($fields, $changeLevel);
    [2853] =>         if (!isset($fieldName)) {
    [2854] =>             return !empty($changed);
    [2855] =>         } else {
    [2856] =>             return array_key_exists($fieldName, $changed ?? []);
    [2857] =>         }
    [2858] =>     }
    [2859] => 
    [2860] =>     /**
    [2861] =>      * Set the value of the field
    [2862] =>      * Called by {@link __set()} and any setFieldName() methods you might create.
    [2863] =>      *
    [2864] =>      * @param string $fieldName Name of the field
    [2865] =>      * @param mixed $val New field value
    [2866] =>      * @return $this
    [2867] =>      */
    [2868] =>     public function setField($fieldName, $val)
    [2869] =>     {
    [2870] =>         $this->objCacheClear();
    [2871] =>         //if it's a has_one component, destroy the cache
    [2872] =>         if (substr($fieldName ?? '', -2) == 'ID') {
    [2873] =>             unset($this->components[substr($fieldName, 0, -2)]);
    [2874] =>         }
    [2875] => 
    [2876] =>         // If we've just lazy-loaded the column, then we need to populate the $original array
    [2877] =>         if (isset($this->record[$fieldName . '_Lazy'])) {
    [2878] =>             $tableClass = $this->record[$fieldName . '_Lazy'];
    [2879] =>             $this->loadLazyFields($tableClass);
    [2880] =>         }
    [2881] => 
    [2882] =>         // Support component assignent via field setter
    [2883] =>         $schema = static::getSchema();
    [2884] =>         if ($schema->unaryComponent(static::class, $fieldName)) {
    [2885] =>             unset($this->components[$fieldName]);
    [2886] =>             // Assign component directly
    [2887] =>             if (is_null($val) || $val instanceof DataObject) {
    [2888] =>                 return $this->setComponent($fieldName, $val);
    [2889] =>             }
    [2890] =>             // Assign by ID instead of object
    [2891] =>             if (is_numeric($val)) {
    [2892] =>                 $fieldName .= 'ID';
    [2893] =>             }
    [2894] =>         }
    [2895] => 
    [2896] =>         // Situation 1: Passing an DBField
    [2897] =>         if ($val instanceof DBField) {
    [2898] =>             $val->setName($fieldName);
    [2899] =>             $val->saveInto($this);
    [2900] => 
    [2901] =>             // Situation 1a: Composite fields should remain bound in case they are
    [2902] =>             // later referenced to update the parent dataobject
    [2903] =>             if ($val instanceof DBComposite) {
    [2904] =>                 $val->bindTo($this);
    [2905] =>                 $this->record[$fieldName] = $val;
    [2906] =>             }
    [2907] =>         // Situation 2: Passing a literal or non-DBField object
    [2908] =>         } else {
    [2909] =>             // If this is a proper database field, we shouldn't be getting non-DBField objects
    [2910] =>             if (is_object($val) && $schema->fieldSpec(static::class, $fieldName)) {
    [2911] =>                 throw new InvalidArgumentException('DataObject::setField: passed an object that is not a DBField');
    [2912] =>             }
    [2913] => 
    [2914] =>             if (!empty($val) && !is_scalar($val)) {
    [2915] =>                 $dbField = $this->dbObject($fieldName);
    [2916] =>                 if ($dbField && $dbField->scalarValueOnly()) {
    [2917] =>                     throw new InvalidArgumentException(
    [2918] =>                         sprintf(
    [2919] =>                             'DataObject::setField: %s only accepts scalars',
    [2920] =>                             $fieldName
    [2921] =>                         )
    [2922] =>                     );
    [2923] =>                 }
    [2924] =>             }
    [2925] => 
    [2926] =>             // if a field is not existing or has strictly changed
    [2927] =>             if (!array_key_exists($fieldName, $this->original ?? []) || $this->original[$fieldName] !== $val) {
    [2928] =>                 // TODO Add check for php-level defaults which are not set in the db
    [2929] =>                 // TODO Add check for hidden input-fields (readonly) which are not set in the db
    [2930] =>                 // At the very least, the type has changed
    [2931] =>                 $this->changed[$fieldName] = self::CHANGE_STRICT;
    [2932] => 
    [2933] =>                 if ((!array_key_exists($fieldName, $this->original ?? []) && $val)
    [2934] =>                     || (array_key_exists($fieldName, $this->original ?? []) && $this->original[$fieldName] != $val)
    [2935] =>                 ) {
    [2936] =>                     // Value has changed as well, not just the type
    [2937] =>                     $this->changed[$fieldName] = self::CHANGE_VALUE;
    [2938] =>                 }
    [2939] =>             // Value has been restored to its original, remove any record of the change
    [2940] =>             } elseif (isset($this->changed[$fieldName])) {
    [2941] =>                 unset($this->changed[$fieldName]);
    [2942] =>             }
    [2943] => 
    [2944] =>             // Value is saved regardless, since the change detection relates to the last write
    [2945] =>             $this->record[$fieldName] = $val;
    [2946] =>         }
    [2947] =>         return $this;
    [2948] =>     }
    [2949] => 
    [2950] =>     /**
    [2951] =>      * Set the value of the field, using a casting object.
    [2952] =>      * This is useful when you aren't sure that a date is in SQL format, for example.
    [2953] =>      * setCastedField() can also be used, by forms, to set related data.  For example, uploaded images
    [2954] =>      * can be saved into the Image table.
    [2955] =>      *
    [2956] =>      * @param string $fieldName Name of the field
    [2957] =>      * @param mixed $value New field value
    [2958] =>      * @return $this
    [2959] =>      */
    [2960] =>     public function setCastedField($fieldName, $value)
    [2961] =>     {
    [2962] =>         if (!$fieldName) {
    [2963] =>             throw new InvalidArgumentException("DataObject::setCastedField: Called without a fieldName");
    [2964] =>         }
    [2965] =>         $fieldObj = $this->dbObject($fieldName);
    [2966] =>         if ($fieldObj) {
    [2967] =>             $fieldObj->setValue($value);
    [2968] =>             $fieldObj->saveInto($this);
    [2969] =>         } else {
    [2970] =>             $this->$fieldName = $value;
    [2971] =>         }
    [2972] =>         return $this;
    [2973] =>     }
    [2974] => 
    [2975] =>     /**
    [2976] =>      * {@inheritdoc}
    [2977] =>      */
    [2978] =>     public function castingHelper($field)
    [2979] =>     {
    [2980] =>         $fieldSpec = static::getSchema()->fieldSpec(static::class, $field);
    [2981] =>         if ($fieldSpec) {
    [2982] =>             return $fieldSpec;
    [2983] =>         }
    [2984] => 
    [2985] =>         // many_many_extraFields aren't presented by db(), so we check if the source query params
    [2986] =>         // provide us with meta-data for a many_many relation we can inspect for extra fields.
    [2987] =>         $queryParams = $this->getSourceQueryParams();
    [2988] =>         if (!empty($queryParams['Component.ExtraFields'])) {
    [2989] =>             $extraFields = $queryParams['Component.ExtraFields'];
    [2990] => 
    [2991] =>             if (isset($extraFields[$field])) {
    [2992] =>                 return $extraFields[$field];
    [2993] =>             }
    [2994] =>         }
    [2995] => 
    [2996] =>         return parent::castingHelper($field);
    [2997] =>     }
    [2998] => 
    [2999] =>     /**
    [3000] =>      * Returns true if the given field exists in a database column on any of
    [3001] =>      * the objects tables and optionally look up a dynamic getter with
    [3002] =>      * get<fieldName>().
    [3003] =>      *
    [3004] =>      * @param string $field Name of the field
    [3005] =>      * @return boolean True if the given field exists
    [3006] =>      */
    [3007] =>     public function hasField($field)
    [3008] =>     {
    [3009] =>         $schema = static::getSchema();
    [3010] =>         return (
    [3011] =>             array_key_exists($field, $this->record ?? [])
    [3012] =>             || array_key_exists($field, $this->components ?? [])
    [3013] =>             || $schema->fieldSpec(static::class, $field)
    [3014] =>             || $schema->unaryComponent(static::class, $field)
    [3015] =>             || $this->hasMethod("get{$field}")
    [3016] =>         );
    [3017] =>     }
    [3018] => 
    [3019] =>     /**
    [3020] =>      * Returns true if the given field exists as a database column
    [3021] =>      *
    [3022] =>      * @param string $field Name of the field
    [3023] =>      *
    [3024] =>      * @return boolean
    [3025] =>      */
    [3026] =>     public function hasDatabaseField($field)
    [3027] =>     {
    [3028] =>         $spec = static::getSchema()->fieldSpec(static::class, $field, DataObjectSchema::DB_ONLY);
    [3029] =>         return !empty($spec);
    [3030] =>     }
    [3031] => 
    [3032] =>     /**
    [3033] =>      * Returns true if the member is allowed to do the given action.
    [3034] =>      * See {@link extendedCan()} for a more versatile tri-state permission control.
    [3035] =>      *
    [3036] =>      * @param string $perm The permission to be checked, such as 'View'.
    [3037] =>      * @param Member $member The member whose permissions need checking.  Defaults to the currently logged
    [3038] =>      * in user.
    [3039] =>      * @param array $context Additional $context to pass to extendedCan()
    [3040] =>      *
    [3041] =>      * @return boolean True if the the member is allowed to do the given action
    [3042] =>      */
    [3043] =>     public function can($perm, $member = null, $context = [])
    [3044] =>     {
    [3045] =>         if (!$member) {
    [3046] =>             $member = Security::getCurrentUser();
    [3047] =>         }
    [3048] => 
    [3049] =>         if ($member && Permission::checkMember($member, "ADMIN")) {
    [3050] =>             return true;
    [3051] =>         }
    [3052] => 
    [3053] =>         if (is_string($perm) && method_exists($this, 'can' . ucfirst($perm ?? ''))) {
    [3054] =>             $method = 'can' . ucfirst($perm ?? '');
    [3055] =>             return $this->$method($member);
    [3056] =>         }
    [3057] => 
    [3058] =>         $results = $this->extendedCan('can', $member);
    [3059] =>         if (isset($results)) {
    [3060] =>             return $results;
    [3061] =>         }
    [3062] => 
    [3063] =>         return ($member && Permission::checkMember($member, $perm));
    [3064] =>     }
    [3065] => 
    [3066] =>     /**
    [3067] =>      * Process tri-state responses from permission-alterting extensions.  The extensions are
    [3068] =>      * expected to return one of three values:
    [3069] =>      *
    [3070] =>      *  - false: Disallow this permission, regardless of what other extensions say
    [3071] =>      *  - true: Allow this permission, as long as no other extensions return false
    [3072] =>      *  - NULL: Don't affect the outcome
    [3073] =>      *
    [3074] =>      * This method itself returns a tri-state value, and is designed to be used like this:
    [3075] =>      *
    [3076] =>      * <code>
    [3077] =>      * $extended = $this->extendedCan('canDoSomething', $member);
    [3078] =>      * if ($extended !== null) return $extended;
    [3079] =>      * else return $normalValue;
    [3080] =>      * </code>
    [3081] =>      *
    [3082] =>      * @param string $methodName Method on the same object, e.g. {@link canEdit()}
    [3083] =>      * @param Member|int $member
    [3084] =>      * @param array $context Optional context
    [3085] =>      * @return boolean|null
    [3086] =>      */
    [3087] =>     public function extendedCan($methodName, $member, $context = [])
    [3088] =>     {
    [3089] =>         $results = $this->extend($methodName, $member, $context);
    [3090] =>         if ($results && is_array($results)) {
    [3091] =>             // Remove NULLs
    [3092] =>             $results = array_filter($results ?? [], function ($v) {
    [3093] =>                 return !is_null($v);
    [3094] =>             });
    [3095] =>             // If there are any non-NULL responses, then return the lowest one of them.
    [3096] =>             // If any explicitly deny the permission, then we don't get access
    [3097] =>             if ($results) {
    [3098] =>                 return min($results);
    [3099] =>             }
    [3100] =>         }
    [3101] =>         return null;
    [3102] =>     }
    [3103] => 
    [3104] =>     /**
    [3105] =>      * @param Member $member
    [3106] =>      * @return boolean
    [3107] =>      */
    [3108] =>     public function canView($member = null)
    [3109] =>     {
    [3110] =>         $extended = $this->extendedCan(__FUNCTION__, $member);
    [3111] =>         if ($extended !== null) {
    [3112] =>             return $extended;
    [3113] =>         }
    [3114] =>         return Permission::check('ADMIN', 'any', $member);
    [3115] =>     }
    [3116] => 
    [3117] =>     /**
    [3118] =>      * @param Member $member
    [3119] =>      * @return boolean
    [3120] =>      */
    [3121] =>     public function canEdit($member = null)
    [3122] =>     {
    [3123] =>         $extended = $this->extendedCan(__FUNCTION__, $member);
    [3124] =>         if ($extended !== null) {
    [3125] =>             return $extended;
    [3126] =>         }
    [3127] =>         return Permission::check('ADMIN', 'any', $member);
    [3128] =>     }
    [3129] => 
    [3130] =>     /**
    [3131] =>      * @param Member $member
    [3132] =>      * @return boolean
    [3133] =>      */
    [3134] =>     public function canDelete($member = null)
    [3135] =>     {
    [3136] =>         $extended = $this->extendedCan(__FUNCTION__, $member);
    [3137] =>         if ($extended !== null) {
    [3138] =>             return $extended;
    [3139] =>         }
    [3140] =>         return Permission::check('ADMIN', 'any', $member);
    [3141] =>     }
    [3142] => 
    [3143] =>     /**
    [3144] =>      * @param Member $member
    [3145] =>      * @param array $context Additional context-specific data which might
    [3146] =>      * affect whether (or where) this object could be created.
    [3147] =>      * @return boolean
    [3148] =>      */
    [3149] =>     public function canCreate($member = null, $context = [])
    [3150] =>     {
    [3151] =>         $extended = $this->extendedCan(__FUNCTION__, $member, $context);
    [3152] =>         if ($extended !== null) {
    [3153] =>             return $extended;
    [3154] =>         }
    [3155] =>         return Permission::check('ADMIN', 'any', $member);
    [3156] =>     }
    [3157] => 
    [3158] =>     /**
    [3159] =>      * Debugging used by Debug::show()
    [3160] =>      *
    [3161] =>      * @return string HTML data representing this object
    [3162] =>      */
    [3163] =>     public function debug()
    [3164] =>     {
    [3165] =>         $class = static::class;
    [3166] =>         $val = "<h3>Database record: {$class}</h3>\n<ul>\n";
    [3167] =>         if ($this->record) {
    [3168] =>             foreach ($this->record as $fieldName => $fieldVal) {
    [3169] =>                 $val .= "\t<li>$fieldName: " . Debug::text($fieldVal) . "</li>\n";
    [3170] =>             }
    [3171] =>         }
    [3172] =>         $val .= "</ul>\n";
    [3173] =>         return $val;
    [3174] =>     }
    [3175] => 
    [3176] =>     /**
    [3177] =>      * Return the DBField object that represents the given field.
    [3178] =>      * This works similarly to obj() with 2 key differences:
    [3179] =>      *   - it still returns an object even when the field has no value.
    [3180] =>      *   - it only matches fields and not methods
    [3181] =>      *   - it matches foreign keys generated by has_one relationships, eg, "ParentID"
    [3182] =>      *
    [3183] =>      * @param string $fieldName Name of the field
    [3184] =>      * @return DBField The field as a DBField object
    [3185] =>      */
    [3186] =>     public function dbObject($fieldName)
    [3187] =>     {
    [3188] =>         // Check for field in DB
    [3189] =>         $schema = static::getSchema();
    [3190] =>         $helper = $schema->fieldSpec(static::class, $fieldName, DataObjectSchema::INCLUDE_CLASS);
    [3191] =>         if (!$helper) {
    [3192] =>             return null;
    [3193] =>         }
    [3194] => 
    [3195] =>         if (!isset($this->record[$fieldName]) && isset($this->record[$fieldName . '_Lazy'])) {
    [3196] =>             $tableClass = $this->record[$fieldName . '_Lazy'];
    [3197] =>             $this->loadLazyFields($tableClass);
    [3198] =>         }
    [3199] => 
    [3200] =>         $value = isset($this->record[$fieldName])
    [3201] =>             ? $this->record[$fieldName]
    [3202] =>             : null;
    [3203] => 
    [3204] =>         // If we have a DBField object in $this->record, then return that
    [3205] =>         if ($value instanceof DBField) {
    [3206] =>             return $value;
    [3207] =>         }
    [3208] => 
    [3209] =>         $pos = strpos($helper ?? '', '.');
    [3210] =>         $class = substr($helper ?? '', 0, $pos);
    [3211] =>         $spec = substr($helper ?? '', $pos + 1);
    [3212] => 
    [3213] =>         /** @var DBField $obj */
    [3214] =>         $table = $schema->tableName($class);
    [3215] =>         $obj = Injector::inst()->create($spec, $fieldName);
    [3216] =>         $obj->setTable($table);
    [3217] =>         $obj->setValue($value, $this, false);
    [3218] =>         return $obj;
    [3219] =>     }
    [3220] => 
    [3221] =>     /**
    [3222] =>      * Traverses to a DBField referenced by relationships between data objects.
    [3223] =>      *
    [3224] =>      * The path to the related field is specified with dot separated syntax
    [3225] =>      * (eg: Parent.Child.Child.FieldName).
    [3226] =>      *
    [3227] =>      * If a relation is blank, this will return null instead.
    [3228] =>      * If a relation name is invalid (e.g. non-relation on a parent) this
    [3229] =>      * can throw a LogicException.
    [3230] =>      *
    [3231] =>      * @param string $fieldPath List of paths on this object. All items in this path
    [3232] =>      * must be ViewableData implementors
    [3233] =>      *
    [3234] =>      * @return mixed DBField of the field on the object or a DataList instance.
    [3235] =>      * @throws LogicException If accessing invalid relations
    [3236] =>      */
    [3237] =>     public function relObject($fieldPath)
    [3238] =>     {
    [3239] =>         $object = null;
    [3240] =>         $component = $this;
    [3241] => 
    [3242] =>         // Parse all relations
    [3243] =>         foreach (explode('.', $fieldPath ?? '') as $relation) {
    [3244] =>             if (!$component) {
    [3245] =>                 return null;
    [3246] =>             }
    [3247] => 
    [3248] =>             // Inspect relation type
    [3249] =>             if (ClassInfo::hasMethod($component, $relation)) {
    [3250] =>                 $component = $component->$relation();
    [3251] =>             } elseif ($component instanceof Relation || $component instanceof DataList) {
    [3252] =>                 // $relation could either be a field (aggregate), or another relation
    [3253] =>                 $singleton = DataObject::singleton($component->dataClass());
    [3254] =>                 $component = $singleton->dbObject($relation) ?: $component->relation($relation);
    [3255] =>             } elseif ($component instanceof DataObject && ($dbObject = $component->dbObject($relation))) {
    [3256] =>                 $component = $dbObject;
    [3257] =>             } elseif ($component instanceof ViewableData && $component->hasField($relation)) {
    [3258] =>                 $component = $component->obj($relation);
    [3259] =>             } else {
    [3260] =>                 throw new LogicException(
    [3261] =>                     "$relation is not a relation/field on " . get_class($component)
    [3262] =>                 );
    [3263] =>             }
    [3264] =>         }
    [3265] =>         return $component;
    [3266] =>     }
    [3267] => 
    [3268] =>     /**
    [3269] =>      * Traverses to a field referenced by relationships between data objects, returning the value
    [3270] =>      * The path to the related field is specified with dot separated syntax (eg: Parent.Child.Child.FieldName)
    [3271] =>      *
    [3272] =>      * @param string $fieldName string
    [3273] =>      * @return mixed Will return null on a missing value
    [3274] =>      */
    [3275] =>     public function relField($fieldName)
    [3276] =>     {
    [3277] =>         // Navigate to relative parent using relObject() if needed
    [3278] =>         $component = $this;
    [3279] =>         if (($pos = strrpos($fieldName ?? '', '.')) !== false) {
    [3280] =>             $relation = substr($fieldName ?? '', 0, $pos);
    [3281] =>             $fieldName = substr($fieldName ?? '', $pos + 1);
    [3282] =>             $component = $this->relObject($relation);
    [3283] =>         }
    [3284] => 
    [3285] =>         // Bail if the component is null
    [3286] =>         if (!$component) {
    [3287] =>             return null;
    [3288] =>         }
    [3289] =>         if (ClassInfo::hasMethod($component, $fieldName)) {
    [3290] =>             return $component->$fieldName();
    [3291] =>         }
    [3292] =>         return $component->$fieldName;
    [3293] =>     }
    [3294] => 
    [3295] =>     /**
    [3296] =>      * Temporary hack to return an association name, based on class, to get around the mangle
    [3297] =>      * of having to deal with reverse lookup of relationships to determine autogenerated foreign keys.
    [3298] =>      *
    [3299] =>      * @param string $className
    [3300] =>      * @return string
    [3301] =>      */
    [3302] =>     public function getReverseAssociation($className)
    [3303] =>     {
    [3304] =>         if (is_array($this->manyMany())) {
    [3305] =>             $many_many = array_flip($this->manyMany() ?? []);
    [3306] =>             if (array_key_exists($className, $many_many ?? [])) {
    [3307] =>                 return $many_many[$className];
    [3308] =>             }
    [3309] =>         }
    [3310] =>         if (is_array($this->hasMany())) {
    [3311] =>             $has_many = array_flip($this->hasMany() ?? []);
    [3312] =>             if (array_key_exists($className, $has_many ?? [])) {
    [3313] =>                 return $has_many[$className];
    [3314] =>             }
    [3315] =>         }
    [3316] =>         if (is_array($this->hasOne())) {
    [3317] =>             $has_one = array_flip($this->hasOne() ?? []);
    [3318] =>             if (array_key_exists($className, $has_one ?? [])) {
    [3319] =>                 return $has_one[$className];
    [3320] =>             }
    [3321] =>         }
    [3322] => 
    [3323] =>         return false;
    [3324] =>     }
    [3325] => 
    [3326] =>     /**
    [3327] =>      * Return all objects matching the filter
    [3328] =>      * sub-classes are automatically selected and included
    [3329] =>      *
    [3330] =>      * @param string $callerClass The class of objects to be returned
    [3331] =>      * @param string|array $filter A filter to be inserted into the WHERE clause.
    [3332] =>      * Supports parameterised queries. See SQLSelect::addWhere() for syntax examples.
    [3333] =>      * @param string|array $sort A sort expression to be inserted into the ORDER
    [3334] =>      * BY clause.  If omitted, self::$default_sort will be used.
    [3335] =>      * @param string $join Deprecated 3.0 Join clause. Use leftJoin($table, $joinClause) instead.
    [3336] =>      * @param string|array $limit A limit expression to be inserted into the LIMIT clause.
    [3337] =>      * @param string $containerClass The container class to return the results in.
    [3338] =>      *
    [3339] =>      * @todo $containerClass is Ignored, why?
    [3340] =>      *
    [3341] =>      * @return DataList The objects matching the filter, in the class specified by $containerClass
    [3342] =>      */
    [3343] =>     public static function get(
    [3344] =>         $callerClass = null,
    [3345] =>         $filter = "",
    [3346] =>         $sort = "",
    [3347] =>         $join = "",
    [3348] =>         $limit = null,
    [3349] =>         $containerClass = DataList::class
    [3350] =>     ) {
    [3351] =>         // Validate arguments
    [3352] =>         if ($callerClass == null) {
    [3353] =>             $callerClass = get_called_class();
    [3354] =>             if ($callerClass === self::class) {
    [3355] =>                 throw new InvalidArgumentException('Call <classname>::get() instead of DataObject::get()');
    [3356] =>             }
    [3357] =>             if ($filter || $sort || $join || $limit || ($containerClass !== DataList::class)) {
    [3358] =>                 throw new InvalidArgumentException('If calling <classname>::get() then you shouldn\'t pass any other'
    [3359] =>                     . ' arguments');
    [3360] =>             }
    [3361] =>         } elseif ($callerClass === self::class) {
    [3362] =>             throw new InvalidArgumentException('DataObject::get() cannot query non-subclass DataObject directly');
    [3363] =>         }
    [3364] =>         if ($join) {
    [3365] =>             throw new InvalidArgumentException(
    [3366] =>                 'The $join argument has been removed. Use leftJoin($table, $joinClause) instead.'
    [3367] =>             );
    [3368] =>         }
    [3369] => 
    [3370] =>         // Build and decorate with args
    [3371] =>         $result = DataList::create($callerClass);
    [3372] =>         if ($filter) {
    [3373] =>             $result = $result->where($filter);
    [3374] =>         }
    [3375] =>         if ($sort) {
    [3376] =>             $result = $result->sort($sort);
    [3377] =>         }
    [3378] =>         if ($limit && strpos($limit ?? '', ',') !== false) {
    [3379] =>             $limitArguments = explode(',', $limit ?? '');
    [3380] =>             $result = $result->limit($limitArguments[1], $limitArguments[0]);
    [3381] =>         } elseif ($limit) {
    [3382] =>             $result = $result->limit($limit);
    [3383] =>         }
    [3384] => 
    [3385] =>         return $result;
    [3386] =>     }
    [3387] => 
    [3388] => 
    [3389] =>     /**
    [3390] =>      * Return the first item matching the given query.
    [3391] =>      *
    [3392] =>      * The object returned is cached, unlike DataObject::get()->first() {@link DataList::first()}
    [3393] =>      * and DataObject::get()->last() {@link DataList::last()}
    [3394] =>      *
    [3395] =>      * The filter argument supports parameterised queries (see SQLSelect::addWhere() for syntax examples). Because
    [3396] =>      * of that (and differently from e.g. DataList::filter()) you need to manually escape the field names:
    [3397] =>      * <code>
    [3398] =>      * $member = DataObject::get_one('Member', [ '"FirstName"' => 'John' ]);
    [3399] =>      * </code>
    [3400] =>      *
    [3401] =>      * @param string $callerClass The class of objects to be returned
    [3402] =>      * @param string|array $filter A filter to be inserted into the WHERE clause.
    [3403] =>      * @param boolean $cache Use caching
    [3404] =>      * @param string $orderby A sort expression to be inserted into the ORDER BY clause.
    [3405] =>      *
    [3406] =>      * @return DataObject|null The first item matching the query
    [3407] =>      */
    [3408] =>     public static function get_one($callerClass, $filter = "", $cache = true, $orderby = "")
    [3409] =>     {
    [3410] =>         /** @var DataObject $singleton */
    [3411] =>         $singleton = singleton($callerClass);
    [3412] => 
    [3413] =>         $cacheComponents = [$filter, $orderby, $singleton->getUniqueKeyComponents()];
    [3414] =>         $cacheKey = md5(serialize($cacheComponents));
    [3415] => 
    [3416] =>         $item = null;
    [3417] =>         if (!$cache || !isset(self::$_cache_get_one[$callerClass][$cacheKey])) {
    [3418] =>             $dl = DataObject::get($callerClass)->where($filter)->sort($orderby);
    [3419] =>             $item = $dl->first();
    [3420] => 
    [3421] =>             if ($cache) {
    [3422] =>                 self::$_cache_get_one[$callerClass][$cacheKey] = $item;
    [3423] =>                 if (!self::$_cache_get_one[$callerClass][$cacheKey]) {
    [3424] =>                     self::$_cache_get_one[$callerClass][$cacheKey] = false;
    [3425] =>                 }
    [3426] =>             }
    [3427] =>         }
    [3428] => 
    [3429] =>         if ($cache) {
    [3430] =>             return self::$_cache_get_one[$callerClass][$cacheKey] ?: null;
    [3431] =>         }
    [3432] => 
    [3433] =>         return $item;
    [3434] =>     }
    [3435] => 
    [3436] =>     /**
    [3437] =>      * Flush the cached results for all relations (has_one, has_many, many_many)
    [3438] =>      * Also clears any cached aggregate data.
    [3439] =>      *
    [3440] =>      * @param boolean $persistent When true will also clear persistent data stored in the Cache system.
    [3441] =>      *                            When false will just clear session-local cached data
    [3442] =>      * @return DataObject $this
    [3443] =>      */
    [3444] =>     public function flushCache($persistent = true)
    [3445] =>     {
    [3446] =>         if (static::class == self::class) {
    [3447] =>             self::$_cache_get_one = [];
    [3448] =>             return $this;
    [3449] =>         }
    [3450] => 
    [3451] =>         $classes = ClassInfo::ancestry(static::class);
    [3452] =>         foreach ($classes as $class) {
    [3453] =>             if (isset(self::$_cache_get_one[$class])) {
    [3454] =>                 unset(self::$_cache_get_one[$class]);
    [3455] =>             }
    [3456] =>         }
    [3457] => 
    [3458] =>         $this->extend('flushCache');
    [3459] => 
    [3460] =>         $this->components = [];
    [3461] =>         return $this;
    [3462] =>     }
    [3463] => 
    [3464] =>     /**
    [3465] =>      * Flush the get_one global cache and destroy associated objects.
    [3466] =>      */
    [3467] =>     public static function flush_and_destroy_cache()
    [3468] =>     {
    [3469] =>         if (self::$_cache_get_one) {
    [3470] =>             foreach (self::$_cache_get_one as $class => $items) {
    [3471] =>                 if (is_array($items)) {
    [3472] =>                     foreach ($items as $item) {
    [3473] =>                         if ($item) {
    [3474] =>                             $item->destroy();
    [3475] =>                         }
    [3476] =>                     }
    [3477] =>                 }
    [3478] =>             }
    [3479] =>         }
    [3480] =>         self::$_cache_get_one = [];
    [3481] =>     }
    [3482] => 
    [3483] =>     /**
    [3484] =>      * Reset all global caches associated with DataObject.
    [3485] =>      */
    [3486] =>     public static function reset()
    [3487] =>     {
    [3488] =>         // @todo Decouple these
    [3489] =>         DBEnum::flushCache();
    [3490] =>         ClassInfo::reset_db_cache();
    [3491] =>         static::getSchema()->reset();
    [3492] =>         self::$_cache_get_one = [];
    [3493] =>         self::$_cache_field_labels = [];
    [3494] =>     }
    [3495] => 
    [3496] =>     /**
    [3497] =>      * Return the given element, searching by ID.
    [3498] =>      *
    [3499] =>      * This can be called either via `DataObject::get_by_id(MyClass::class, $id)`
    [3500] =>      * or `MyClass::get_by_id($id)`
    [3501] =>      *
    [3502] =>      * The object returned is cached, unlike DataObject::get()->byID() {@link DataList::byID()}
    [3503] =>      *
    [3504] =>      * @param string|int $classOrID The class of the object to be returned, or id if called on target class
    [3505] =>      * @param int|bool $idOrCache The id of the element, or cache if called on target class
    [3506] =>      * @param boolean $cache See {@link get_one()}
    [3507] =>      *
    [3508] =>      * @return static|null The element
    [3509] =>      */
    [3510] =>     public static function get_by_id($classOrID, $idOrCache = null, $cache = true)
    [3511] =>     {
    [3512] =>         // Shift arguments if passing id in first or second argument
    [3513] =>         list ($class, $id, $cached) = is_numeric($classOrID)
    [3514] =>             ? [get_called_class(), (int) $classOrID, isset($idOrCache) ? $idOrCache : $cache]
    [3515] =>             : [$classOrID, (int) $idOrCache, $cache];
    [3516] =>         if ($id < 1) {
    [3517] =>             return null;
    [3518] =>         }
    [3519] => 
    [3520] =>         // Validate class
    [3521] =>         if ($class === self::class) {
    [3522] =>             throw new InvalidArgumentException('DataObject::get_by_id() cannot query non-subclass DataObject directly');
    [3523] =>         }
    [3524] => 
    [3525] =>         // Pass to get_one
    [3526] =>         $column = static::getSchema()->sqlColumnForField($class, 'ID');
    [3527] =>         return DataObject::get_one($class, [$column => $id], $cached);
    [3528] =>     }
    [3529] => 
    [3530] =>     /**
    [3531] =>      * Get the name of the base table for this object
    [3532] =>      *
    [3533] =>      * @return string
    [3534] =>      */
    [3535] =>     public function baseTable()
    [3536] =>     {
    [3537] =>         return static::getSchema()->baseDataTable($this);
    [3538] =>     }
    [3539] => 
    [3540] =>     /**
    [3541] =>      * Get the base class for this object
    [3542] =>      *
    [3543] =>      * @return string
    [3544] =>      */
    [3545] =>     public function baseClass()
    [3546] =>     {
    [3547] =>         return static::getSchema()->baseDataClass($this);
    [3548] =>     }
    [3549] => 
    [3550] =>     /**
    [3551] =>      * @var array Parameters used in the query that built this object.
    [3552] =>      * This can be used by decorators (e.g. lazy loading) to
    [3553] =>      * run additional queries using the same context.
    [3554] =>      */
    [3555] =>     protected $sourceQueryParams;
    [3556] => 
    [3557] =>     /**
    [3558] =>      * @see $sourceQueryParams
    [3559] =>      * @return array
    [3560] =>      */
    [3561] =>     public function getSourceQueryParams()
    [3562] =>     {
    [3563] =>         return $this->sourceQueryParams;
    [3564] =>     }
    [3565] => 
    [3566] =>     /**
    [3567] =>      * Get list of parameters that should be inherited to relations on this object
    [3568] =>      *
    [3569] =>      * @return array
    [3570] =>      */
    [3571] =>     public function getInheritableQueryParams()
    [3572] =>     {
    [3573] =>         $params = $this->getSourceQueryParams();
    [3574] =>         $this->extend('updateInheritableQueryParams', $params);
    [3575] =>         return $params;
    [3576] =>     }
    [3577] => 
    [3578] =>     /**
    [3579] =>      * @see $sourceQueryParams
    [3580] =>      * @param array $array
    [3581] =>      */
    [3582] =>     public function setSourceQueryParams($array)
    [3583] =>     {
    [3584] =>         $this->sourceQueryParams = $array;
    [3585] =>     }
    [3586] => 
    [3587] =>     /**
    [3588] =>      * @see $sourceQueryParams
    [3589] =>      * @param string $key
    [3590] =>      * @param string $value
    [3591] =>      */
    [3592] =>     public function setSourceQueryParam($key, $value)
    [3593] =>     {
    [3594] =>         $this->sourceQueryParams[$key] = $value;
    [3595] =>     }
    [3596] => 
    [3597] =>     /**
    [3598] =>      * @see $sourceQueryParams
    [3599] =>      * @param string $key
    [3600] =>      * @return string
    [3601] =>      */
    [3602] =>     public function getSourceQueryParam($key)
    [3603] =>     {
    [3604] =>         if (isset($this->sourceQueryParams[$key])) {
    [3605] =>             return $this->sourceQueryParams[$key];
    [3606] =>         }
    [3607] =>         return null;
    [3608] =>     }
    [3609] => 
    [3610] =>     //-------------------------------------------------------------------------------------------//
    [3611] => 
    [3612] =>     /**
    [3613] =>      * Check the database schema and update it as necessary.
    [3614] =>      *
    [3615] =>      * @uses DataExtension::augmentDatabase()
    [3616] =>      */
    [3617] =>     public function requireTable()
    [3618] =>     {
    [3619] =>         // Only build the table if we've actually got fields
    [3620] =>         $schema = static::getSchema();
    [3621] =>         $table = $schema->tableName(static::class);
    [3622] =>         $fields = $schema->databaseFields(static::class, false);
    [3623] =>         $indexes = $schema->databaseIndexes(static::class, false);
    [3624] =>         $extensions = self::database_extensions(static::class);
    [3625] => 
    [3626] =>         if (empty($table)) {
    [3627] =>             throw new LogicException(
    [3628] =>                 "Class " . static::class . " not loaded by manifest, or no database table configured"
    [3629] =>             );
    [3630] =>         }
    [3631] => 
    [3632] =>         if ($fields) {
    [3633] =>             $hasAutoIncPK = get_parent_class($this ?? '') === self::class;
    [3634] =>             DB::require_table(
    [3635] =>                 $table,
    [3636] =>                 $fields,
    [3637] =>                 $indexes,
    [3638] =>                 $hasAutoIncPK,
    [3639] =>                 $this->config()->get('create_table_options'),
    [3640] =>                 $extensions
    [3641] =>             );
    [3642] =>         } else {
    [3643] =>             DB::dont_require_table($table);
    [3644] =>         }
    [3645] => 
    [3646] =>         // Build any child tables for many_many items
    [3647] =>         if ($manyMany = $this->uninherited('many_many')) {
    [3648] =>             $extras = $this->uninherited('many_many_extraFields');
    [3649] =>             foreach ($manyMany as $component => $spec) {
    [3650] =>                 // Get many_many spec
    [3651] =>                 $manyManyComponent = $schema->manyManyComponent(static::class, $component);
    [3652] =>                 $parentField = $manyManyComponent['parentField'];
    [3653] =>                 $childField = $manyManyComponent['childField'];
    [3654] =>                 $tableOrClass = $manyManyComponent['join'];
    [3655] => 
    [3656] =>                 // Skip if backed by actual class
    [3657] =>                 if (class_exists($tableOrClass ?? '')) {
    [3658] =>                     continue;
    [3659] =>                 }
    [3660] => 
    [3661] =>                 // Build fields
    [3662] =>                 $manymanyFields = [
    [3663] =>                     $parentField => "Int",
    [3664] =>                     $childField => "Int",
    [3665] =>                 ];
    [3666] =>                 if (isset($extras[$component])) {
    [3667] =>                     $manymanyFields = array_merge($manymanyFields, $extras[$component]);
    [3668] =>                 }
    [3669] => 
    [3670] =>                 // Build index list
    [3671] =>                 $manymanyIndexes = [
    [3672] =>                     $parentField => [
    [3673] =>                         'type' => 'index',
    [3674] =>                         'name' => $parentField,
    [3675] =>                         'columns' => [$parentField],
    [3676] =>                     ],
    [3677] =>                     $childField => [
    [3678] =>                         'type' => 'index',
    [3679] =>                         'name' => $childField,
    [3680] =>                         'columns' => [$childField],
    [3681] =>                     ],
    [3682] =>                 ];
    [3683] =>                 DB::require_table($tableOrClass, $manymanyFields, $manymanyIndexes, true, null, $extensions);
    [3684] =>             }
    [3685] =>         }
    [3686] => 
    [3687] =>         // Let any extensions make their own database fields
    [3688] =>         $this->extend('augmentDatabase', $dummy);
    [3689] =>     }
    [3690] => 
    [3691] =>     /**
    [3692] =>      * Add default records to database. This function is called whenever the
    [3693] =>      * database is built, after the database tables have all been created. Overload
    [3694] =>      * this to add default records when the database is built, but make sure you
    [3695] =>      * call parent::requireDefaultRecords().
    [3696] =>      *
    [3697] =>      * @uses DataExtension::requireDefaultRecords()
    [3698] =>      */
    [3699] =>     public function requireDefaultRecords()
    [3700] =>     {
    [3701] =>         $defaultRecords = $this->config()->uninherited('default_records');
    [3702] => 
    [3703] =>         if (!empty($defaultRecords)) {
    [3704] =>             $hasData = DataObject::get_one(static::class);
    [3705] =>             if (!$hasData) {
    [3706] =>                 $className = static::class;
    [3707] =>                 foreach ($defaultRecords as $record) {
    [3708] =>                     $obj = Injector::inst()->create($className, $record);
    [3709] =>                     $obj->write();
    [3710] =>                 }
    [3711] =>                 DB::alteration_message("Added default records to $className table", "created");
    [3712] =>             }
    [3713] =>         }
    [3714] => 
    [3715] =>         // Let any extensions make their own database default data
    [3716] =>         $this->extend('requireDefaultRecords', $dummy);
    [3717] =>     }
    [3718] => 
    [3719] =>     /**
    [3720] =>      * Invoked after every database build is complete (including after table creation and
    [3721] =>      * default record population).
    [3722] =>      *
    [3723] =>      * See {@link DatabaseAdmin::doBuild()} for context.
    [3724] =>      */
    [3725] =>     public function onAfterBuild()
    [3726] =>     {
    [3727] =>         $this->extend('onAfterBuild');
    [3728] =>     }
    [3729] => 
    [3730] =>     private function getDatabaseBackedField(string $fieldPath): ?string
    [3731] =>     {
    [3732] =>         $component = $this;
    [3733] =>         $fieldParts = [];
    [3734] =>         $parts = explode('.', $fieldPath ?? '');
    [3735] => 
    [3736] =>         foreach ($parts as $nextPart) {
    [3737] =>             if (!$component) {
    [3738] =>                 return null;
    [3739] =>             }
    [3740] =>             $fieldParts[] = $nextPart;
    [3741] => 
    [3742] =>             if ($component instanceof Relation || $component instanceof DataList) {
    [3743] =>                 if ($component->hasMethod($nextPart)) {
    [3744] =>                     // If the next part is a method, we don't have a database-backed field.
    [3745] =>                     return null;
    [3746] =>                 }
    [3747] =>                 // The next part could either be a field, or another relation
    [3748] =>                 $singleton = DataObject::singleton($component->dataClass());
    [3749] =>                 if ($singleton->dbObject($nextPart) instanceof DBField) {
    [3750] =>                     // If the next part is a DBField, we've found the database-backed field.
    [3751] =>                     break;
    [3752] =>                 }
    [3753] =>                 $component = $component->relation($nextPart);
    [3754] =>                 array_shift($parts);
    [3755] =>             } elseif ($component instanceof DataObject && ($component->dbObject($nextPart) instanceof DBField)) {
    [3756] =>                 // If the next part is a DBField, we've found the database-backed field.
    [3757] =>                 break;
    [3758] =>             } elseif ($component instanceof DataObject && $component->getRelationType($nextPart) !== null) {
    [3759] =>                 // If it's a last part or only one elemnt of a relation, we don't have a database-backed field.
    [3760] =>                 if (count($parts) === 1) {
    [3761] =>                     return null;
    [3762] =>                 }
    [3763] =>                 $component = $component->$nextPart();
    [3764] =>                 array_shift($parts);
    [3765] =>             } elseif (ClassInfo::hasMethod($component, $nextPart)) {
    [3766] =>                 // If the next part is a method, we don't have a database-backed field.
    [3767] =>                 return null;
    [3768] =>             } else {
    [3769] =>                 return null;
    [3770] =>             }
    [3771] =>         }
    [3772] => 
    [3773] =>         return implode('.', $fieldParts) ?: null;
    [3774] =>     }
    [3775] => 
    [3776] =>     /**
    [3777] =>      * Get the default searchable fields for this object, as defined in the
    [3778] =>      * $searchable_fields list. If searchable fields are not defined on the
    [3779] =>      * data object, uses a default selection of summary fields.
    [3780] =>      *
    [3781] =>      * @return array
    [3782] =>      */
    [3783] =>     public function searchableFields()
    [3784] =>     {
    [3785] =>         // can have mixed format, need to make consistent in most verbose form
    [3786] =>         $fields = $this->config()->get('searchable_fields');
    [3787] =>         $labels = $this->fieldLabels();
    [3788] => 
    [3789] =>         // fallback to summary fields (unless empty array is explicitly specified)
    [3790] =>         if (!$fields && !is_array($fields)) {
    [3791] =>             $summaryFields = array_keys($this->summaryFields() ?? []);
    [3792] =>             $fields = [];
    [3793] => 
    [3794] =>             if ($summaryFields) {
    [3795] =>                 foreach ($summaryFields as $name) {
    [3796] =>                     if ($field = $this->getDatabaseBackedField($name)) {
    [3797] =>                         $fields[] = $field;
    [3798] =>                     }
    [3799] =>                 }
    [3800] =>             }
    [3801] =>         }
    [3802] => 
    [3803] =>         // we need to make sure the format is unified before
    [3804] =>         // augmenting fields, so extensions can apply consistent checks
    [3805] =>         // but also after augmenting fields, because the extension
    [3806] =>         // might use the shorthand notation as well
    [3807] => 
    [3808] =>         // rewrite array, if it is using shorthand syntax
    [3809] =>         $rewrite = [];
    [3810] =>         foreach ($fields as $name => $specOrName) {
    [3811] =>             $identifier = (is_int($name)) ? $specOrName : $name;
    [3812] => 
    [3813] =>             if (is_int($name)) {
    [3814] =>                 // Format: array('MyFieldName')
    [3815] =>                 $rewrite[$identifier] = [];
    [3816] =>             } elseif (is_array($specOrName) && (isset($specOrName['match_any']))) {
    [3817] =>                 $rewrite[$identifier] = $fields[$identifier];
    [3818] =>                 $rewrite[$identifier]['match_any'] = $specOrName['match_any'];
    [3819] =>             } elseif (is_array($specOrName) && ($relObject = $this->relObject($identifier))) {
    [3820] =>                 // Format: array('MyFieldName' => array(
    [3821] =>                 //   'filter => 'ExactMatchFilter',
    [3822] =>                 //   'field' => 'NumericField', // optional
    [3823] =>                 //   'title' => 'My Title', // optional
    [3824] =>                 // ))
    [3825] =>                 $rewrite[$identifier] = array_merge(
    [3826] =>                     ['filter' => $relObject->config()->get('default_search_filter_class')],
    [3827] =>                     (array)$specOrName
    [3828] =>                 );
    [3829] =>             } else {
    [3830] =>                 // Format: array('MyFieldName' => 'ExactMatchFilter')
    [3831] =>                 $rewrite[$identifier] = [
    [3832] =>                     'filter' => $specOrName,
    [3833] =>                 ];
    [3834] =>             }
    [3835] =>             if (!isset($rewrite[$identifier]['title'])) {
    [3836] =>                 $rewrite[$identifier]['title'] = (isset($labels[$identifier]))
    [3837] =>                     ? $labels[$identifier] : FormField::name_to_label($identifier);
    [3838] =>             }
    [3839] =>             if (!isset($rewrite[$identifier]['filter'])) {
    [3840] =>                 /** @skipUpgrade */
    [3841] =>                 $rewrite[$identifier]['filter'] = 'PartialMatchFilter';
    [3842] =>             }
    [3843] =>         }
    [3844] => 
    [3845] =>         $fields = $rewrite;
    [3846] => 
    [3847] =>         // apply DataExtensions if present
    [3848] =>         $this->extend('updateSearchableFields', $fields);
    [3849] => 
    [3850] =>         return $fields;
    [3851] =>     }
    [3852] => 
    [3853] =>     /**
    [3854] =>      * Get any user defined searchable fields labels that
    [3855] =>      * exist. Allows overriding of default field names in the form
    [3856] =>      * interface actually presented to the user.
    [3857] =>      *
    [3858] =>      * The reason for keeping this separate from searchable_fields,
    [3859] =>      * which would be a logical place for this functionality, is to
    [3860] =>      * avoid bloating and complicating the configuration array. Currently
    [3861] =>      * much of this system is based on sensible defaults, and this property
    [3862] =>      * would generally only be set in the case of more complex relationships
    [3863] =>      * between data object being required in the search interface.
    [3864] =>      *
    [3865] =>      * Generates labels based on name of the field itself, if no static property
    [3866] =>      * {@link self::field_labels} exists.
    [3867] =>      *
    [3868] =>      * @uses $field_labels
    [3869] =>      * @uses FormField::name_to_label()
    [3870] =>      *
    [3871] =>      * @param boolean $includerelations a boolean value to indicate if the labels returned include relation fields
    [3872] =>      *
    [3873] =>      * @return array Array of all element labels
    [3874] =>      */
    [3875] =>     public function fieldLabels($includerelations = true)
    [3876] =>     {
    [3877] =>         $cacheKey = static::class . '_' . $includerelations;
    [3878] => 
    [3879] =>         if (!isset(self::$_cache_field_labels[$cacheKey])) {
    [3880] =>             $customLabels = $this->config()->get('field_labels');
    [3881] =>             $autoLabels = [];
    [3882] => 
    [3883] =>             // get all translated static properties as defined in i18nCollectStatics()
    [3884] =>             $ancestry = ClassInfo::ancestry(static::class);
    [3885] =>             $ancestry = array_reverse($ancestry ?? []);
    [3886] =>             if ($ancestry) {
    [3887] =>                 foreach ($ancestry as $ancestorClass) {
    [3888] =>                     if ($ancestorClass === ViewableData::class) {
    [3889] =>                         break;
    [3890] =>                     }
    [3891] =>                     $types = [
    [3892] =>                         'db' => (array)Config::inst()->get($ancestorClass, 'db', Config::UNINHERITED)
    [3893] =>                     ];
    [3894] =>                     if ($includerelations) {
    [3895] =>                         $types['has_one'] = (array)Config::inst()->get($ancestorClass, 'has_one', Config::UNINHERITED);
    [3896] =>                         $types['has_many'] = (array)Config::inst()->get(
    [3897] =>                             $ancestorClass,
    [3898] =>                             'has_many',
    [3899] =>                             Config::UNINHERITED
    [3900] =>                         );
    [3901] =>                         $types['many_many'] = (array)Config::inst()->get(
    [3902] =>                             $ancestorClass,
    [3903] =>                             'many_many',
    [3904] =>                             Config::UNINHERITED
    [3905] =>                         );
    [3906] =>                         $types['belongs_many_many'] = (array)Config::inst()->get(
    [3907] =>                             $ancestorClass,
    [3908] =>                             'belongs_many_many',
    [3909] =>                             Config::UNINHERITED
    [3910] =>                         );
    [3911] =>                     }
    [3912] =>                     foreach ($types as $type => $attrs) {
    [3913] =>                         foreach ($attrs as $name => $spec) {
    [3914] =>                             $autoLabels[$name] = _t(
    [3915] =>                                 "{$ancestorClass}.{$type}_{$name}",
    [3916] =>                                 FormField::name_to_label($name)
    [3917] =>                             );
    [3918] =>                         }
    [3919] =>                     }
    [3920] =>                 }
    [3921] =>             }
    [3922] => 
    [3923] =>             $labels = array_merge((array)$autoLabels, (array)$customLabels);
    [3924] =>             $this->extend('updateFieldLabels', $labels);
    [3925] =>             self::$_cache_field_labels[$cacheKey] = $labels;
    [3926] =>         }
    [3927] => 
    [3928] =>         return self::$_cache_field_labels[$cacheKey];
    [3929] =>     }
    [3930] => 
    [3931] =>     /**
    [3932] =>      * Get a human-readable label for a single field,
    [3933] =>      * see {@link fieldLabels()} for more details.
    [3934] =>      *
    [3935] =>      * @uses fieldLabels()
    [3936] =>      * @uses FormField::name_to_label()
    [3937] =>      *
    [3938] =>      * @param string $name Name of the field
    [3939] =>      * @return string Label of the field
    [3940] =>      */
    [3941] =>     public function fieldLabel($name)
    [3942] =>     {
    [3943] =>         $labels = $this->fieldLabels();
    [3944] =>         return (isset($labels[$name])) ? $labels[$name] : FormField::name_to_label($name);
    [3945] =>     }
    [3946] => 
    [3947] =>     /**
    [3948] =>      * Get the default summary fields for this object.
    [3949] =>      *
    [3950] =>      * @todo use the translation apparatus to return a default field selection for the language
    [3951] =>      *
    [3952] =>      * @return array
    [3953] =>      */
    [3954] =>     public function summaryFields()
    [3955] =>     {
    [3956] =>         $rawFields = $this->config()->get('summary_fields');
    [3957] => 
    [3958] =>         // Merge associative / numeric keys
    [3959] =>         $fields = [];
    [3960] =>         foreach ($rawFields as $key => $value) {
    [3961] =>             if (is_int($key)) {
    [3962] =>                 $key = $value;
    [3963] =>             }
    [3964] =>             $fields[$key] = $value;
    [3965] =>         }
    [3966] => 
    [3967] =>         if (!$fields) {
    [3968] =>             $fields = [];
    [3969] =>             // try to scaffold a couple of usual suspects
    [3970] =>             if ($this->hasField('Name')) {
    [3971] =>                 $fields['Name'] = 'Name';
    [3972] =>             }
    [3973] =>             if (static::getSchema()->fieldSpec($this, 'Title')) {
    [3974] =>                 $fields['Title'] = 'Title';
    [3975] =>             }
    [3976] =>             if ($this->hasField('Description')) {
    [3977] =>                 $fields['Description'] = 'Description';
    [3978] =>             }
    [3979] =>             if ($this->hasField('FirstName')) {
    [3980] =>                 $fields['FirstName'] = 'First Name';
    [3981] =>             }
    [3982] =>         }
    [3983] =>         $this->extend("updateSummaryFields", $fields);
    [3984] => 
    [3985] =>         // Final fail-over, just list ID field
    [3986] =>         if (!$fields) {
    [3987] =>             $fields['ID'] = 'ID';
    [3988] =>         }
    [3989] => 
    [3990] =>         // Localize fields (if possible)
    [3991] =>         foreach ($this->fieldLabels(false) as $name => $label) {
    [3992] =>             // only attempt to localize if the label definition is the same as the field name.
    [3993] =>             // this will preserve any custom labels set in the summary_fields configuration
    [3994] =>             if (isset($fields[$name]) && $name === $fields[$name]) {
    [3995] =>                 $fields[$name] = $label;
    [3996] =>             }
    [3997] =>         }
    [3998] => 
    [3999] =>         return $fields;
    [4000] =>     }
    [4001] => 
    [4002] =>     /**
    [4003] =>      * Defines a default list of filters for the search context.
    [4004] =>      *
    [4005] =>      * If a filter class mapping is defined on the data object,
    [4006] =>      * it is constructed here. Otherwise, the default filter specified in
    [4007] =>      * {@link DBField} is used.
    [4008] =>      *
    [4009] =>      * @todo error handling/type checking for valid FormField and SearchFilter subclasses?
    [4010] =>      *
    [4011] =>      * @return array
    [4012] =>      */
    [4013] =>     public function defaultSearchFilters()
    [4014] =>     {
    [4015] =>         $filters = [];
    [4016] => 
    [4017] =>         foreach ($this->searchableFields() as $name => $spec) {
    [4018] =>             if (empty($spec['filter'])) {
    [4019] =>                 /** @skipUpgrade */
    [4020] =>                 $filters[$name] = 'PartialMatchFilter';
    [4021] =>             } elseif ($spec['filter'] instanceof SearchFilter) {
    [4022] =>                 $filters[$name] = $spec['filter'];
    [4023] =>             } else {
    [4024] =>                 $filters[$name] = Injector::inst()->create($spec['filter'], $name);
    [4025] =>             }
    [4026] =>         }
    [4027] => 
    [4028] =>         return $filters;
    [4029] =>     }
    [4030] => 
    [4031] =>     /**
    [4032] =>      * @return boolean True if the object is in the database
    [4033] =>      */
    [4034] =>     public function isInDB()
    [4035] =>     {
    [4036] =>         return is_numeric($this->ID) && $this->ID > 0;
    [4037] =>     }
    [4038] => 
    [4039] =>     /*
    [4040] =>      * @ignore
    [4041] =>      */
    [4042] =>     private static $subclass_access = true;
    [4043] => 
    [4044] =>     /**
    [4045] =>      * Temporarily disable subclass access in data object qeur
    [4046] =>      */
    [4047] =>     public static function disable_subclass_access()
    [4048] =>     {
    [4049] =>         self::$subclass_access = false;
    [4050] =>     }
    [4051] => 
    [4052] =>     public static function enable_subclass_access()
    [4053] =>     {
    [4054] =>         self::$subclass_access = true;
    [4055] =>     }
    [4056] => 
    [4057] =>     //-------------------------------------------------------------------------------------------//
    [4058] => 
    [4059] =>     /**
    [4060] =>      * Database field definitions.
    [4061] =>      * This is a map from field names to field type. The field
    [4062] =>      * type should be a class that extends .
    [4063] =>      * @var array
    [4064] =>      * @config
    [4065] =>      */
    [4066] =>     private static $db = [];
    [4067] => 
    [4068] =>     /**
    [4069] =>      * Use a casting object for a field. This is a map from
    [4070] =>      * field name to class name of the casting object.
    [4071] =>      *
    [4072] =>      * @var array
    [4073] =>      */
    [4074] =>     private static $casting = [
    [4075] =>         "Title" => 'Text',
    [4076] =>     ];
    [4077] => 
    [4078] =>     /**
    [4079] =>      * Specify custom options for a CREATE TABLE call.
    [4080] =>      * Can be used to specify a custom storage engine for specific database table.
    [4081] =>      * All options have to be keyed for a specific database implementation,
    [4082] =>      * identified by their class name (extending from {@link SS_Database}).
    [4083] =>      *
    [4084] =>      * <code>
    [4085] =>      * private static $create_table_options = [
    [4086] =>      *     MySQLSchemaManager::ID => 'ENGINE=MyISAM',
    [4087] =>      * ];
    [4088] =>      * </code>
    [4089] =>      *
    [4090] =>      * Caution: This API is experimental, and might not be
    [4091] =>      * included in the next major release. Please use with care.
    [4092] =>      *
    [4093] =>      * @var array
    [4094] =>      * @config
    [4095] =>      */
    [4096] =>     private static $create_table_options = [
    [4097] =>         MySQLSchemaManager::ID => 'ENGINE=InnoDB'
    [4098] =>     ];
    [4099] => 
    [4100] =>     /**
    [4101] =>      * If a field is in this array, then create a database index
    [4102] =>      * on that field. This is a map from fieldname to index type.
    [4103] =>      * See {@link SS_Database->requireIndex()} and custom subclasses for details on the array notation.
    [4104] =>      *
    [4105] =>      * @var array
    [4106] =>      * @config
    [4107] =>      */
    [4108] =>     private static $indexes = null;
    [4109] => 
    [4110] =>     /**
    [4111] =>      * Inserts standard column-values when a DataObject
    [4112] =>      * is instantiated. Does not insert default records {@see $default_records}.
    [4113] =>      * This is a map from fieldname to default value.
    [4114] =>      *
    [4115] =>      *  - If you would like to change a default value in a sub-class, just specify it.
    [4116] =>      *  - If you would like to disable the default value given by a parent class, set the default value to 0,'',
    [4117] =>      *    or false in your subclass.  Setting it to null won't work.
    [4118] =>      *
    [4119] =>      * @var array
    [4120] =>      * @config
    [4121] =>      */
    [4122] =>     private static $defaults = [];
    [4123] => 
    [4124] =>     /**
    [4125] =>      * Multidimensional array which inserts default data into the database
    [4126] =>      * on a db/build-call as long as the database-table is empty. Please use this only
    [4127] =>      * for simple constructs, not for SiteTree-Objects etc. which need special
    [4128] =>      * behaviour such as publishing and ParentNodes.
    [4129] =>      *
    [4130] =>      * Example:
    [4131] =>      * <code>
    [4132] =>      * private static $default_records = [
    [4133] =>      *     [ 'Title' => 'DefaultPage1', 'PageTitle' => 'page1' ],
    [4134] =>      *     [ 'Title' => 'DefaultPage2' ],
    [4135] =>      * ];
    [4136] =>      * </code>
    [4137] =>      *
    [4138] =>      * @var array
    [4139] =>      * @config
    [4140] =>      */
    [4141] =>     private static $default_records = null;
    [4142] => 
    [4143] =>     /**
    [4144] =>      * One-to-zero relationship definition. This is a map of component name to data type. In order to turn this into a
    [4145] =>      * true one-to-one relationship you can add a {@link DataObject::$belongs_to} relationship on the child class.
    [4146] =>      *
    [4147] =>      * Note that you cannot have a has_one and belongs_to relationship with the same name.
    [4148] =>      *
    [4149] =>      * @var array
    [4150] =>      * @config
    [4151] =>      */
    [4152] =>     private static $has_one = [];
    [4153] => 
    [4154] =>     /**
    [4155] =>      * A meta-relationship that allows you to define the reverse side of a {@link DataObject::$has_one}.
    [4156] =>      *
    [4157] =>      * This does not actually create any data structures, but allows you to query the other object in a one-to-one
    [4158] =>      * relationship from the child object. If you have multiple belongs_to links to another object you can use the
    [4159] =>      * syntax "ClassName.HasOneName" to specify which foreign has_one key on the other object to use.
    [4160] =>      *
    [4161] =>      * Note that you cannot have a has_one and belongs_to relationship with the same name.
    [4162] =>      *
    [4163] =>      * @var array
    [4164] =>      * @config
    [4165] =>      */
    [4166] =>     private static $belongs_to = [];
    [4167] => 
    [4168] =>     /**
    [4169] =>      * This defines a one-to-many relationship. It is a map of component name to the remote data class.
    [4170] =>      *
    [4171] =>      * This relationship type does not actually create a data structure itself - you need to define a matching $has_one
    [4172] =>      * relationship on the child class. Also, if the $has_one relationship on the child class has multiple links to this
    [4173] =>      * class you can use the syntax "ClassName.HasOneRelationshipName" in the remote data class definition to show
    [4174] =>      * which foreign key to use.
    [4175] =>      *
    [4176] =>      * @var array
    [4177] =>      * @config
    [4178] =>      */
    [4179] =>     private static $has_many = [];
    [4180] => 
    [4181] =>     /**
    [4182] =>      * many-many relationship definitions.
    [4183] =>      * This is a map from component name to data type.
    [4184] =>      * @var array
    [4185] =>      * @config
    [4186] =>      */
    [4187] =>     private static $many_many = [];
    [4188] => 
    [4189] =>     /**
    [4190] =>      * Extra fields to include on the connecting many-many table.
    [4191] =>      * This is a map from field name to field type.
    [4192] =>      *
    [4193] =>      * Example code:
    [4194] =>      * <code>
    [4195] =>      * private static $many_many_extraFields = [
    [4196] =>      *     'Members' => [
    [4197] =>      *         'Role' => 'Varchar(100)',
    [4198] =>      *     ],
    [4199] =>      * ];
    [4200] =>      * </code>
    [4201] =>      *
    [4202] =>      * @var array
    [4203] =>      * @config
    [4204] =>      */
    [4205] =>     private static $many_many_extraFields = [];
    [4206] => 
    [4207] =>     /**
    [4208] =>      * The inverse side of a many-many relationship.
    [4209] =>      * This is a map from component name to data type.
    [4210] =>      * @var array
    [4211] =>      * @config
    [4212] =>      */
    [4213] =>     private static $belongs_many_many = [];
    [4214] => 
    [4215] =>     /**
    [4216] =>      * The default sort expression. This will be inserted in the ORDER BY
    [4217] =>      * clause of a SQL query if no other sort expression is provided.
    [4218] =>      * @var string
    [4219] =>      * @config
    [4220] =>      */
    [4221] =>     private static $default_sort = null;
    [4222] => 
    [4223] =>     /**
    [4224] =>      * Default list of fields that can be scaffolded by the ModelAdmin
    [4225] =>      * search interface.
    [4226] =>      *
    [4227] =>      * Overriding the default filter, with a custom defined filter:
    [4228] =>      * <code>
    [4229] =>      * private static $searchable_fields = [
    [4230] =>      *     'Name' => 'PartialMatchFilter',
    [4231] =>      * ];
    [4232] =>      * </code>
    [4233] =>      *
    [4234] =>      * Overriding the default form fields, with a custom defined field.
    [4235] =>      * The 'filter' parameter will be generated from {@link DBField::$default_search_filter_class}.
    [4236] =>      * The 'title' parameter will be generated from {@link DataObject->fieldLabels()}.
    [4237] =>      * <code>
    [4238] =>      * private static $searchable_fields = [
    [4239] =>      *     'Name' => [
    [4240] =>      *         'field' => 'TextField',
    [4241] =>      *     ],
    [4242] =>      * ];
    [4243] =>      * </code>
    [4244] =>      *
    [4245] =>      * Overriding the default form field, filter and title:
    [4246] =>      * <code>
    [4247] =>      * private static $searchable_fields = [
    [4248] =>      *     'Organisation.ZipCode' => [
    [4249] =>      *         'field' => 'TextField',
    [4250] =>      *         'filter' => 'PartialMatchFilter',
    [4251] =>      *         'title' => 'Organisation ZIP',
    [4252] =>      *     ],
    [4253] =>      * ];
    [4254] =>      * </code>
    [4255] =>      * @config
    [4256] =>      * @var array
    [4257] =>      */
    [4258] =>     private static $searchable_fields = null;
    [4259] => 
    [4260] =>     /**
    [4261] =>      * Name of the field which is used as a stand-in for searching across all searchable fields.
    [4262] =>      *
    [4263] =>      * If this is a blank string, general search functionality is disabled
    [4264] =>      * and the general search field falls back to using the first field in
    [4265] =>      * the searchable_fields array.
    [4266] =>      */
    [4267] =>     private static string $general_search_field_name = 'q';
    [4268] => 
    [4269] =>     /**
    [4270] =>      * The search filter to use when searching with the general search field.
    [4271] =>      * If this is an empty string, the search filters configured for each field are used instead.
    [4272] =>      */
    [4273] =>     private static string $general_search_field_filter = PartialMatchFilter::class;
    [4274] => 
    [4275] =>     /**
    [4276] =>      * If true, the search phrase is split into individual terms, and checks all searchable fields for each search term.
    [4277] =>      * If false, all fields are checked for the entire search phrase as a whole.
    [4278] =>      *
    [4279] =>      * Note that splitting terms may cause unexpected resuls if using an ExactMatchFilter.
    [4280] =>      */
    [4281] =>     private static bool $general_search_split_terms = true;
    [4282] => 
    [4283] =>     /**
    [4284] =>      * User defined labels for searchable_fields, used to override
    [4285] =>      * default display in the search form.
    [4286] =>      * @config
    [4287] =>      * @var array
    [4288] =>      */
    [4289] =>     private static $field_labels = [];
    [4290] => 
    [4291] =>     /**
    [4292] =>      * Provides a default list of fields to be used by a 'summary'
    [4293] =>      * view of this object.
    [4294] =>      * @config
    [4295] =>      * @var array
    [4296] =>      */
    [4297] =>     private static $summary_fields = [];
    [4298] => 
    [4299] =>     public function provideI18nEntities()
    [4300] =>     {
    [4301] =>         // Note: see http://guides.rubyonrails.org/i18n.html#pluralization for rules
    [4302] =>         // Best guess for a/an rule. Better guesses require overriding in subclasses
    [4303] =>         $pluralName = $this->plural_name();
    [4304] =>         $singularName = $this->singular_name();
    [4305] =>         $conjunction = preg_match('/^[aeiou]/i', $singularName ?? '') ? 'An ' : 'A ';
    [4306] =>         return [
    [4307] =>             static::class . '.SINGULARNAME' => $this->singular_name(),
    [4308] =>             static::class . '.PLURALNAME' => $pluralName,
    [4309] =>             static::class . '.PLURALS' => [
    [4310] =>                 'one' => $conjunction . $singularName,
    [4311] =>                 'other' => '{count} ' . $pluralName
    [4312] =>             ]
    [4313] =>         ];
    [4314] =>     }
    [4315] => 
    [4316] =>     /**
    [4317] =>      * Returns true if the given method/parameter has a value
    [4318] =>      * (Uses the DBField::hasValue if the parameter is a database field)
    [4319] =>      *
    [4320] =>      * @param string $field The field name
    [4321] =>      * @param array $arguments
    [4322] =>      * @param bool $cache
    [4323] =>      * @return boolean
    [4324] =>      */
    [4325] =>     public function hasValue($field, $arguments = null, $cache = true)
    [4326] =>     {
    [4327] =>         // has_one fields should not use dbObject to check if a value is given
    [4328] =>         $hasOne = static::getSchema()->hasOneComponent(static::class, $field);
    [4329] =>         if (!$hasOne && ($obj = $this->dbObject($field))) {
    [4330] =>             return $obj->exists();
    [4331] =>         } else {
    [4332] =>             return parent::hasValue($field, $arguments, $cache);
    [4333] =>         }
    [4334] =>     }
    [4335] => 
    [4336] =>     /**
    [4337] =>      * If selected through a many_many through relation, this is the instance of the joined record
    [4338] =>      *
    [4339] =>      * @return DataObject
    [4340] =>      */
    [4341] =>     public function getJoin()
    [4342] =>     {
    [4343] =>         return $this->joinRecord;
    [4344] =>     }
    [4345] => 
    [4346] =>     /**
    [4347] =>      * Set joining object
    [4348] =>      *
    [4349] =>      * @param DataObject $object
    [4350] =>      * @param string $alias Alias
    [4351] =>      * @return $this
    [4352] =>      */
    [4353] =>     public function setJoin(DataObject $object, $alias = null)
    [4354] =>     {
    [4355] =>         $this->joinRecord = $object;
    [4356] =>         if ($alias) {
    [4357] =>             if (static::getSchema()->fieldSpec(static::class, $alias)) {
    [4358] =>                 throw new InvalidArgumentException(
    [4359] =>                     "Joined record $alias cannot also be a db field"
    [4360] =>                 );
    [4361] =>             }
    [4362] =>             $this->record[$alias] = $object;
    [4363] =>         }
    [4364] =>         return $this;
    [4365] =>     }
    [4366] => 
    [4367] =>     /**
    [4368] =>      * Find objects in the given relationships, merging them into the given list
    [4369] =>      *
    [4370] =>      * @param string $source Config property to extract relationships from
    [4371] =>      * @param bool $recursive True if recursive
    [4372] =>      * @param ArrayList $list If specified, items will be added to this list. If not, a new
    [4373] =>      * instance of ArrayList will be constructed and returned
    [4374] =>      * @return ArrayList The list of related objects
    [4375] =>      */
    [4376] =>     public function findRelatedObjects($source, $recursive = true, $list = null)
    [4377] =>     {
    [4378] =>         if (!$list) {
    [4379] =>             $list = new ArrayList();
    [4380] =>         }
    [4381] => 
    [4382] =>         // Skip search for unsaved records
    [4383] =>         if (!$this->isInDB()) {
    [4384] =>             return $list;
    [4385] =>         }
    [4386] => 
    [4387] =>         $relationships = $this->config()->get($source) ?: [];
    [4388] =>         foreach ($relationships as $relationship) {
    [4389] =>             // Warn if invalid config
    [4390] =>             if (!$this->hasMethod($relationship)) {
    [4391] =>                 trigger_error(sprintf(
    [4392] =>                     "Invalid %s config value \"%s\" on object on class \"%s\"",
    [4393] =>                     $source,
    [4394] =>                     $relationship,
    [4395] =>                     get_class($this)
    [4396] =>                 ), E_USER_WARNING);
    [4397] =>                 continue;
    [4398] =>             }
    [4399] => 
    [4400] =>             // Inspect value of this relationship
    [4401] =>             $items = $this->{$relationship}();
    [4402] => 
    [4403] =>             // Merge any new item
    [4404] =>             $newItems = $this->mergeRelatedObjects($list, $items);
    [4405] => 
    [4406] =>             // Recurse if necessary
    [4407] =>             if ($recursive) {
    [4408] =>                 foreach ($newItems as $item) {
    [4409] =>                     /** @var DataObject $item */
    [4410] =>                     $item->findRelatedObjects($source, true, $list);
    [4411] =>                 }
    [4412] =>             }
    [4413] =>         }
    [4414] =>         return $list;
    [4415] =>     }
    [4416] => 
    [4417] =>     /**
    [4418] =>      * Helper method to merge owned/owning items into a list.
    [4419] =>      * Items already present in the list will be skipped.
    [4420] =>      *
    [4421] =>      * @param ArrayList $list Items to merge into
    [4422] =>      * @param mixed $items List of new items to merge
    [4423] =>      * @return ArrayList List of all newly added items that did not already exist in $list
    [4424] =>      */
    [4425] =>     public function mergeRelatedObjects($list, $items)
    [4426] =>     {
    [4427] =>         $added = new ArrayList();
    [4428] =>         if (!$items) {
    [4429] =>             return $added;
    [4430] =>         }
    [4431] =>         if ($items instanceof DataObject) {
    [4432] =>             $items = [$items];
    [4433] =>         }
    [4434] => 
    [4435] =>         /** @var DataObject $item */
    [4436] =>         foreach ($items as $item) {
    [4437] =>             $this->mergeRelatedObject($list, $added, $item);
    [4438] =>         }
    [4439] =>         return $added;
    [4440] =>     }
    [4441] => 
    [4442] =>     /**
    [4443] =>      * Generate a unique key for data object
    [4444] =>      * the unique key uses the @see DataObject::getUniqueKeyComponents() extension point so unique key modifiers
    [4445] =>      * such as versioned or fluent are covered
    [4446] =>      * i.e. same data object in different stages or different locales will produce different unique key
    [4447] =>      *
    [4448] =>      * recommended use:
    [4449] =>      * - when you need unique key for caching purposes
    [4450] =>      * - when you need unique id on the front end (for example JavaScript needs to target specific element)
    [4451] =>      *
    [4452] =>      * @return string
    [4453] =>      * @throws Exception
    [4454] =>      */
    [4455] =>     public function getUniqueKey(): string
    [4456] =>     {
    [4457] =>         /** @var UniqueKeyInterface $service */
    [4458] =>         $service = Injector::inst()->get(UniqueKeyInterface::class);
    [4459] =>         $keyComponents = $this->getUniqueKeyComponents();
    [4460] => 
    [4461] =>         return $service->generateKey($this, $keyComponents);
    [4462] =>     }
    [4463] => 
    [4464] =>     /**
    [4465] =>      * Merge single object into a list, but ensures that existing objects are not
    [4466] =>      * re-added.
    [4467] =>      *
    [4468] =>      * @param ArrayList $list Global list
    [4469] =>      * @param ArrayList $added Additional list to insert into
    [4470] =>      * @param DataObject $item Item to add
    [4471] =>      */
    [4472] =>     protected function mergeRelatedObject($list, $added, $item)
    [4473] =>     {
    [4474] =>         // Identify item
    [4475] =>         $itemKey = get_class($item) . '/' . $item->ID;
    [4476] => 
    [4477] =>         // Write if saved, versioned, and not already added
    [4478] =>         if ($item->isInDB() && !isset($list[$itemKey])) {
    [4479] =>             $list[$itemKey] = $item;
    [4480] =>             $added[$itemKey] = $item;
    [4481] =>         }
    [4482] => 
    [4483] =>         // Add joined record (from many_many through) automatically
    [4484] =>         $joined = $item->getJoin();
    [4485] =>         if ($joined) {
    [4486] =>             $this->mergeRelatedObject($list, $added, $joined);
    [4487] =>         }
    [4488] =>     }
    [4489] => 
    [4490] =>     /**
    [4491] =>      * Extension point to add more cache key components.
    [4492] =>      * The framework extend method will return combined values from DataExtension method(s) as an array
    [4493] =>      * The method on your DataExtension class should return a single scalar value. For example:
    [4494] =>      *
    [4495] =>      * public function cacheKeyComponent()
    [4496] =>      * {
    [4497] =>      *      return (string) $this->owner->MyColumn;
    [4498] =>      * }
    [4499] =>      *
    [4500] =>      * @return array
    [4501] =>      */
    [4502] =>     private function getUniqueKeyComponents(): array
    [4503] =>     {
    [4504] =>         return $this->extend('cacheKeyComponent');
    [4505] =>     }
    [4506] => 
    [4507] =>     /**
    [4508] =>      * Find all other DataObject instances that are related to this DataObject in the database
    [4509] =>      * through has_one and many_many relationships. For example:
    [4510] =>      * This method is called on a File.  The MyPage model $has_one File.  There is a Page record that has
    [4511] =>      * a FileID = $this->ID. This SS_List returned by this method will include that Page instance.
    [4512] =>      *
    [4513] =>      * @param string[] $excludedClasses
    [4514] =>      * @return SS_List
    [4515] =>      * @internal
    [4516] =>      */
    [4517] =>     public function findAllRelatedData(array $excludedClasses = []): SS_List
    [4518] =>     {
    [4519] =>         $service = Injector::inst()->get(RelatedDataService::class);
    [4520] =>         return $service->findAll($this, $excludedClasses);
    [4521] =>     }
    [4522] => }
    [4523] => 
    [4524] => 
    [4525] => In ParserAbstract.php line 293:
    [4526] => 
    [4527] =>   [PhpParser\Error]
    [4528] =>   Syntax error, unexpected T_STRING, expecting T_FUNCTION or T_CONST on line 4265
    [4529] => 
    [4530] => 
    [4531] => Exception trace:
    [4532] =>   at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php:293
    [4533] =>  PhpParser\ParserAbstract->parse() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Parser/DirectParser.php:45
    [4534] =>  PHPStan\Parser\DirectParser->parseString() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Parser/DirectParser.php:35
    [4535] =>  PHPStan\Parser\DirectParser->parseFile() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Parser/CachedParser.php:29
    [4536] =>  PHPStan\Parser\CachedParser->parseFile() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Type/FileTypeMapper.php:110
    [4537] =>  PHPStan\Type\FileTypeMapper->createResolvedPhpDocMap() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Type/FileTypeMapper.php:81
    [4538] =>  PHPStan\Type\FileTypeMapper->getResolvedPhpDocMap() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Type/FileTypeMapper.php:61
    [4539] =>  PHPStan\Type\FileTypeMapper->getResolvedPhpDoc() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/Annotations/AnnotationsMethodsClassReflectionExtension.php:72
    [4540] =>  PHPStan\Reflection\Annotations\AnnotationsMethodsClassReflectionExtension->createMethods() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/Annotations/AnnotationsMethodsClassReflectionExtension.php:53
    [4541] =>  PHPStan\Reflection\Annotations\AnnotationsMethodsClassReflectionExtension->createMethods() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/Annotations/AnnotationsMethodsClassReflectionExtension.php:53
    [4542] =>  PHPStan\Reflection\Annotations\AnnotationsMethodsClassReflectionExtension->createMethods() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/Annotations/AnnotationsMethodsClassReflectionExtension.php:27
    [4543] =>  PHPStan\Reflection\Annotations\AnnotationsMethodsClassReflectionExtension->hasMethod() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/Php/PhpClassReflectionExtension.php:199
    [4544] =>  PHPStan\Reflection\Php\PhpClassReflectionExtension->createMethod() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/Php/PhpClassReflectionExtension.php:167
    [4545] =>  PHPStan\Reflection\Php\PhpClassReflectionExtension->getMethod() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Reflection/ClassReflection.php:170
    [4546] =>  PHPStan\Reflection\ClassReflection->getMethod() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Type/ObjectType.php:177
    [4547] =>  PHPStan\Type\ObjectType->getMethod() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/Scope.php:691
    [4548] =>  PHPStan\Analyser\Scope->resolveType() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/Scope.php:323
    [4549] =>  PHPStan\Analyser\Scope->getType() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/Scope.php:640
    [4550] =>  PHPStan\Analyser\Scope->resolveType() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/Scope.php:323
    [4551] =>  PHPStan\Analyser\Scope->getType() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Rules/RuleLevelHelper.php:89
    [4552] =>  PHPStan\Rules\RuleLevelHelper->findTypeToCheck() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Rules/Methods/CallMethodsRule.php:62
    [4553] =>  PHPStan\Rules\Methods\CallMethodsRule->processNode() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/Visitor/PHPStanScopeVisitor.php:80
    [4554] =>  SilverStripe\Upgrader\UpgradeRule\PHP\Visitor\PHPStanScopeVisitor->SilverStripe\Upgrader\UpgradeRule\PHP\Visitor\{closure}() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:316
    [4555] =>  PHPStan\Analyser\NodeScopeResolver->processNode() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:777
    [4556] =>  PHPStan\Analyser\NodeScopeResolver->processNode() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:176
    [4557] =>  PHPStan\Analyser\NodeScopeResolver->processNodes() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:489
    [4558] =>  PHPStan\Analyser\NodeScopeResolver->processNode() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:176
    [4559] =>  PHPStan\Analyser\NodeScopeResolver->processNodes() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:699
    [4560] =>  PHPStan\Analyser\NodeScopeResolver->processNode() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:176
    [4561] =>  PHPStan\Analyser\NodeScopeResolver->processNodes() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:699
    [4562] =>  PHPStan\Analyser\NodeScopeResolver->processNode() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:176
    [4563] =>  PHPStan\Analyser\NodeScopeResolver->processNodes() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:699
    [4564] =>  PHPStan\Analyser\NodeScopeResolver->processNode() at /var/www/ss3/upgrader/vendor/phpstan/phpstan/src/Analyser/NodeScopeResolver.php:176
    [4565] =>  PHPStan\Analyser\NodeScopeResolver->processNodes() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/Visitor/PHPStanScopeVisitor.php:82
    [4566] =>  SilverStripe\Upgrader\UpgradeRule\PHP\Visitor\PHPStanScopeVisitor->enterNode() at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/NodeTraverser.php:159
    [4567] =>  PhpParser\NodeTraverser->traverseArray() at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/NodeTraverser.php:85
    [4568] =>  PhpParser\NodeTraverser->traverse() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/PHPUpgradeRule.php:28
    [4569] =>  SilverStripe\Upgrader\UpgradeRule\PHP\PHPUpgradeRule->transformWithVisitors() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/ApiChangeWarningsRule.php:88
    [4570] =>  SilverStripe\Upgrader\UpgradeRule\PHP\ApiChangeWarningsRule->mutateSourceWithVisitors() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/ApiChangeWarningsRule.php:60
    [4571] =>  SilverStripe\Upgrader\UpgradeRule\PHP\ApiChangeWarningsRule->upgradeFile() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Upgrader.php:61
    [4572] =>  SilverStripe\Upgrader\Upgrader->upgrade() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Console/InspectCommand.php:88
    [4573] =>  SilverStripe\Upgrader\Console\InspectCommand->execute() at /var/www/ss3/upgrader/vendor/symfony/console/Command/Command.php:255
    [4574] =>  Symfony\Component\Console\Command\Command->run() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:1021
    [4575] =>  Symfony\Component\Console\Application->doRunCommand() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:275
    [4576] =>  Symfony\Component\Console\Application->doRun() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:149
    [4577] =>  Symfony\Component\Console\Application->run() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code:55
    [4578] => 
    [4579] => inspect [-d|--root-dir ROOT-DIR] [-w|--write] [--skip-visibility] [--] <path>
    [4580] => 
)


------------------------------------------------------------------------
To continue, please use the following parameter: startFrom=InspectAPIChanges-1
e.g. php runme.php startFrom=InspectAPIChanges-1
------------------------------------------------------------------------
            
# running php upgrade inspect see: https://github.com/silverstripe/silverstripe-upgrader
cd /var/www/upgrades/upgradeto4
php /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code inspect /var/www/upgrades/upgradeto4/payment_paypal/src  --root-dir=/var/www/upgrades/upgradeto4 --write -vvv
Array
(
    [0] => Running post-upgrade on "/var/www/upgrades/upgradeto4/payment_paypal/src"
    [1] => [2025-07-14 05:29:30] Applying ApiChangeWarningsRule to PayPalExpressCheckoutPaymentHandler.php...
    [2] => PHP Warning:  Undefined array key 265 in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Lexer.php on line 258
    [3] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 190
    [4] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 359
    [5] => PHP Warning:  Undefined array key 265 in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Lexer.php on line 258
    [6] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 190
    [7] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 359
    [8] => 
    [9] => In ParserAbstract.php line 293:
    [10] => 
    [11] =>   [PhpParser\Error]
    [12] =>   Syntax error, unexpected , expecting T_STRING or T_NS_SEPARATOR or '{' on line 3
    [13] => 
    [14] => 
    [15] => Exception trace:
    [16] =>   at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php:293
    [17] =>  PhpParser\ParserAbstract->parse() at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Parser/Multiple.php:50
    [18] =>  PhpParser\Parser\Multiple->tryParse() at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Parser/Multiple.php:31
    [19] =>  PhpParser\Parser\Multiple->parse() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Util/MutableSource.php:45
    [20] =>  SilverStripe\Upgrader\Util\MutableSource->__construct() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/ApiChangeWarningsRule.php:54
    [21] =>  SilverStripe\Upgrader\UpgradeRule\PHP\ApiChangeWarningsRule->upgradeFile() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Upgrader.php:61
    [22] =>  SilverStripe\Upgrader\Upgrader->upgrade() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Console/InspectCommand.php:88
    [23] =>  SilverStripe\Upgrader\Console\InspectCommand->execute() at /var/www/ss3/upgrader/vendor/symfony/console/Command/Command.php:255
    [24] =>  Symfony\Component\Console\Command\Command->run() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:1021
    [25] =>  Symfony\Component\Console\Application->doRunCommand() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:275
    [26] =>  Symfony\Component\Console\Application->doRun() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:149
    [27] =>  Symfony\Component\Console\Application->run() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code:55
    [28] => 
    [29] => inspect [-d|--root-dir ROOT-DIR] [-w|--write] [--skip-visibility] [--] <path>
    [30] => 
)


------------------------------------------------------------------------
To continue, please use the following parameter: startFrom=InspectAPIChanges-1
e.g. php runme.php startFrom=InspectAPIChanges-1
------------------------------------------------------------------------
            
# running php upgrade inspect see: https://github.com/silverstripe/silverstripe-upgrader
cd /var/www/upgrades/upgradeto4
php /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code inspect /var/www/upgrades/upgradeto4/payment_paypal/src  --root-dir=/var/www/upgrades/upgradeto4 --write -vvv
Array
(
    [0] => Running post-upgrade on "/var/www/upgrades/upgradeto4/payment_paypal/src"
    [1] => [2025-07-14 05:31:24] Applying ApiChangeWarningsRule to PayPalExpressCheckoutPaymentHandler.php...
    [2] => PHP Warning:  Undefined array key 265 in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Lexer.php on line 258
    [3] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 190
    [4] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 359
    [5] => PHP Warning:  Undefined array key 265 in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Lexer.php on line 258
    [6] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 190
    [7] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 359
    [8] => 
    [9] => In ParserAbstract.php line 293:
    [10] => 
    [11] =>   [PhpParser\Error]
    [12] =>   Syntax error, unexpected , expecting T_STRING or T_NS_SEPARATOR or '{' on line 3
    [13] => 
    [14] => 
    [15] => Exception trace:
    [16] =>   at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php:293
    [17] =>  PhpParser\ParserAbstract->parse() at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Parser/Multiple.php:50
    [18] =>  PhpParser\Parser\Multiple->tryParse() at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Parser/Multiple.php:31
    [19] =>  PhpParser\Parser\Multiple->parse() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Util/MutableSource.php:45
    [20] =>  SilverStripe\Upgrader\Util\MutableSource->__construct() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/ApiChangeWarningsRule.php:54
    [21] =>  SilverStripe\Upgrader\UpgradeRule\PHP\ApiChangeWarningsRule->upgradeFile() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Upgrader.php:61
    [22] =>  SilverStripe\Upgrader\Upgrader->upgrade() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Console/InspectCommand.php:88
    [23] =>  SilverStripe\Upgrader\Console\InspectCommand->execute() at /var/www/ss3/upgrader/vendor/symfony/console/Command/Command.php:255
    [24] =>  Symfony\Component\Console\Command\Command->run() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:1021
    [25] =>  Symfony\Component\Console\Application->doRunCommand() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:275
    [26] =>  Symfony\Component\Console\Application->doRun() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:149
    [27] =>  Symfony\Component\Console\Application->run() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code:55
    [28] => 
    [29] => inspect [-d|--root-dir ROOT-DIR] [-w|--write] [--skip-visibility] [--] <path>
    [30] => 
)


------------------------------------------------------------------------
To continue, please use the following parameter: startFrom=InspectAPIChanges-1
e.g. php runme.php startFrom=InspectAPIChanges-1
------------------------------------------------------------------------
            
# running php upgrade inspect see: https://github.com/silverstripe/silverstripe-upgrader
cd /var/www/upgrades/upgradeto4
php /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code inspect /var/www/upgrades/upgradeto4/payment_paypal/src  --root-dir=/var/www/upgrades/upgradeto4 --write -vvv
Array
(
    [0] => Running post-upgrade on "/var/www/upgrades/upgradeto4/payment_paypal/src"
    [1] => [2025-07-14 05:35:49] Applying ApiChangeWarningsRule to PayPalExpressCheckoutPaymentHandler.php...
    [2] => PHP Warning:  Undefined array key 265 in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Lexer.php on line 258
    [3] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 190
    [4] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 359
    [5] => PHP Warning:  Undefined array key 265 in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Lexer.php on line 258
    [6] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 190
    [7] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 359
    [8] => 
    [9] => In ParserAbstract.php line 293:
    [10] => 
    [11] =>   [PhpParser\Error]
    [12] =>   Syntax error, unexpected , expecting T_STRING or T_NS_SEPARATOR or '{' on line 3
    [13] => 
    [14] => 
    [15] => Exception trace:
    [16] =>   at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php:293
    [17] =>  PhpParser\ParserAbstract->parse() at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Parser/Multiple.php:50
    [18] =>  PhpParser\Parser\Multiple->tryParse() at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Parser/Multiple.php:31
    [19] =>  PhpParser\Parser\Multiple->parse() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Util/MutableSource.php:45
    [20] =>  SilverStripe\Upgrader\Util\MutableSource->__construct() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/ApiChangeWarningsRule.php:54
    [21] =>  SilverStripe\Upgrader\UpgradeRule\PHP\ApiChangeWarningsRule->upgradeFile() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Upgrader.php:61
    [22] =>  SilverStripe\Upgrader\Upgrader->upgrade() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Console/InspectCommand.php:88
    [23] =>  SilverStripe\Upgrader\Console\InspectCommand->execute() at /var/www/ss3/upgrader/vendor/symfony/console/Command/Command.php:255
    [24] =>  Symfony\Component\Console\Command\Command->run() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:1021
    [25] =>  Symfony\Component\Console\Application->doRunCommand() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:275
    [26] =>  Symfony\Component\Console\Application->doRun() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:149
    [27] =>  Symfony\Component\Console\Application->run() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code:55
    [28] => 
    [29] => inspect [-d|--root-dir ROOT-DIR] [-w|--write] [--skip-visibility] [--] <path>
    [30] => 
)


------------------------------------------------------------------------
To continue, please use the following parameter: startFrom=InspectAPIChanges-1
e.g. php runme.php startFrom=InspectAPIChanges-1
------------------------------------------------------------------------
            
# running php upgrade inspect see: https://github.com/silverstripe/silverstripe-upgrader
cd /var/www/upgrades/upgradeto4
php /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code inspect /var/www/upgrades/upgradeto4/payment_paypal/src  --root-dir=/var/www/upgrades/upgradeto4 --write -vvv
Array
(
    [0] => Running post-upgrade on "/var/www/upgrades/upgradeto4/payment_paypal/src"
    [1] => [2025-07-14 05:37:20] Applying ApiChangeWarningsRule to PayPalExpressCheckoutPaymentHandler.php...
    [2] => PHP Warning:  Undefined array key 265 in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Lexer.php on line 258
    [3] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 190
    [4] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 359
    [5] => PHP Warning:  Undefined array key 265 in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Lexer.php on line 258
    [6] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 190
    [7] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 359
    [8] => 
    [9] => In ParserAbstract.php line 293:
    [10] => 
    [11] =>   [PhpParser\Error]
    [12] =>   Syntax error, unexpected , expecting T_STRING or T_NS_SEPARATOR or '{' on line 3
    [13] => 
    [14] => 
    [15] => Exception trace:
    [16] =>   at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php:293
    [17] =>  PhpParser\ParserAbstract->parse() at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Parser/Multiple.php:50
    [18] =>  PhpParser\Parser\Multiple->tryParse() at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Parser/Multiple.php:31
    [19] =>  PhpParser\Parser\Multiple->parse() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Util/MutableSource.php:45
    [20] =>  SilverStripe\Upgrader\Util\MutableSource->__construct() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/ApiChangeWarningsRule.php:54
    [21] =>  SilverStripe\Upgrader\UpgradeRule\PHP\ApiChangeWarningsRule->upgradeFile() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Upgrader.php:61
    [22] =>  SilverStripe\Upgrader\Upgrader->upgrade() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Console/InspectCommand.php:88
    [23] =>  SilverStripe\Upgrader\Console\InspectCommand->execute() at /var/www/ss3/upgrader/vendor/symfony/console/Command/Command.php:255
    [24] =>  Symfony\Component\Console\Command\Command->run() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:1021
    [25] =>  Symfony\Component\Console\Application->doRunCommand() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:275
    [26] =>  Symfony\Component\Console\Application->doRun() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:149
    [27] =>  Symfony\Component\Console\Application->run() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code:55
    [28] => 
    [29] => inspect [-d|--root-dir ROOT-DIR] [-w|--write] [--skip-visibility] [--] <path>
    [30] => 
)


------------------------------------------------------------------------
To continue, please use the following parameter: startFrom=InspectAPIChanges-1
e.g. php runme.php startFrom=InspectAPIChanges-1
------------------------------------------------------------------------
            
# running php upgrade inspect see: https://github.com/silverstripe/silverstripe-upgrader
cd /var/www/upgrades/upgradeto4
php /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code inspect /var/www/upgrades/upgradeto4/payment_paypal/src  --root-dir=/var/www/upgrades/upgradeto4 --write -vvv
Array
(
    [0] => Running post-upgrade on "/var/www/upgrades/upgradeto4/payment_paypal/src"
    [1] => [2025-07-14 05:41:03] Applying ApiChangeWarningsRule to PayPalExpressCheckoutPaymentHandler.php...
    [2] => <?php
    [3] => 
    [4] => namespace Sunnysideup\PaymentPaypal;
    [5] => 
    [6] => 
    [7] => 
    [8] => 
    [9] => use SilverStripe\Control\Director;
    [10] => use SilverStripe\Control\Controller;
    [11] => use SilverStripe\Core\Config\Config;
    [12] => 
    [13] => 
    [14] => 
    [15] => 
    [16] => /**
    [17] =>  * Handler for responses from the PayPal site
    [18] =>  */
    [19] => class PayPalExpressCheckoutPaymentHandler extends Controller
    [20] => {
    [21] =>     private static $url_segment = 'paypalexpresscheckoutpaymenthandler';
    [22] => 
    [23] =>     protected $payment = null; //only need to get this once
    [24] => 
    [25] =>     private static $allowed_actions = array(
    [26] =>         'confirm',
    [27] =>         'cancel'
    [28] =>     );
    [29] => 
    [30] =>     public function Link($action = null)
    [31] =>     {
    [32] =>         return Controller::join_links(
    [33] =>             Director::baseURL(),
    [34] =>             $this->Config()->get("url_segment"),
    [35] =>             $action
    [36] =>         );
    [37] =>     }
    [38] => 
    [39] =>     public function payment()
    [40] =>     {
    [41] =>         if ($this->payment) {
    [42] =>             return $this->payment;
    [43] =>         } elseif ($token = Controller::getRequest()->getVar('token')) {
    [44] =>             $payment =  PayPalExpressCheckoutPayment::get()
    [45] =>                 ->filter(
    [46] =>                     array(
    [47] =>                         "Token" => $token,
    [48] =>                         "Status" => "Incomplete"
    [49] =>                     )
    [50] =>                 )
    [51] =>                 ->first();
    [52] =>             $this->payment = $payment;
    [53] =>             $this->payment->init();
    [54] =>             return $this->payment;
    [55] =>         }
    [56] =>         return null;
    [57] =>     }
    [58] => 
    [59] =>     public function confirm($request)
    [60] =>     {
    [61] =>         //TODO: pretend the user confirmed, and skip straight to results. (check that this is allowed)
    [62] =>         //TODO: get updated shipping details from paypal??
    [63] =>         if ($payment = $this->payment()) {
    [64] =>             if ($pid = Controller::getRequest()->getVar('PayerID')) {
    [65] =>                 $payment->PayerID = $pid;
    [66] =>                 $payment->write();
    [67] =>                 $payment->confirmPayment();
    [68] =>             }
    [69] =>         } else {
    [70] =>             //something went wrong?	..perhaps trying to pay for a payment that has already been processed
    [71] =>         }
    [72] =>         $this->doRedirect();
    [73] =>         return;
    [74] =>     }
    [75] => 
    [76] =>     public function cancel($request)
    [77] =>     {
    [78] =>         if ($payment = $this->payment()) {
    [79] =>             //TODO: do API call to gather further information
    [80] =>             $payment->Status = "Failure";
    [81] =>             $payment->Message = _t('PayPalExpressCheckoutPayment.USERCANCELLED', "User cancelled");
    [82] =>             $payment->write();
    [83] =>         }
    [84] =>         $this->doRedirect();
    [85] =>         return;
    [86] =>     }
    [87] => 
    [88] =>     protected function doRedirect()
    [89] =>     {
    [90] =>         $payment = $this->payment();
    [91] =>         if ($payment && $obj = $payment->PaidObject()) {
    [92] =>             $this->redirect($obj->Link());
    [93] =>             return;
    [94] =>         }
    [95] =>         $this->redirect(Director::absoluteURL('home', true)); //TODO: make this customisable in Payment_Controllers
    [96] =>         return;
    [97] =>     }
    [98] => 
    [99] =>     public static function return_link()
    [100] =>     {
    [101] => 
    [102] =>         /**
    [103] =>          * ### @@@@ START REPLACEMENT @@@@ ###
    [104] =>          * WHY: automated upgrade
    [105] =>          * OLD: Config::inst()->get("
    [106] =>          * NEW: Config::inst()->get(" ...  (COMPLEX)
    [107] =>          * EXP: Check if you should be using Name::class here instead of hard-coded class.
    [108] =>          * ### @@@@ STOP REPLACEMENT @@@@ ###
    [109] =>          */
    [110] =>         return Director::absoluteURL(Config::inst()->get(PayPalExpressCheckoutPaymentHandler::class, "url_segment"), true) . "/confirm/";
    [111] =>     }
    [112] => 
    [113] =>     public static function cancel_link()
    [114] =>     {
    [115] => 
    [116] =>         /**
    [117] =>          * ### @@@@ START REPLACEMENT @@@@ ###
    [118] =>          * WHY: automated upgrade
    [119] =>          * OLD: Config::inst()->get("
    [120] =>          * NEW: Config::inst()->get(" ...  (COMPLEX)
    [121] =>          * EXP: Check if you should be using Name::class here instead of hard-coded class.
    [122] =>          * ### @@@@ STOP REPLACEMENT @@@@ ###
    [123] =>          */
    [124] =>         return Director::absoluteURL(Config::inst()->get(PayPalExpressCheckoutPaymentHandler::class, "url_segment"), true) . "/cancel/";
    [125] =>     }
    [126] =>     public static function complete_link()
    [127] =>     {
    [128] => 
    [129] =>         /**
    [130] =>          * ### @@@@ START REPLACEMENT @@@@ ###
    [131] =>          * WHY: automated upgrade
    [132] =>          * OLD: Config::inst()->get("
    [133] =>          * NEW: Config::inst()->get(" ...  (COMPLEX)
    [134] =>          * EXP: Check if you should be using Name::class here instead of hard-coded class.
    [135] =>          * ### @@@@ STOP REPLACEMENT @@@@ ###
    [136] =>          */
    [137] =>         return Director::absoluteURL(Config::inst()->get(PayPalExpressCheckoutPaymentHandler::class, "url_segment"), true) . "/confirm/";
    [138] =>     }
    [139] => }
    [140] => PHP Warning:  Undefined array key 265 in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Lexer.php on line 258
    [141] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 190
    [142] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 359
    [143] => PHP Warning:  Undefined array key 265 in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Lexer.php on line 258
    [144] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 190
    [145] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 359
    [146] => 
    [147] => In ParserAbstract.php line 293:
    [148] => 
    [149] =>   [PhpParser\Error]
    [150] =>   Syntax error, unexpected , expecting T_STRING or T_NS_SEPARATOR or '{' on line 3
    [151] => 
    [152] => 
    [153] => Exception trace:
    [154] =>   at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php:293
    [155] =>  PhpParser\ParserAbstract->parse() at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Parser/Multiple.php:54
    [156] =>  PhpParser\Parser\Multiple->tryParse() at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Parser/Multiple.php:34
    [157] =>  PhpParser\Parser\Multiple->parse() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Util/MutableSource.php:45
    [158] =>  SilverStripe\Upgrader\Util\MutableSource->__construct() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/ApiChangeWarningsRule.php:54
    [159] =>  SilverStripe\Upgrader\UpgradeRule\PHP\ApiChangeWarningsRule->upgradeFile() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Upgrader.php:61
    [160] =>  SilverStripe\Upgrader\Upgrader->upgrade() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Console/InspectCommand.php:88
    [161] =>  SilverStripe\Upgrader\Console\InspectCommand->execute() at /var/www/ss3/upgrader/vendor/symfony/console/Command/Command.php:255
    [162] =>  Symfony\Component\Console\Command\Command->run() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:1021
    [163] =>  Symfony\Component\Console\Application->doRunCommand() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:275
    [164] =>  Symfony\Component\Console\Application->doRun() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:149
    [165] =>  Symfony\Component\Console\Application->run() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code:55
    [166] => 
    [167] => inspect [-d|--root-dir ROOT-DIR] [-w|--write] [--skip-visibility] [--] <path>
    [168] => 
)


------------------------------------------------------------------------
To continue, please use the following parameter: startFrom=InspectAPIChanges-1
e.g. php runme.php startFrom=InspectAPIChanges-1
------------------------------------------------------------------------
            
# running php upgrade inspect see: https://github.com/silverstripe/silverstripe-upgrader
cd /var/www/upgrades/upgradeto4
php /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code inspect /var/www/upgrades/upgradeto4/payment_paypal/src  --root-dir=/var/www/upgrades/upgradeto4 --write -vvv
Array
(
    [0] => Running post-upgrade on "/var/www/upgrades/upgradeto4/payment_paypal/src"
    [1] => [2025-07-14 05:41:48] Applying ApiChangeWarningsRule to PayPalExpressCheckoutPaymentHandler.php...
    [2] => <?php
    [3] => 
    [4] => namespace Sunnysideup\PaymentPaypal;
    [5] => 
    [6] => 
    [7] => 
    [8] => 
    [9] => use SilverStripe\Control\Director;
    [10] => use SilverStripe\Control\Controller;
    [11] => use SilverStripe\Core\Config\Config;
    [12] => 
    [13] => 
    [14] => 
    [15] => /**
    [16] =>  * Handler for responses from the PayPal site
    [17] =>  */
    [18] => class PayPalExpressCheckoutPaymentHandler extends Controller
    [19] => {
    [20] =>     private static $url_segment = 'paypalexpresscheckoutpaymenthandler';
    [21] => 
    [22] =>     protected $payment = null; //only need to get this once
    [23] => 
    [24] =>     private static $allowed_actions = array(
    [25] =>         'confirm',
    [26] =>         'cancel'
    [27] =>     );
    [28] => 
    [29] =>     public function Link($action = null)
    [30] =>     {
    [31] =>         return Controller::join_links(
    [32] =>             Director::baseURL(),
    [33] =>             $this->Config()->get("url_segment"),
    [34] =>             $action
    [35] =>         );
    [36] =>     }
    [37] => 
    [38] =>     public function payment()
    [39] =>     {
    [40] =>         if ($this->payment) {
    [41] =>             return $this->payment;
    [42] =>         } elseif ($token = Controller::getRequest()->getVar('token')) {
    [43] =>             $payment =  PayPalExpressCheckoutPayment::get()
    [44] =>                 ->filter(
    [45] =>                     array(
    [46] =>                         "Token" => $token,
    [47] =>                         "Status" => "Incomplete"
    [48] =>                     )
    [49] =>                 )
    [50] =>                 ->first();
    [51] =>             $this->payment = $payment;
    [52] =>             $this->payment->init();
    [53] =>             return $this->payment;
    [54] =>         }
    [55] =>         return null;
    [56] =>     }
    [57] => 
    [58] =>     public function confirm($request)
    [59] =>     {
    [60] =>         //TODO: pretend the user confirmed, and skip straight to results. (check that this is allowed)
    [61] =>         //TODO: get updated shipping details from paypal??
    [62] =>         if ($payment = $this->payment()) {
    [63] =>             if ($pid = Controller::getRequest()->getVar('PayerID')) {
    [64] =>                 $payment->PayerID = $pid;
    [65] =>                 $payment->write();
    [66] =>                 $payment->confirmPayment();
    [67] =>             }
    [68] =>         } else {
    [69] =>             //something went wrong?	..perhaps trying to pay for a payment that has already been processed
    [70] =>         }
    [71] =>         $this->doRedirect();
    [72] =>         return;
    [73] =>     }
    [74] => 
    [75] =>     public function cancel($request)
    [76] =>     {
    [77] =>         if ($payment = $this->payment()) {
    [78] =>             //TODO: do API call to gather further information
    [79] =>             $payment->Status = "Failure";
    [80] =>             $payment->Message = _t('PayPalExpressCheckoutPayment.USERCANCELLED', "User cancelled");
    [81] =>             $payment->write();
    [82] =>         }
    [83] =>         $this->doRedirect();
    [84] =>         return;
    [85] =>     }
    [86] => 
    [87] =>     protected function doRedirect()
    [88] =>     {
    [89] =>         $payment = $this->payment();
    [90] =>         if ($payment && $obj = $payment->PaidObject()) {
    [91] =>             $this->redirect($obj->Link());
    [92] =>             return;
    [93] =>         }
    [94] =>         $this->redirect(Director::absoluteURL('home', true)); //TODO: make this customisable in Payment_Controllers
    [95] =>         return;
    [96] =>     }
    [97] => 
    [98] =>     public static function return_link()
    [99] =>     {
    [100] => 
    [101] =>         /**
    [102] =>          * ### @@@@ START REPLACEMENT @@@@ ###
    [103] =>          * WHY: automated upgrade
    [104] =>          * OLD: Config::inst()->get("
    [105] =>          * NEW: Config::inst()->get(" ...  (COMPLEX)
    [106] =>          * EXP: Check if you should be using Name::class here instead of hard-coded class.
    [107] =>          * ### @@@@ STOP REPLACEMENT @@@@ ###
    [108] =>          */
    [109] =>         return Director::absoluteURL(Config::inst()->get(PayPalExpressCheckoutPaymentHandler::class, "url_segment"), true) . "/confirm/";
    [110] =>     }
    [111] => 
    [112] =>     public static function cancel_link()
    [113] =>     {
    [114] => 
    [115] =>         /**
    [116] =>          * ### @@@@ START REPLACEMENT @@@@ ###
    [117] =>          * WHY: automated upgrade
    [118] =>          * OLD: Config::inst()->get("
    [119] =>          * NEW: Config::inst()->get(" ...  (COMPLEX)
    [120] =>          * EXP: Check if you should be using Name::class here instead of hard-coded class.
    [121] =>          * ### @@@@ STOP REPLACEMENT @@@@ ###
    [122] =>          */
    [123] =>         return Director::absoluteURL(Config::inst()->get(PayPalExpressCheckoutPaymentHandler::class, "url_segment"), true) . "/cancel/";
    [124] =>     }
    [125] =>     public static function complete_link()
    [126] =>     {
    [127] => 
    [128] =>         /**
    [129] =>          * ### @@@@ START REPLACEMENT @@@@ ###
    [130] =>          * WHY: automated upgrade
    [131] =>          * OLD: Config::inst()->get("
    [132] =>          * NEW: Config::inst()->get(" ...  (COMPLEX)
    [133] =>          * EXP: Check if you should be using Name::class here instead of hard-coded class.
    [134] =>          * ### @@@@ STOP REPLACEMENT @@@@ ###
    [135] =>          */
    [136] =>         return Director::absoluteURL(Config::inst()->get(PayPalExpressCheckoutPaymentHandler::class, "url_segment"), true) . "/confirm/";
    [137] =>     }
    [138] => }
    [139] => PHP Warning:  Undefined array key 265 in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Lexer.php on line 258
    [140] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 190
    [141] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 359
    [142] => PHP Warning:  Undefined array key 265 in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Lexer.php on line 258
    [143] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 190
    [144] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 359
    [145] => 
    [146] => In ParserAbstract.php line 293:
    [147] => 
    [148] =>   [PhpParser\Error]
    [149] =>   Syntax error, unexpected , expecting T_STRING or T_NS_SEPARATOR or '{' on line 3
    [150] => 
    [151] => 
    [152] => Exception trace:
    [153] =>   at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php:293
    [154] =>  PhpParser\ParserAbstract->parse() at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Parser/Multiple.php:54
    [155] =>  PhpParser\Parser\Multiple->tryParse() at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Parser/Multiple.php:34
    [156] =>  PhpParser\Parser\Multiple->parse() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Util/MutableSource.php:45
    [157] =>  SilverStripe\Upgrader\Util\MutableSource->__construct() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/ApiChangeWarningsRule.php:54
    [158] =>  SilverStripe\Upgrader\UpgradeRule\PHP\ApiChangeWarningsRule->upgradeFile() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Upgrader.php:61
    [159] =>  SilverStripe\Upgrader\Upgrader->upgrade() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Console/InspectCommand.php:88
    [160] =>  SilverStripe\Upgrader\Console\InspectCommand->execute() at /var/www/ss3/upgrader/vendor/symfony/console/Command/Command.php:255
    [161] =>  Symfony\Component\Console\Command\Command->run() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:1021
    [162] =>  Symfony\Component\Console\Application->doRunCommand() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:275
    [163] =>  Symfony\Component\Console\Application->doRun() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:149
    [164] =>  Symfony\Component\Console\Application->run() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code:55
    [165] => 
    [166] => inspect [-d|--root-dir ROOT-DIR] [-w|--write] [--skip-visibility] [--] <path>
    [167] => 
)


------------------------------------------------------------------------
To continue, please use the following parameter: startFrom=InspectAPIChanges-1
e.g. php runme.php startFrom=InspectAPIChanges-1
------------------------------------------------------------------------
            
# running php upgrade inspect see: https://github.com/silverstripe/silverstripe-upgrader
cd /var/www/upgrades/upgradeto4
php /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code inspect /var/www/upgrades/upgradeto4/payment_paypal/src  --root-dir=/var/www/upgrades/upgradeto4 --write -vvv
Array
(
    [0] => Running post-upgrade on "/var/www/upgrades/upgradeto4/payment_paypal/src"
    [1] => [2025-07-14 05:42:33] Applying ApiChangeWarningsRule to PayPalExpressCheckoutPaymentHandler.php...
    [2] => <?php
    [3] => 
    [4] => 
    [5] => 
    [6] => 
    [7] => 
    [8] => use SilverStripe\Control\Director;
    [9] => use SilverStripe\Control\Controller;
    [10] => use SilverStripe\Core\Config\Config;
    [11] => 
    [12] => 
    [13] => 
    [14] => /**
    [15] =>  * Handler for responses from the PayPal site
    [16] =>  */
    [17] => class PayPalExpressCheckoutPaymentHandler extends Controller
    [18] => {
    [19] =>     private static $url_segment = 'paypalexpresscheckoutpaymenthandler';
    [20] => 
    [21] =>     protected $payment = null; //only need to get this once
    [22] => 
    [23] =>     private static $allowed_actions = array(
    [24] =>         'confirm',
    [25] =>         'cancel'
    [26] =>     );
    [27] => 
    [28] =>     public function Link($action = null)
    [29] =>     {
    [30] =>         return Controller::join_links(
    [31] =>             Director::baseURL(),
    [32] =>             $this->Config()->get("url_segment"),
    [33] =>             $action
    [34] =>         );
    [35] =>     }
    [36] => 
    [37] =>     public function payment()
    [38] =>     {
    [39] =>         if ($this->payment) {
    [40] =>             return $this->payment;
    [41] =>         } elseif ($token = Controller::getRequest()->getVar('token')) {
    [42] =>             $payment =  PayPalExpressCheckoutPayment::get()
    [43] =>                 ->filter(
    [44] =>                     array(
    [45] =>                         "Token" => $token,
    [46] =>                         "Status" => "Incomplete"
    [47] =>                     )
    [48] =>                 )
    [49] =>                 ->first();
    [50] =>             $this->payment = $payment;
    [51] =>             $this->payment->init();
    [52] =>             return $this->payment;
    [53] =>         }
    [54] =>         return null;
    [55] =>     }
    [56] => 
    [57] =>     public function confirm($request)
    [58] =>     {
    [59] =>         //TODO: pretend the user confirmed, and skip straight to results. (check that this is allowed)
    [60] =>         //TODO: get updated shipping details from paypal??
    [61] =>         if ($payment = $this->payment()) {
    [62] =>             if ($pid = Controller::getRequest()->getVar('PayerID')) {
    [63] =>                 $payment->PayerID = $pid;
    [64] =>                 $payment->write();
    [65] =>                 $payment->confirmPayment();
    [66] =>             }
    [67] =>         } else {
    [68] =>             //something went wrong?	..perhaps trying to pay for a payment that has already been processed
    [69] =>         }
    [70] =>         $this->doRedirect();
    [71] =>         return;
    [72] =>     }
    [73] => 
    [74] =>     public function cancel($request)
    [75] =>     {
    [76] =>         if ($payment = $this->payment()) {
    [77] =>             //TODO: do API call to gather further information
    [78] =>             $payment->Status = "Failure";
    [79] =>             $payment->Message = _t('PayPalExpressCheckoutPayment.USERCANCELLED', "User cancelled");
    [80] =>             $payment->write();
    [81] =>         }
    [82] =>         $this->doRedirect();
    [83] =>         return;
    [84] =>     }
    [85] => 
    [86] =>     protected function doRedirect()
    [87] =>     {
    [88] =>         $payment = $this->payment();
    [89] =>         if ($payment && $obj = $payment->PaidObject()) {
    [90] =>             $this->redirect($obj->Link());
    [91] =>             return;
    [92] =>         }
    [93] =>         $this->redirect(Director::absoluteURL('home', true)); //TODO: make this customisable in Payment_Controllers
    [94] =>         return;
    [95] =>     }
    [96] => 
    [97] =>     public static function return_link()
    [98] =>     {
    [99] => 
    [100] =>         /**
    [101] =>          * ### @@@@ START REPLACEMENT @@@@ ###
    [102] =>          * WHY: automated upgrade
    [103] =>          * OLD: Config::inst()->get("
    [104] =>          * NEW: Config::inst()->get(" ...  (COMPLEX)
    [105] =>          * EXP: Check if you should be using Name::class here instead of hard-coded class.
    [106] =>          * ### @@@@ STOP REPLACEMENT @@@@ ###
    [107] =>          */
    [108] =>         return Director::absoluteURL(Config::inst()->get(PayPalExpressCheckoutPaymentHandler::class, "url_segment"), true) . "/confirm/";
    [109] =>     }
    [110] => 
    [111] =>     public static function cancel_link()
    [112] =>     {
    [113] => 
    [114] =>         /**
    [115] =>          * ### @@@@ START REPLACEMENT @@@@ ###
    [116] =>          * WHY: automated upgrade
    [117] =>          * OLD: Config::inst()->get("
    [118] =>          * NEW: Config::inst()->get(" ...  (COMPLEX)
    [119] =>          * EXP: Check if you should be using Name::class here instead of hard-coded class.
    [120] =>          * ### @@@@ STOP REPLACEMENT @@@@ ###
    [121] =>          */
    [122] =>         return Director::absoluteURL(Config::inst()->get(PayPalExpressCheckoutPaymentHandler::class, "url_segment"), true) . "/cancel/";
    [123] =>     }
    [124] =>     public static function complete_link()
    [125] =>     {
    [126] => 
    [127] =>         /**
    [128] =>          * ### @@@@ START REPLACEMENT @@@@ ###
    [129] =>          * WHY: automated upgrade
    [130] =>          * OLD: Config::inst()->get("
    [131] =>          * NEW: Config::inst()->get(" ...  (COMPLEX)
    [132] =>          * EXP: Check if you should be using Name::class here instead of hard-coded class.
    [133] =>          * ### @@@@ STOP REPLACEMENT @@@@ ###
    [134] =>          */
    [135] =>         return Director::absoluteURL(Config::inst()->get(PayPalExpressCheckoutPaymentHandler::class, "url_segment"), true) . "/confirm/";
    [136] =>     }
    [137] => }
    [138] => PHP Warning:  Undefined array key 265 in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Lexer.php on line 258
    [139] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 190
    [140] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 359
    [141] => PHP Warning:  Undefined array key 265 in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Lexer.php on line 258
    [142] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 190
    [143] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 359
    [144] => 
    [145] => In ParserAbstract.php line 293:
    [146] => 
    [147] =>   [PhpParser\Error]
    [148] =>   Syntax error, unexpected , expecting T_STRING or T_FUNCTION or T_CONST or T_NS_SEPARATOR on line 7
    [149] => 
    [150] => 
    [151] => Exception trace:
    [152] =>   at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php:293
    [153] =>  PhpParser\ParserAbstract->parse() at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Parser/Multiple.php:54
    [154] =>  PhpParser\Parser\Multiple->tryParse() at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Parser/Multiple.php:34
    [155] =>  PhpParser\Parser\Multiple->parse() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Util/MutableSource.php:45
    [156] =>  SilverStripe\Upgrader\Util\MutableSource->__construct() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/ApiChangeWarningsRule.php:54
    [157] =>  SilverStripe\Upgrader\UpgradeRule\PHP\ApiChangeWarningsRule->upgradeFile() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Upgrader.php:61
    [158] =>  SilverStripe\Upgrader\Upgrader->upgrade() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Console/InspectCommand.php:88
    [159] =>  SilverStripe\Upgrader\Console\InspectCommand->execute() at /var/www/ss3/upgrader/vendor/symfony/console/Command/Command.php:255
    [160] =>  Symfony\Component\Console\Command\Command->run() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:1021
    [161] =>  Symfony\Component\Console\Application->doRunCommand() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:275
    [162] =>  Symfony\Component\Console\Application->doRun() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:149
    [163] =>  Symfony\Component\Console\Application->run() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code:55
    [164] => 
    [165] => inspect [-d|--root-dir ROOT-DIR] [-w|--write] [--skip-visibility] [--] <path>
    [166] => 
)


------------------------------------------------------------------------
To continue, please use the following parameter: startFrom=InspectAPIChanges-1
e.g. php runme.php startFrom=InspectAPIChanges-1
------------------------------------------------------------------------
            
# running php upgrade inspect see: https://github.com/silverstripe/silverstripe-upgrader
cd /var/www/upgrades/upgradeto4
php /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code inspect /var/www/upgrades/upgradeto4/payment_paypal/src  --root-dir=/var/www/upgrades/upgradeto4 --write -vvv
Array
(
    [0] => Running post-upgrade on "/var/www/upgrades/upgradeto4/payment_paypal/src"
    [1] => [2025-07-14 05:43:10] Applying ApiChangeWarningsRule to PayPalExpressCheckoutPaymentHandler.php...
    [2] => <?php
    [3] => 
    [4] => namespace Sunnysideup\PaymentPaypal;
    [5] => 
    [6] => 
    [7] => 
    [8] => 
    [9] => use SilverStripe\Control\Director;
    [10] => use SilverStripe\Control\Controller;
    [11] => use SilverStripe\Core\Config\Config;
    [12] => 
    [13] => 
    [14] => 
    [15] => /**
    [16] =>  * Handler for responses from the PayPal site
    [17] =>  */
    [18] => class PayPalExpressCheckoutPaymentHandler extends Controller
    [19] => {
    [20] =>     private static $url_segment = 'paypalexpresscheckoutpaymenthandler';
    [21] => 
    [22] =>     protected $payment = null; //only need to get this once
    [23] => 
    [24] =>     private static $allowed_actions = array(
    [25] =>         'confirm',
    [26] =>         'cancel'
    [27] =>     );
    [28] => 
    [29] =>     public function Link($action = null)
    [30] =>     {
    [31] =>         return Controller::join_links(
    [32] =>             Director::baseURL(),
    [33] =>             $this->Config()->get("url_segment"),
    [34] =>             $action
    [35] =>         );
    [36] =>     }
    [37] => 
    [38] =>     public function payment()
    [39] =>     {
    [40] =>         if ($this->payment) {
    [41] =>             return $this->payment;
    [42] =>         } elseif ($token = Controller::getRequest()->getVar('token')) {
    [43] =>             $payment =  PayPalExpressCheckoutPayment::get()
    [44] =>                 ->filter(
    [45] =>                     array(
    [46] =>                         "Token" => $token,
    [47] =>                         "Status" => "Incomplete"
    [48] =>                     )
    [49] =>                 )
    [50] =>                 ->first();
    [51] =>             $this->payment = $payment;
    [52] =>             $this->payment->init();
    [53] =>             return $this->payment;
    [54] =>         }
    [55] =>         return null;
    [56] =>     }
    [57] => 
    [58] =>     public function confirm($request)
    [59] =>     {
    [60] =>         //TODO: pretend the user confirmed, and skip straight to results. (check that this is allowed)
    [61] =>         //TODO: get updated shipping details from paypal??
    [62] =>         if ($payment = $this->payment()) {
    [63] =>             if ($pid = Controller::getRequest()->getVar('PayerID')) {
    [64] =>                 $payment->PayerID = $pid;
    [65] =>                 $payment->write();
    [66] =>                 $payment->confirmPayment();
    [67] =>             }
    [68] =>         } else {
    [69] =>             //something went wrong?	..perhaps trying to pay for a payment that has already been processed
    [70] =>         }
    [71] =>         $this->doRedirect();
    [72] =>         return;
    [73] =>     }
    [74] => 
    [75] =>     public function cancel($request)
    [76] =>     {
    [77] =>         if ($payment = $this->payment()) {
    [78] =>             //TODO: do API call to gather further information
    [79] =>             $payment->Status = "Failure";
    [80] =>             $payment->Message = _t('PayPalExpressCheckoutPayment.USERCANCELLED', "User cancelled");
    [81] =>             $payment->write();
    [82] =>         }
    [83] =>         $this->doRedirect();
    [84] =>         return;
    [85] =>     }
    [86] => 
    [87] =>     protected function doRedirect()
    [88] =>     {
    [89] =>         $payment = $this->payment();
    [90] =>         if ($payment && $obj = $payment->PaidObject()) {
    [91] =>             $this->redirect($obj->Link());
    [92] =>             return;
    [93] =>         }
    [94] =>         $this->redirect(Director::absoluteURL('home', true)); //TODO: make this customisable in Payment_Controllers
    [95] =>         return;
    [96] =>     }
    [97] => 
    [98] =>     public static function return_link()
    [99] =>     {
    [100] => 
    [101] =>         /**
    [102] =>          * ### @@@@ START REPLACEMENT @@@@ ###
    [103] =>          * WHY: automated upgrade
    [104] =>          * OLD: Config::inst()->get("
    [105] =>          * NEW: Config::inst()->get(" ...  (COMPLEX)
    [106] =>          * EXP: Check if you should be using Name::class here instead of hard-coded class.
    [107] =>          * ### @@@@ STOP REPLACEMENT @@@@ ###
    [108] =>          */
    [109] =>         return Director::absoluteURL(Config::inst()->get(PayPalExpressCheckoutPaymentHandler::class, "url_segment"), true) . "/confirm/";
    [110] =>     }
    [111] => 
    [112] =>     public static function cancel_link()
    [113] =>     {
    [114] => 
    [115] =>         /**
    [116] =>          * ### @@@@ START REPLACEMENT @@@@ ###
    [117] =>          * WHY: automated upgrade
    [118] =>          * OLD: Config::inst()->get("
    [119] =>          * NEW: Config::inst()->get(" ...  (COMPLEX)
    [120] =>          * EXP: Check if you should be using Name::class here instead of hard-coded class.
    [121] =>          * ### @@@@ STOP REPLACEMENT @@@@ ###
    [122] =>          */
    [123] =>         return Director::absoluteURL(Config::inst()->get(PayPalExpressCheckoutPaymentHandler::class, "url_segment"), true) . "/cancel/";
    [124] =>     }
    [125] =>     public static function complete_link()
    [126] =>     {
    [127] => 
    [128] =>         /**
    [129] =>          * ### @@@@ START REPLACEMENT @@@@ ###
    [130] =>          * WHY: automated upgrade
    [131] =>          * OLD: Config::inst()->get("
    [132] =>          * NEW: Config::inst()->get(" ...  (COMPLEX)
    [133] =>          * EXP: Check if you should be using Name::class here instead of hard-coded class.
    [134] =>          * ### @@@@ STOP REPLACEMENT @@@@ ###
    [135] =>          */
    [136] =>         return Director::absoluteURL(Config::inst()->get(PayPalExpressCheckoutPaymentHandler::class, "url_segment"), true) . "/confirm/";
    [137] =>     }
    [138] => }
    [139] => PHP Warning:  Undefined array key 265 in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Lexer.php on line 258
    [140] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 190
    [141] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 359
    [142] => PHP Warning:  Undefined array key 265 in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Lexer.php on line 258
    [143] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 190
    [144] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 359
    [145] => 
    [146] => In ParserAbstract.php line 293:
    [147] => 
    [148] =>   [PhpParser\Error]
    [149] =>   Syntax error, unexpected , expecting T_STRING or T_NS_SEPARATOR or '{' on line 3
    [150] => 
    [151] => 
    [152] => Exception trace:
    [153] =>   at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php:293
    [154] =>  PhpParser\ParserAbstract->parse() at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Parser/Multiple.php:54
    [155] =>  PhpParser\Parser\Multiple->tryParse() at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Parser/Multiple.php:34
    [156] =>  PhpParser\Parser\Multiple->parse() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Util/MutableSource.php:45
    [157] =>  SilverStripe\Upgrader\Util\MutableSource->__construct() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/ApiChangeWarningsRule.php:54
    [158] =>  SilverStripe\Upgrader\UpgradeRule\PHP\ApiChangeWarningsRule->upgradeFile() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Upgrader.php:61
    [159] =>  SilverStripe\Upgrader\Upgrader->upgrade() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Console/InspectCommand.php:88
    [160] =>  SilverStripe\Upgrader\Console\InspectCommand->execute() at /var/www/ss3/upgrader/vendor/symfony/console/Command/Command.php:255
    [161] =>  Symfony\Component\Console\Command\Command->run() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:1021
    [162] =>  Symfony\Component\Console\Application->doRunCommand() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:275
    [163] =>  Symfony\Component\Console\Application->doRun() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:149
    [164] =>  Symfony\Component\Console\Application->run() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code:55
    [165] => 
    [166] => inspect [-d|--root-dir ROOT-DIR] [-w|--write] [--skip-visibility] [--] <path>
    [167] => 
)


------------------------------------------------------------------------
To continue, please use the following parameter: startFrom=InspectAPIChanges-1
e.g. php runme.php startFrom=InspectAPIChanges-1
------------------------------------------------------------------------
            
# running php upgrade inspect see: https://github.com/silverstripe/silverstripe-upgrader
cd /var/www/upgrades/upgradeto4
php /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code inspect /var/www/upgrades/upgradeto4/payment_paypal/src  --root-dir=/var/www/upgrades/upgradeto4 --write -vvv
Array
(
    [0] => Running post-upgrade on "/var/www/upgrades/upgradeto4/payment_paypal/src"
    [1] => [2025-07-14 05:44:36] Applying ApiChangeWarningsRule to PayPalExpressCheckoutPaymentHandler.php...
    [2] => <?php
    [3] => 
    [4] => namespace Sunnysideup\PaymentPaypal;
    [5] => 
    [6] => 
    [7] => 
    [8] => 
    [9] => use SilverStripe\Control\Director;
    [10] => use SilverStripe\Control\Controller;
    [11] => use SilverStripe\Core\Config\Config;
    [12] => 
    [13] => 
    [14] => 
    [15] => /**
    [16] =>  * Handler for responses from the PayPal site
    [17] =>  */
    [18] => class PayPalExpressCheckoutPaymentHandler extends Controller
    [19] => {
    [20] =>     private static $url_segment = 'paypalexpresscheckoutpaymenthandler';
    [21] => 
    [22] =>     protected $payment = null; //only need to get this once
    [23] => 
    [24] =>     private static $allowed_actions = array(
    [25] =>         'confirm',
    [26] =>         'cancel'
    [27] =>     );
    [28] => 
    [29] =>     public function Link($action = null)
    [30] =>     {
    [31] =>         return Controller::join_links(
    [32] =>             Director::baseURL(),
    [33] =>             $this->Config()->get("url_segment"),
    [34] =>             $action
    [35] =>         );
    [36] =>     }
    [37] => 
    [38] =>     public function payment()
    [39] =>     {
    [40] =>         if ($this->payment) {
    [41] =>             return $this->payment;
    [42] =>         } elseif ($token = Controller::getRequest()->getVar('token')) {
    [43] =>             $payment =  PayPalExpressCheckoutPayment::get()
    [44] =>                 ->filter(
    [45] =>                     array(
    [46] =>                         "Token" => $token,
    [47] =>                         "Status" => "Incomplete"
    [48] =>                     )
    [49] =>                 )
    [50] =>                 ->first();
    [51] =>             $this->payment = $payment;
    [52] =>             $this->payment->init();
    [53] =>             return $this->payment;
    [54] =>         }
    [55] =>         return null;
    [56] =>     }
    [57] => 
    [58] =>     public function confirm($request)
    [59] =>     {
    [60] =>         //TODO: pretend the user confirmed, and skip straight to results. (check that this is allowed)
    [61] =>         //TODO: get updated shipping details from paypal??
    [62] =>         if ($payment = $this->payment()) {
    [63] =>             if ($pid = Controller::getRequest()->getVar('PayerID')) {
    [64] =>                 $payment->PayerID = $pid;
    [65] =>                 $payment->write();
    [66] =>                 $payment->confirmPayment();
    [67] =>             }
    [68] =>         } else {
    [69] =>             //something went wrong?	..perhaps trying to pay for a payment that has already been processed
    [70] =>         }
    [71] =>         $this->doRedirect();
    [72] =>         return;
    [73] =>     }
    [74] => 
    [75] =>     public function cancel($request)
    [76] =>     {
    [77] =>         if ($payment = $this->payment()) {
    [78] =>             //TODO: do API call to gather further information
    [79] =>             $payment->Status = "Failure";
    [80] =>             $payment->Message = _t('PayPalExpressCheckoutPayment.USERCANCELLED', "User cancelled");
    [81] =>             $payment->write();
    [82] =>         }
    [83] =>         $this->doRedirect();
    [84] =>         return;
    [85] =>     }
    [86] => 
    [87] =>     protected function doRedirect()
    [88] =>     {
    [89] =>         $payment = $this->payment();
    [90] =>         if ($payment && $obj = $payment->PaidObject()) {
    [91] =>             $this->redirect($obj->Link());
    [92] =>             return;
    [93] =>         }
    [94] =>         $this->redirect(Director::absoluteURL('home', true)); //TODO: make this customisable in Payment_Controllers
    [95] =>         return;
    [96] =>     }
    [97] => 
    [98] =>     public static function return_link()
    [99] =>     {
    [100] => 
    [101] =>         /**
    [102] =>          * ### @@@@ START REPLACEMENT @@@@ ###
    [103] =>          * WHY: automated upgrade
    [104] =>          * OLD: Config::inst()->get("
    [105] =>          * NEW: Config::inst()->get(" ...  (COMPLEX)
    [106] =>          * EXP: Check if you should be using Name::class here instead of hard-coded class.
    [107] =>          * ### @@@@ STOP REPLACEMENT @@@@ ###
    [108] =>          */
    [109] =>         return Director::absoluteURL(Config::inst()->get(PayPalExpressCheckoutPaymentHandler::class, "url_segment"), true) . "/confirm/";
    [110] =>     }
    [111] => 
    [112] =>     public static function cancel_link()
    [113] =>     {
    [114] => 
    [115] =>         /**
    [116] =>          * ### @@@@ START REPLACEMENT @@@@ ###
    [117] =>          * WHY: automated upgrade
    [118] =>          * OLD: Config::inst()->get("
    [119] =>          * NEW: Config::inst()->get(" ...  (COMPLEX)
    [120] =>          * EXP: Check if you should be using Name::class here instead of hard-coded class.
    [121] =>          * ### @@@@ STOP REPLACEMENT @@@@ ###
    [122] =>          */
    [123] =>         return Director::absoluteURL(Config::inst()->get(PayPalExpressCheckoutPaymentHandler::class, "url_segment"), true) . "/cancel/";
    [124] =>     }
    [125] =>     public static function complete_link()
    [126] =>     {
    [127] => 
    [128] =>         /**
    [129] =>          * ### @@@@ START REPLACEMENT @@@@ ###
    [130] =>          * WHY: automated upgrade
    [131] =>          * OLD: Config::inst()->get("
    [132] =>          * NEW: Config::inst()->get(" ...  (COMPLEX)
    [133] =>          * EXP: Check if you should be using Name::class here instead of hard-coded class.
    [134] =>          * ### @@@@ STOP REPLACEMENT @@@@ ###
    [135] =>          */
    [136] =>         return Director::absoluteURL(Config::inst()->get(PayPalExpressCheckoutPaymentHandler::class, "url_segment"), true) . "/confirm/";
    [137] =>     }
    [138] => }
    [139] => PHP Warning:  Undefined array key 265 in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Lexer.php on line 258
    [140] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 190
    [141] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 359
    [142] => PHP Warning:  Undefined array key 265 in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Lexer.php on line 258
    [143] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 190
    [144] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 359
    [145] => 
    [146] => In ParserAbstract.php line 293:
    [147] => 
    [148] =>   [PhpParser\Error]
    [149] =>   Syntax error, unexpected , expecting T_STRING or T_NS_SEPARATOR or '{' on line 3
    [150] => 
    [151] => 
    [152] => Exception trace:
    [153] =>   at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php:293
    [154] =>  PhpParser\ParserAbstract->parse() at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Parser/Multiple.php:54
    [155] =>  PhpParser\Parser\Multiple->tryParse() at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Parser/Multiple.php:34
    [156] =>  PhpParser\Parser\Multiple->parse() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Util/MutableSource.php:45
    [157] =>  SilverStripe\Upgrader\Util\MutableSource->__construct() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/ApiChangeWarningsRule.php:54
    [158] =>  SilverStripe\Upgrader\UpgradeRule\PHP\ApiChangeWarningsRule->upgradeFile() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Upgrader.php:61
    [159] =>  SilverStripe\Upgrader\Upgrader->upgrade() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Console/InspectCommand.php:88
    [160] =>  SilverStripe\Upgrader\Console\InspectCommand->execute() at /var/www/ss3/upgrader/vendor/symfony/console/Command/Command.php:255
    [161] =>  Symfony\Component\Console\Command\Command->run() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:1021
    [162] =>  Symfony\Component\Console\Application->doRunCommand() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:275
    [163] =>  Symfony\Component\Console\Application->doRun() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:149
    [164] =>  Symfony\Component\Console\Application->run() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code:55
    [165] => 
    [166] => inspect [-d|--root-dir ROOT-DIR] [-w|--write] [--skip-visibility] [--] <path>
    [167] => 
)


------------------------------------------------------------------------
To continue, please use the following parameter: startFrom=InspectAPIChanges-1
e.g. php runme.php startFrom=InspectAPIChanges-1
------------------------------------------------------------------------
            
# running php upgrade inspect see: https://github.com/silverstripe/silverstripe-upgrader
cd /var/www/upgrades/upgradeto4
php /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code inspect /var/www/upgrades/upgradeto4/payment_paypal/src  --root-dir=/var/www/upgrades/upgradeto4 --write -vvv
Array
(
    [0] => Running post-upgrade on "/var/www/upgrades/upgradeto4/payment_paypal/src"
    [1] => [2025-07-14 05:44:50] Applying ApiChangeWarningsRule to PayPalExpressCheckoutPaymentHandler.php...
    [2] => <?php
    [3] => 
    [4] => namespace Sunnysideup\PaymentPaypal;
    [5] => 
    [6] => 
    [7] => 
    [8] => 
    [9] => use SilverStripe\Control\Director;
    [10] => use SilverStripe\Control\Controller;
    [11] => use SilverStripe\Core\Config\Config;
    [12] => 
    [13] => 
    [14] => 
    [15] => /**
    [16] =>  * Handler for responses from the PayPal site
    [17] =>  */
    [18] => class PayPalExpressCheckoutPaymentHandler extends Controller
    [19] => {
    [20] =>     private static $url_segment = 'paypalexpresscheckoutpaymenthandler';
    [21] => 
    [22] =>     protected $payment = null; //only need to get this once
    [23] => 
    [24] =>     private static $allowed_actions = array(
    [25] =>         'confirm',
    [26] =>         'cancel'
    [27] =>     );
    [28] => 
    [29] =>     public function Link($action = null)
    [30] =>     {
    [31] =>         return Controller::join_links(
    [32] =>             Director::baseURL(),
    [33] =>             $this->Config()->get("url_segment"),
    [34] =>             $action
    [35] =>         );
    [36] =>     }
    [37] => 
    [38] =>     public function payment()
    [39] =>     {
    [40] =>         if ($this->payment) {
    [41] =>             return $this->payment;
    [42] =>         } elseif ($token = Controller::getRequest()->getVar('token')) {
    [43] =>             $payment =  PayPalExpressCheckoutPayment::get()
    [44] =>                 ->filter(
    [45] =>                     array(
    [46] =>                         "Token" => $token,
    [47] =>                         "Status" => "Incomplete"
    [48] =>                     )
    [49] =>                 )
    [50] =>                 ->first();
    [51] =>             $this->payment = $payment;
    [52] =>             $this->payment->init();
    [53] =>             return $this->payment;
    [54] =>         }
    [55] =>         return null;
    [56] =>     }
    [57] => 
    [58] =>     public function confirm($request)
    [59] =>     {
    [60] =>         //TODO: pretend the user confirmed, and skip straight to results. (check that this is allowed)
    [61] =>         //TODO: get updated shipping details from paypal??
    [62] =>         if ($payment = $this->payment()) {
    [63] =>             if ($pid = Controller::getRequest()->getVar('PayerID')) {
    [64] =>                 $payment->PayerID = $pid;
    [65] =>                 $payment->write();
    [66] =>                 $payment->confirmPayment();
    [67] =>             }
    [68] =>         } else {
    [69] =>             //something went wrong?	..perhaps trying to pay for a payment that has already been processed
    [70] =>         }
    [71] =>         $this->doRedirect();
    [72] =>         return;
    [73] =>     }
    [74] => 
    [75] =>     public function cancel($request)
    [76] =>     {
    [77] =>         if ($payment = $this->payment()) {
    [78] =>             //TODO: do API call to gather further information
    [79] =>             $payment->Status = "Failure";
    [80] =>             $payment->Message = _t('PayPalExpressCheckoutPayment.USERCANCELLED', "User cancelled");
    [81] =>             $payment->write();
    [82] =>         }
    [83] =>         $this->doRedirect();
    [84] =>         return;
    [85] =>     }
    [86] => 
    [87] =>     protected function doRedirect()
    [88] =>     {
    [89] =>         $payment = $this->payment();
    [90] =>         if ($payment && $obj = $payment->PaidObject()) {
    [91] =>             $this->redirect($obj->Link());
    [92] =>             return;
    [93] =>         }
    [94] =>         $this->redirect(Director::absoluteURL('home', true)); //TODO: make this customisable in Payment_Controllers
    [95] =>         return;
    [96] =>     }
    [97] => 
    [98] =>     public static function return_link()
    [99] =>     {
    [100] => 
    [101] =>         /**
    [102] =>          * ### @@@@ START REPLACEMENT @@@@ ###
    [103] =>          * WHY: automated upgrade
    [104] =>          * OLD: Config::inst()->get("
    [105] =>          * NEW: Config::inst()->get(" ...  (COMPLEX)
    [106] =>          * EXP: Check if you should be using Name::class here instead of hard-coded class.
    [107] =>          * ### @@@@ STOP REPLACEMENT @@@@ ###
    [108] =>          */
    [109] =>         return Director::absoluteURL(Config::inst()->get(PayPalExpressCheckoutPaymentHandler::class, "url_segment"), true) . "/confirm/";
    [110] =>     }
    [111] => 
    [112] =>     public static function cancel_link()
    [113] =>     {
    [114] => 
    [115] =>         /**
    [116] =>          * ### @@@@ START REPLACEMENT @@@@ ###
    [117] =>          * WHY: automated upgrade
    [118] =>          * OLD: Config::inst()->get("
    [119] =>          * NEW: Config::inst()->get(" ...  (COMPLEX)
    [120] =>          * EXP: Check if you should be using Name::class here instead of hard-coded class.
    [121] =>          * ### @@@@ STOP REPLACEMENT @@@@ ###
    [122] =>          */
    [123] =>         return Director::absoluteURL(Config::inst()->get(PayPalExpressCheckoutPaymentHandler::class, "url_segment"), true) . "/cancel/";
    [124] =>     }
    [125] =>     public static function complete_link()
    [126] =>     {
    [127] => 
    [128] =>         /**
    [129] =>          * ### @@@@ START REPLACEMENT @@@@ ###
    [130] =>          * WHY: automated upgrade
    [131] =>          * OLD: Config::inst()->get("
    [132] =>          * NEW: Config::inst()->get(" ...  (COMPLEX)
    [133] =>          * EXP: Check if you should be using Name::class here instead of hard-coded class.
    [134] =>          * ### @@@@ STOP REPLACEMENT @@@@ ###
    [135] =>          */
    [136] =>         return Director::absoluteURL(Config::inst()->get(PayPalExpressCheckoutPaymentHandler::class, "url_segment"), true) . "/confirm/";
    [137] =>     }
    [138] => }
    [139] => PHP Warning:  Undefined array key 265 in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Lexer.php on line 258
    [140] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 190
    [141] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 359
    [142] => PHP Warning:  Undefined array key 265 in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Lexer.php on line 258
    [143] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 190
    [144] => PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 359
    [145] => 
    [146] => In ParserAbstract.php line 293:
    [147] => 
    [148] =>   [PhpParser\Error]
    [149] =>   Syntax error, unexpected , expecting T_STRING or T_NS_SEPARATOR or '{' on line 3
    [150] => 
    [151] => 
    [152] => Exception trace:
    [153] =>   at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php:293
    [154] =>  PhpParser\ParserAbstract->parse() at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Parser/Multiple.php:54
    [155] =>  PhpParser\Parser\Multiple->tryParse() at /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Parser/Multiple.php:34
    [156] =>  PhpParser\Parser\Multiple->parse() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Util/MutableSource.php:45
    [157] =>  SilverStripe\Upgrader\Util\MutableSource->__construct() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/UpgradeRule/PHP/ApiChangeWarningsRule.php:54
    [158] =>  SilverStripe\Upgrader\UpgradeRule\PHP\ApiChangeWarningsRule->upgradeFile() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Upgrader.php:61
    [159] =>  SilverStripe\Upgrader\Upgrader->upgrade() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/src/Console/InspectCommand.php:88
    [160] =>  SilverStripe\Upgrader\Console\InspectCommand->execute() at /var/www/ss3/upgrader/vendor/symfony/console/Command/Command.php:255
    [161] =>  Symfony\Component\Console\Command\Command->run() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:1021
    [162] =>  Symfony\Component\Console\Application->doRunCommand() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:275
    [163] =>  Symfony\Component\Console\Application->doRun() at /var/www/ss3/upgrader/vendor/symfony/console/Application.php:149
    [164] =>  Symfony\Component\Console\Application->run() at /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code:55
    [165] => 
    [166] => inspect [-d|--root-dir ROOT-DIR] [-w|--write] [--skip-visibility] [--] <path>
    [167] => 
)


------------------------------------------------------------------------
To continue, please use the following parameter: startFrom=InspectAPIChanges-1
e.g. php runme.php startFrom=InspectAPIChanges-1
------------------------------------------------------------------------
            
# running php upgrade inspect see: https://github.com/silverstripe/silverstripe-upgrader
cd /var/www/upgrades/upgradeto4
php /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code inspect /var/www/upgrades/upgradeto4/payment_paypal/src  --root-dir=/var/www/upgrades/upgradeto4 --write -vvv
Writing changes for 0 files
Running post-upgrade on "/var/www/upgrades/upgradeto4/payment_paypal/src"
[2025-07-14 05:46:11] Applying ApiChangeWarningsRule to PayPalExpressCheckoutPaymentHandler.php...
<?php

namespace Sunnysideup\PaymentPaypal;




use SilverStripe\Control\Director;
use SilverStripe\Control\Controller;
use SilverStripe\Core\Config\Config;



/**
 * Handler for responses from the PayPal site
 */
class PayPalExpressCheckoutPaymentHandler extends Controller
{
    private static $url_segment = 'paypalexpresscheckoutpaymenthandler';

    protected $payment = null; //only need to get this once

    private static $allowed_actions = array(
        'confirm',
        'cancel'
    );

    public function Link($action = null)
    {
        return Controller::join_links(
            Director::baseURL(),
            $this->Config()->get("url_segment"),
            $action
        );
    }

    public function payment()
    {
        if ($this->payment) {
            return $this->payment;
        } elseif ($token = Controller::getRequest()->getVar('token')) {
            $payment =  PayPalExpressCheckoutPayment::get()
                ->filter(
                    array(
                        "Token" => $token,
                        "Status" => "Incomplete"
                    )
                )
                ->first();
            $this->payment = $payment;
            $this->payment->init();
            return $this->payment;
        }
        return null;
    }

    public function confirm($request)
    {
        //TODO: pretend the user confirmed, and skip straight to results. (check that this is allowed)
        //TODO: get updated shipping details from paypal??
        if ($payment = $this->payment()) {
            if ($pid = Controller::getRequest()->getVar('PayerID')) {
                $payment->PayerID = $pid;
                $payment->write();
                $payment->confirmPayment();
            }
        } else {
            //something went wrong?	..perhaps trying to pay for a payment that has already been processed
        }
        $this->doRedirect();
        return;
    }

    public function cancel($request)
    {
        if ($payment = $this->payment()) {
            //TODO: do API call to gather further information
            $payment->Status = "Failure";
            $payment->Message = _t('PayPalExpressCheckoutPayment.USERCANCELLED', "User cancelled");
            $payment->write();
        }
        $this->doRedirect();
        return;
    }

    protected function doRedirect()
    {
        $payment = $this->payment();
        if ($payment && $obj = $payment->PaidObject()) {
            $this->redirect($obj->Link());
            return;
        }
        $this->redirect(Director::absoluteURL('home', true)); //TODO: make this customisable in Payment_Controllers
        return;
    }

    public static function return_link()
    {

        /**
         * ### @@@@ START REPLACEMENT @@@@ ###
         * WHY: automated upgrade
         * OLD: Config::inst()->get("
         * NEW: Config::inst()->get(" ...  (COMPLEX)
         * EXP: Check if you should be using Name::class here instead of hard-coded class.
         * ### @@@@ STOP REPLACEMENT @@@@ ###
         */
        return Director::absoluteURL(Config::inst()->get(PayPalExpressCheckoutPaymentHandler::class, "url_segment"), true) . "/confirm/";
    }

    public static function cancel_link()
    {

        /**
         * ### @@@@ START REPLACEMENT @@@@ ###
         * WHY: automated upgrade
         * OLD: Config::inst()->get("
         * NEW: Config::inst()->get(" ...  (COMPLEX)
         * EXP: Check if you should be using Name::class here instead of hard-coded class.
         * ### @@@@ STOP REPLACEMENT @@@@ ###
         */
        return Director::absoluteURL(Config::inst()->get(PayPalExpressCheckoutPaymentHandler::class, "url_segment"), true) . "/cancel/";
    }
    public static function complete_link()
    {

        /**
         * ### @@@@ START REPLACEMENT @@@@ ###
         * WHY: automated upgrade
         * OLD: Config::inst()->get("
         * NEW: Config::inst()->get(" ...  (COMPLEX)
         * EXP: Check if you should be using Name::class here instead of hard-coded class.
         * ### @@@@ STOP REPLACEMENT @@@@ ###
         */
        return Director::absoluteURL(Config::inst()->get(PayPalExpressCheckoutPaymentHandler::class, "url_segment"), true) . "/confirm/";
    }
}
PHP Warning:  Undefined array key 265 in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Lexer.php on line 258
PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 194
PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 367
[2025-07-14 05:46:11] Applying UpdateVisibilityRule to PayPalExpressCheckoutPaymentHandler.php...
<?php

namespace Sunnysideup\PaymentPaypal;




use SilverStripe\Control\Director;
use SilverStripe\Control\Controller;
use SilverStripe\Core\Config\Config;



/**
 * Handler for responses from the PayPal site
 */
class PayPalExpressCheckoutPaymentHandler extends Controller
{
    private static $url_segment = 'paypalexpresscheckoutpaymenthandler';

    protected $payment = null; //only need to get this once

    private static $allowed_actions = array(
        'confirm',
        'cancel'
    );

    public function Link($action = null)
    {
        return Controller::join_links(
            Director::baseURL(),
            $this->Config()->get("url_segment"),
            $action
        );
    }

    public function payment()
    {
        if ($this->payment) {
            return $this->payment;
        } elseif ($token = Controller::getRequest()->getVar('token')) {
            $payment =  PayPalExpressCheckoutPayment::get()
                ->filter(
                    array(
                        "Token" => $token,
                        "Status" => "Incomplete"
                    )
                )
                ->first();
            $this->payment = $payment;
            $this->payment->init();
            return $this->payment;
        }
        return null;
    }

    public function confirm($request)
    {
        //TODO: pretend the user confirmed, and skip straight to results. (check that this is allowed)
        //TODO: get updated shipping details from paypal??
        if ($payment = $this->payment()) {
            if ($pid = Controller::getRequest()->getVar('PayerID')) {
                $payment->PayerID = $pid;
                $payment->write();
                $payment->confirmPayment();
            }
        } else {
            //something went wrong?	..perhaps trying to pay for a payment that has already been processed
        }
        $this->doRedirect();
        return;
    }

    public function cancel($request)
    {
        if ($payment = $this->payment()) {
            //TODO: do API call to gather further information
            $payment->Status = "Failure";
            $payment->Message = _t('PayPalExpressCheckoutPayment.USERCANCELLED', "User cancelled");
            $payment->write();
        }
        $this->doRedirect();
        return;
    }

    protected function doRedirect()
    {
        $payment = $this->payment();
        if ($payment && $obj = $payment->PaidObject()) {
            $this->redirect($obj->Link());
            return;
        }
        $this->redirect(Director::absoluteURL('home', true)); //TODO: make this customisable in Payment_Controllers
        return;
    }

    public static function return_link()
    {

        /**
         * ### @@@@ START REPLACEMENT @@@@ ###
         * WHY: automated upgrade
         * OLD: Config::inst()->get("
         * NEW: Config::inst()->get(" ...  (COMPLEX)
         * EXP: Check if you should be using Name::class here instead of hard-coded class.
         * ### @@@@ STOP REPLACEMENT @@@@ ###
         */
        return Director::absoluteURL(Config::inst()->get(PayPalExpressCheckoutPaymentHandler::class, "url_segment"), true) . "/confirm/";
    }

    public static function cancel_link()
    {

        /**
         * ### @@@@ START REPLACEMENT @@@@ ###
         * WHY: automated upgrade
         * OLD: Config::inst()->get("
         * NEW: Config::inst()->get(" ...  (COMPLEX)
         * EXP: Check if you should be using Name::class here instead of hard-coded class.
         * ### @@@@ STOP REPLACEMENT @@@@ ###
         */
        return Director::absoluteURL(Config::inst()->get(PayPalExpressCheckoutPaymentHandler::class, "url_segment"), true) . "/cancel/";
    }
    public static function complete_link()
    {

        /**
         * ### @@@@ START REPLACEMENT @@@@ ###
         * WHY: automated upgrade
         * OLD: Config::inst()->get("
         * NEW: Config::inst()->get(" ...  (COMPLEX)
         * EXP: Check if you should be using Name::class here instead of hard-coded class.
         * ### @@@@ STOP REPLACEMENT @@@@ ###
         */
        return Director::absoluteURL(Config::inst()->get(PayPalExpressCheckoutPaymentHandler::class, "url_segment"), true) . "/confirm/";
    }
}
PHP Warning:  Undefined array key 265 in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Lexer.php on line 258
PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 194
PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 367
[2025-07-14 05:46:11] Applying ApiChangeWarningsRule to PayPalExpressCheckoutPayment.php...
<?php

namespace Sunnysideup\PaymentPaypal;

use GuzzleHttp\Client;
use SilverStripe\Forms\LiteralField;
use SilverStripe\Forms\FieldList;
use SilverStripe\Control\Controller;
use SilverStripe\View\Requirements;
use SilverStripe\Control\Director;
use SilverStripe\Core\Convert;
use SilverStripe\SiteConfig\SiteConfig;
use SilverStripe\Core\Config\Config;
use Sunnysideup\Ecommerce\Model\Money\EcommercePayment;
use Sunnysideup\Ecommerce\Model\Order;
use Sunnysideup\Ecommerce\Money\Payment\PaymentResults\EcommercePaymentFailure;
use Sunnysideup\Ecommerce\Money\Payment\PaymentResults\EcommercePaymentProcessing;

/**
 * PayPal Express Checkout Payment
 * @author Jeremy Shipman jeremy [at] burnbright.net
 * @author Nicolaas [at] sunnysideup.co.nz
 *
 * Developer documentation:
 * Integration guide: https://cms.paypal.com/cms_content/US/en_US/files/developer/PP_ExpressCheckout_IntegrationGuide.pdf
 * API reference: 	  https://cms.paypal.com/us/cgi-bin/?cmd=_render-content&content_ID=developer/howto_api_reference
 * Uses the Name-Value Pair API protocol
 *
 */



class PayPalExpressCheckoutPayment extends EcommercePayment
{
    private static $debug = false;

    private static $continue_button_text = 'Continue to PayPal';

    /**
     * ### @@@@ START REPLACEMENT @@@@ ###
     * OLD: private static $db
     * EXP: Check that is class indeed extends DataObject and that it is not a data-extension!
     * ### @@@@ STOP REPLACEMENT @@@@ ###
     */

    private static $table_name = 'PayPalExpressCheckoutPayment';

    private static $db = array(
        'Token' => 'Varchar(30)',
        'PayerID' => 'Varchar(30)',
        'TransactionID' => 'Varchar(30)',
        'AuthorisationCode' => 'Text',
        'Debug' => 'HTMLText'
    );
    private static $logo = "ecommerce/images/paymentmethods/paypal.jpg";
    private static $payment_methods = [];

    //PayPal URLs
    private static $test_API_Endpoint = "https://api-3t.sandbox.paypal.com/nvp";
    private static $test_PAYPAL_URL = "https://www.sandbox.paypal.com/webscr?cmd=_express-checkout&token=";
    private static $API_Endpoint = "https://api-3t.paypal.com/nvp";
    private static $PAYPAL_URL = "https://www.paypal.com/cgi-bin/webscr?cmd=_express-checkout&token=";
    private static $privacy_link = "https://www.paypal.com/us/cgi-bin/webscr?cmd=p/gen/ua/policy_privacy-outside";

    //config
    private static $test_mode = true; //on by default
    private static $API_UserName;
    private static $API_Password;
    private static $API_Signature;
    private static $sBNCode = null; // BN Code 	is only applicable for partners
    private static $version = '64';

    //set custom settings
    private static $custom_settings = array(
        //design
        //'HDRIMG' => "http://www.mysite.com/images/logo.jpg", //max size = 750px wide by 90px high, and good to be on secure server
        //'HDRBORDERCOLOR' => 'CCCCCC', //header border
        //'HDRBACKCOLOR' => '00FFFF', //header background
        //'PAYFLOWCOLOR'=> 'AAAAAA' //payflow colour
        //'PAGESTYLE' => //page style set in merchant account settings
        'SOLUTIONTYPE' => 'Sole' //require paypal account, or not. Can be or 'Mark' (required) or 'Sole' (not required)
        //'BRANDNAME'  => 'my site name'//override business name in checkout
        //'CUSTOMERSERVICENUMBER' => '0800 1234 5689'//number to call to resolve payment issues
        //'NOSHIPPING' => 1 //disable showing shipping details
    );

    public function getCMSFields()
    {
        $fields = parent::getCMSFields();
        foreach (array_keys($this->config()->get('db')) as $field) {
            $fields->removeFieldFromTab('Root.Main', $field);
            $fields->addFieldToTab('Root.Advanced', LiteralField::create($field . '_debug', '<h2>' . $field . '</h2><pre>' . $this->$field . '</pre>'));
        }
        return $fields;
    }

    public function getPaymentFormFields($amount = 0, ?Order $order = null): FieldList
    {
        $logo = '<img src="' . $this->Config()->get("logo") . '" alt="Credit card payments powered by PayPal"/>';
        $privacyLink = '<a href="' . $this->Config()->get("privacy_link") . '" target="_blank" title="Read PayPal\'s privacy policy">' . $logo . '</a><br/>';
        return new FieldList(
            new LiteralField('PayPalInfo', $privacyLink),
            new LiteralField(
                'PayPalPaymentsList',

                /**
                 * ### @@@@ START REPLACEMENT @@@@ ###
                 * WHY: automated upgrade
                 * OLD: ->RenderWith( (ignore case)
                 * NEW: ->RenderWith( ...  (COMPLEX)
                 * EXP: Check that the template location is still valid!
                 * ### @@@@ STOP REPLACEMENT @@@@ ###
                 */
                $this->RenderWith("PaymentMethods")
            )
        );
    }

    public function getPaymentFormRequirements(): array
    {
        return [];
    }

    //main processing function
    public function processPayment($data, $form)
    {
        //sanity checks for credentials
        if (!$this->Config()->get("API_UserName") || !$this->Config()->get("API_Password") || !$this->Config()->get("API_Signature")) {
            user_error('You are attempting to make a payment without the necessary credentials set', E_USER_ERROR);
        }
        $data = $this->Order()->BillingAddress()->toMap();
        $paymenturl = $this->getTokenURL($this->Amount->Amount, $this->Amount->Currency, $data);
        $this->Status = "Incomplete";
        $this->write();
        if ($paymenturl) {
            Controller::curr()->redirect($paymenturl); //redirect to payment gateway
            return EcommercePaymentProcessing::create();
        }
        $this->Message = _t('PayPalExpressCheckoutPayment.COULDNOTBECONTACTED', "PayPal could not be contacted");
        $this->Status = 'Failure';
        $this->write();
        return EcommercePaymentFailure::create($this->Message);
    }

    /**
     * @deprecated
     */
    public function PayPalForm()
    {
        user_error("This form is no longer used.");

        /**
         * ### @@@@ START REPLACEMENT @@@@ ###
         * WHY: automated upgrade
         * OLD: THIRDPARTY_DIR . '/jquery/jquery.js'
         * EXP: Check for best usage and inclusion of Jquery
         * ### @@@@ STOP REPLACEMENT @@@@ ###
         */
        Requirements::javascript('sunnysideup/payment_paypal: silverstripe/admin: thirdparty/jquery/jquery.js');

        // 1) Main Information
        $fields = '';
        $order = $this->Order();
        $items = $order->Items();
        $member = $order->Member();

        // 2) Main Settings

        $url = $this->Config()->get("test_mode") ? $this->Config()->get("test_url") : $this->Config()->get("url");
        $inputs['cmd'] = '_cart';
        $inputs['upload'] = '1';

        // 3) Items Informations

        $cpt = 0;
        foreach ($items as $item) {
            $inputs['item_name_' . ++$cpt] = $item->TableTitle();
            // item_number is unnecessary
            $inputs['amount_' . $cpt] = $item->UnitPrice();
            $inputs['quantity_' . $cpt] = $item->Quantity;
        }

        // 4) Payment Informations And Authorisation Code

        $inputs['business'] = $this->Config()->get("test_mode") ? $this->Config()->get("test_account_email") : $this->Config()->get("account_email");
        $inputs['custom'] = $this->ID . '-' . $this->AuthorisationCode;
        // Add Here The Shipping And/Or Taxes
        $inputs['currency_code'] = $this->Currency;

        // 5) Redirection Informations

        $inputs['cancel_return'] = Director::absoluteBaseURL() . PayPalExpressCheckoutPaymentHandler::cancel_link($inputs['custom']);
        $inputs['return'] = Director::absoluteBaseURL() . PayPalExpressCheckoutPaymentHandler::complete_link();
        $inputs['rm'] = '2';
        // Add Here The Notify URL

        // 6) PayPal Pages Style Optional Informations

        if ($this->Config()->get("continue_button_text")) {
            $inputs['cbt'] = $this->Config()->get("continue_button_text");
        }

        if ($this->Config()->get("header_image_url")) {
            $inputs['cpp_header_image'] = urlencode($this->Config()->get("header_image_url"));
        }
        if ($this->Config()->get("header_back_color")) {
            $inputs['cpp_headerback_color'] = $this->Config()->get("header_back_color");
        }
        if ($this->Config()->get("header_border_color")) {
            $inputs['cpp_headerborder_color'] = $this->Config()->get("header_border_color");
        }
        if ($this->Config()->get("payflow_color")) {
            $inputs['cpp_payflow_color'] = $this->Config()->get("payflow_color");
        }
        if ($this->Config()->get("back_color")) {
            $inputs['cs'] = $this->Config()->get("back_color");
        }
        if ($this->Config()->get("image_url")) {
            $inputs['image_url'] = urlencode($this->Config()->get("image_url"));
        }
        if ($this->Config()->get("page_style")) {
            $inputs['page_style'] = $this->Config()->get("page_style");
        }

        // 7) Prepopulating Customer Informations
        $billingAddress = $order->BillingAddress();
        $inputs['first_name'] = $billingAddress->FirstName;
        $inputs['last_name'] = $billingAddress->Surname;
        $inputs['address1'] = $billingAddress->Address;
        $inputs['address2'] = $billingAddress->Address2;
        $inputs['city'] = $billingAddress->City;
        $inputs['zip'] = $billingAddress->PostalCode;
        $inputs['state'] = $billingAddress->Region()->Code;
        $inputs['country'] = $billingAddress->Country;
        $inputs['email'] = $member->Email;

        // 8) Form Creation
        if (is_array($inputs) && count($inputs)) {
            foreach ($inputs as $name => $value) {
                $ATT_value = Convert::raw2att($value);
                $fields .= "<input type=\"hidden\" name=\"$name\" value=\"$ATT_value\" />";
            }
        }

        return <<<HTML
            <form id="PaymentForm" method="post" action="$url">
                $fields
                <input type="submit" value="Submit" />
            </form>
            <script type="text/javascript">
                jQuery(document).ready(function() {
                    jQuery("input[type='submit']").hide();
                    jQuery('#PaymentForm').submit();
                });
            </script>
HTML;
    }

    public function populateDefaults()
    {
        parent::populateDefaults();
        $this->AuthorisationCode = md5(uniqid(rand(), true));
    }




    /**
     * Requests a Token url, based on the provided Name-Value-Pair fields
     * See docs for more detail on these fields:
     * https://cms.paypal.com/us/cgi-bin/?cmd=_render-content&content_ID=developer/e_howto_api_nvp_r_SetExpressCheckout
     *
     * Note: some of these values will override the paypal merchant account settings.
     * Note: not all fields are listed here.
     */
    protected function getTokenURL($paymentAmount, $currencyCodeType, $extradata = array())
    {
        $data = array(
            //payment info
            'PAYMENTREQUEST_0_AMT' => $paymentAmount,
            'PAYMENTREQUEST_0_CURRENCYCODE' => $currencyCodeType, //TODO: check to be sure all currency codes match the SS ones
            //TODO: include individual costs: shipping, shipping discount, insurance, handling, tax??
            //'PAYMENTREQUEST_0_ITEMAMT' => //item(s)
            //'PAYMENTREQUEST_0_SHIPPINGAMT' //shipping
            //'PAYMENTREQUEST_0_SHIPDISCAMT' //shipping discount
            //'PAYMENTREQUEST_0_HANDLINGAMT' //handling
            //'PAYMENTREQUEST_0_TAXAMT' //tax
            //'PAYMENTREQUEST_0_INVNUM' => $this->PaidObjectID //invoice number
            //'PAYMENTREQUEST_0_TRANSACTIONID' //Transaction id
            //'PAYMENTREQUEST_0_DESC' => //description
            //'PAYMENTREQUEST_0_NOTETEXT' => //note to merchant
            //'PAYMENTREQUEST_0_PAYMENTACTION' => , //Sale, Order, or Authorization
            //'PAYMENTREQUEST_0_PAYMENTREQUESTID'
            //return urls
            'RETURNURL' => PayPalExpressCheckoutPaymentHandler::return_link(),
            'CANCELURL' => PayPalExpressCheckoutPaymentHandler::cancel_link(),
            //'PAYMENTREQUEST_0_NOTIFYURL' => //Instant payment notification
            //'CALLBACK'
            //'CALLBACKTIMEOUT'
            //shipping display
            //'REQCONFIRMSHIPPING' //require that paypal account address be confirmed
            'NOSHIPPING' => 1, //show shipping fields, or not 0 = show shipping, 1 = don't show shipping, 2 = use account address, if none passed
            //'ALLOWOVERRIDE' //display only the provided address, not the one stored in paypal
            //TODO: Probably overkill, but you can even include the prices,qty,weight,tax etc for individual sale items
            //other settings
            //'LOCALECODE' => //locale, or default to US
            'LANDINGPAGE' => 'Billing' //can be 'Billing' or 'Login'
        );

        if (!isset($extradata['Name'])) {
            $arr =  array();
            if (isset($extradata['FirstName'])) {
                $arr[] = $extradata['FirstName'];
            }
            if (isset($extradata['MiddleName'])) {
                $arr[] = $extradata['MiddleName'];
            }
            if (isset($extradata['Surname'])) {
                $arr[] = $extradata['Surname'];
            }
            $extradata['Name'] = implode(' ', $arr);
        }
        $extradata["OrderID"] = SiteConfig::current_site_config()->Title . " " . $this->Order()->getTitle();
        //add member & shipping fields, etc ...this will pre-populate the paypal login / create account form
        foreach (
            array(
                'Email' => 'EMAIL',
                'Name' => 'PAYMENTREQUEST_0_SHIPTONAME',
                'Address' => 'PAYMENTREQUEST_0_SHIPTOSTREET',
                'Address2' => 'PAYMENTREQUEST_0_SHIPTOSTREET2',
                'City' => 'PAYMENTREQUEST_0_SHIPTOCITY',
                'PostalCode' => 'PAYMENTREQUEST_0_SHIPTOZIP',
                'Region' => 'PAYMENTREQUEST_0_SHIPTOPHONENUM',
                'Phone' => 'PAYMENTREQUEST_0_SHIPTOPHONENUM',
                'Country' => 'PAYMENTREQUEST_0_SHIPTOCOUNTRYCODE',
                'OrderID' => 'PAYMENTREQUEST_0_DESC'
            ) as $field => $val
        ) {
            if (isset($extradata[$field])) {
                $data[$val] = $extradata[$field];
            } elseif ($this->$field) {
                $data[$val] = $this->$field;
            }
        }
        //set design settings
        $data = array_merge($this->Config()->get("custom_settings"), $data);
        $response = $this->apiCall('SetExpressCheckout', $data);

        /**
         * ### @@@@ START REPLACEMENT @@@@ ###
         * WHY: automated upgrade
         * OLD: Config::inst()->get("
         * NEW: Config::inst()->get(" ...  (COMPLEX)
         * EXP: Check if you should be using Name::class here instead of hard-coded class.
         * ### @@@@ STOP REPLACEMENT @@@@ ###
         */
        $mode = ($this->Config()->get("test_mode") === true) ? "test" : "live";
        if (Config::inst()->get(PayPalExpressCheckoutPayment::class, "debug")) {
            $this->addDebugInfo("RESPONSE: " . print_r($response, 1));
            $debugmessage = "PayPal Debug:" .
                "\nMode: $mode" .
                "\nAPI url: " . $this->getApiEndpoint() .
                "\nRedirect url: " . $this->getPayPalURL($response['TOKEN']) .
                "\nUsername: " . $this->Config()->get("API_UserName") .
                "\nPassword: " . $this->Config()->get("API_Password") .
                "\nSignature: " . $this->Config()->get("API_Signature") .
                "\nRequest Data: " . print_r($data, true) .
                "\nResponse: " . print_r($response, true);
            $this->addDebugInfo("DEBUG MESSAGE: " . $debugmessage);
        }
        if (!isset($response['ACK']) ||  !(strtoupper($response['ACK']) == "SUCCESS" || strtoupper($response['ACK']) == "SUCCESSWITHWARNING")) {
            return null;
        }
        //get and save token for later
        $token = $response['TOKEN'];
        $this->Token = $token;
        $this->write();
        return $this->getPayPalURL($token);
    }

    /**
     * see https://cms.paypal.com/us/cgi-bin/?cmd=_render-content&content_ID=developer/e_howto_api_nvp_r_DoExpressCheckoutPayment
     */
    public function confirmPayment()
    {
        $data = array(
            'PAYERID' => $this->PayerID,
            'TOKEN' => $this->Token,
            'PAYMENTREQUEST_0_PAYMENTACTION' => "Sale",
            'PAYMENTREQUEST_0_AMT' => $this->Amount->Amount,
            'PAYMENTREQUEST_0_CURRENCYCODE' => $this->Amount->Currency,
            'IPADDRESS' => urlencode($_SERVER['SERVER_NAME'])
        );
        $response = $this->apiCall('DoExpressCheckoutPayment', $data);
        if (!isset($response['ACK']) ||  !(strtoupper($response['ACK']) == "SUCCESS" || strtoupper($response['ACK']) == "SUCCESSWITHWARNING")) {
            return null;
        }
        if (isset($response["PAYMENTINFO_0_TRANSACTIONID"])) {
            //' Unique transaction ID of the payment. Note:  If the PaymentAction of the request was Authorization or Order, this value is your AuthorizationID for use with the Authorization & Capture APIs.
            $this->TransactionID    = $response["PAYMENTINFO_0_TRANSACTIONID"];
        }
        //$transactionType 		= $response["PAYMENTINFO_0_TRANSACTIONTYPE"]; //' The type of transaction Possible values: l  cart l  express-checkout
        //$paymentType			= $response["PAYMENTTYPE"];  	//' Indicates whether the payment is instant or delayed. Possible values: l  none l  echeck l  instant
        //$orderTime 				= $response["ORDERTIME"];  		//' Time/date stamp of payment
        //TODO: should these be updated like this?
        //$this->Amount->Amount	= $response["AMT"];  			//' The final amount charged, including any shipping and taxes from your Merchant Profile.
        //$this->Amount->Currency= $response["CURRENCYCODE"];  	//' A three-character currency code for one of the currencies listed in PayPay-Supported Transactional Currencies. Default: USD.
        //TODO: store this extra info locally?
        //$feeAmt					= $response["FEEAMT"];  		//' PayPal fee amount charged for the transaction
        //$settleAmt				= $response["SETTLEAMT"];  		//' Amount deposited in your PayPal account after a currency conversion.
        //$taxAmt					= $response["TAXAMT"];  		//' Tax charged on the transaction.
        //$exchangeRate			= $response["EXCHANGERATE"];  	//' Exchange rate if a currency conversion occurred. Relevant only if your are billing in their non-primary currency. If the customer chooses to pay with a currency other than the non-primary currency, the conversion occurs in the customer's account.
        if (isset($response["PAYMENTINFO_0_PAYMENTSTATUS"])) {
            switch (strtoupper($response["PAYMENTINFO_0_PAYMENTSTATUS"])) {
                case "PROCESSED":
                case "COMPLETED":
                    $this->Status = 'Success';
                    $this->Message = _t('PayPalExpressCheckoutPayment.SUCCESS', "The payment has been completed, and the funds have been successfully transferred");
                    break;
                case "EXPIRED":
                    $this->Message = _t('PayPalExpressCheckoutPayment.AUTHORISATION', "The authorization period for this payment has been reached");
                    $this->Status = 'Failure';
                    break;
                case "DENIED":
                    $this->Message = _t('PayPalExpressCheckoutPayment.FAILURE', "Payment was denied");
                    $this->Status = 'Failure';
                    break;
                case "REVERSED":
                    $this->Status = 'Failure';
                    break;
                case "VOIDED":
                    $this->Message = _t('PayPalExpressCheckoutPayment.VOIDED', "An authorization for this transaction has been voided.");
                    $this->Status = 'Failure';
                    break;
                case "FAILED":
                    $this->Status = 'Failure';
                    break;
                case "CANCEL-REVERSAL": // A reversal has been canceled; for example, when you win a dispute and the funds for the reversal have been returned to you.
                    break;
                case "IN-PROGRESS":
                    $this->Message = _t('PayPalExpressCheckoutPayment.INPROGRESS', "The transaction has not terminated"); //, e.g. an authorization may be awaiting completion.";
                    break;
                case "PARTIALLY-REFUNDED":
                    $this->Message = _t('PayPalExpressCheckoutPayment.PARTIALLYREFUNDED', "The payment has been partially refunded.");
                    break;
                case "PENDING":
                    $this->Message = _t('PayPalExpressCheckoutPayment.PENDING', "The payment is pending.");
                    if (isset($response["PAYMENTINFO_0_PENDINGREASON"])) {
                        $this->Message .= " " . $this->getPendingReason($response["PAYMENTINFO_0_PENDINGREASON"]);
                    }
                    break;
                case "REFUNDED":
                    $this->Message = _t('PayPalExpressCheckoutPayment.REFUNDED', "Payment refunded.");
                    break;
                default:
            }
        }
        //$reasonCode		= $response["REASONCODE"];
        $this->write();
    }

    protected function getPendingReason($reason)
    {
        switch ($reason) {
            case "address":
                return _t('PayPalExpressCheckoutPayment.PENDING.ADDRESS', "A confirmed shipping address was not provided.");
            case "authorization":
                return _t('PayPalExpressCheckoutPayment.PENDING.AUTHORISATION', "Payment has been authorised, but not settled.");
            case "echeck":
                return _t('PayPalExpressCheckoutPayment.PENDING.ECHECK', "eCheck has not cleared.");
            case "intl":
                return _t('PayPalExpressCheckoutPayment.PENDING.INTERNATIONAL', "International: payment must be accepted or denied manually.");
            case "multicurrency":
                return _t('PayPalExpressCheckoutPayment.PENDING.MULTICURRENCY', "Multi-currency: payment must be accepted or denied manually.");
            case "order":
            case "paymentreview":
            case "unilateral":
            case "verify":
            case "other":
        }
    }

    /**
     * Handles actual communication with API server.
     */
    protected function apiCall($method, $data = array())
    {
        $this->addDebugInfo('---------------------------------------');
        $this->addDebugInfo('---------------------------------------');
        $this->addDebugInfo('---------------------------------------');
        $postfields = array(
            'METHOD' => $method,
            'VERSION' => $this->Config()->get("version"),
            'USER' => $this->Config()->get("API_UserName"),
            'PWD' => $this->Config()->get("API_Password"),
            'SIGNATURE' => $this->Config()->get("API_Signature"),
            'BUTTONSOURCE' => $this->Config()->get("sBNCode")
        );

        /**
         * ### @@@@ START REPLACEMENT @@@@ ###
         * WHY: automated upgrade
         * OLD: Config::inst()->get("
         * NEW: Config::inst()->get(" ...  (COMPLEX)
         * EXP: Check if you should be using Name::class here instead of hard-coded class.
         * ### @@@@ STOP REPLACEMENT @@@@ ###
         */
        if (Config::inst()->get(PayPalExpressCheckoutPayment::class, "debug")) {
            $this->addDebugInfo("STANDARD POSTING FIELDS ....  //// : " . print_r($postfields, 1));
            $this->addDebugInfo("ADDITIONAL POSTING FIELDS ....  //// : " . print_r($data, 1));
            $this->addDebugInfo("SENDING TO ....  //// : " . print_r($this->getApiEndpoint(), 1));
        }
        $postfields = array_merge($postfields, $data);
        //Make POST request to Paypal via RESTful service
        $client = new Client([
            'base_uri' => $this->getApiEndpoint(),
            'headers' => [
                'Accept' => 'application/xml',
                'Content-Type' => 'application/x-www-form-urlencoded',
            ],
            'timeout' => 10, // optional
        ]);

        $response = $client->post('', [
            'form_params' => $postfields,
        ]);

        // status and body:
        $status = $response->getStatusCode();
        $body = (string)$response->getBody();

        return [
            'status' => $status,
            'body' => $body,
        ];

        /**
         * ### @@@@ START REPLACEMENT @@@@ ###
         * WHY: automated upgrade
         * OLD: Config::inst()->get("
         * NEW: Config::inst()->get(" ...  (COMPLEX)
         * EXP: Check if you should be using Name::class here instead of hard-coded class.
         * ### @@@@ STOP REPLACEMENT @@@@ ###
         */
        if (Config::inst()->get(PayPalExpressCheckoutPayment::class, "debug")) {
            $this->addDebugInfo('RESPONSE ....  //// : ' . print_r($response, 1));
        }
        return $this->deformatNVP($response->getBody());
    }

    protected function deformatNVP($nvpstr)
    {
        $intial = 0;
        $nvpArray = [];
        while (strlen($nvpstr)) {
            //postion of Key
            $keypos = strpos($nvpstr, '=');
            //position of value
            $valuepos = strpos($nvpstr, '&') ? strpos($nvpstr, '&') : strlen($nvpstr);
            /*getting the Key and Value values and storing in a Associative Array*/
            $keyval = substr($nvpstr, $intial, $keypos);
            $valval = substr($nvpstr, $keypos + 1, $valuepos - $keypos - 1);
            //decoding the respose
            $nvpArray[urldecode($keyval)] = urldecode($valval);
            $nvpstr = substr($nvpstr, $valuepos + 1, strlen($nvpstr));
        }
        return $nvpArray;
    }

    protected function getApiEndpoint()
    {
        return ($this->Config()->get("test_mode") === true) ? $this->Config()->get("test_API_Endpoint") : $this->Config()->get("API_Endpoint");
    }

    protected function getPayPalURL($token)
    {
        $url = ($this->Config()->get("test_mode") === true) ? $this->Config()->get("test_PAYPAL_URL") : $this->Config()->get("PAYPAL_URL");
        return $url . $token . '&useraction=commit'; //useraction=commit ensures the payment is confirmed on PayPal, and not on a merchant confirm page.
    }


    protected function addDebugInfo($msg)
    {
        $this->Debug .= "---------//------------\n\n" . $msg;
        $this->write();
    }
}
PHP Warning:  Undefined array key 265 in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Lexer.php on line 258
PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 194
PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 367
[2025-07-14 05:46:11] Applying UpdateVisibilityRule to PayPalExpressCheckoutPayment.php...
<?php

namespace Sunnysideup\PaymentPaypal;

use GuzzleHttp\Client;
use SilverStripe\Forms\LiteralField;
use SilverStripe\Forms\FieldList;
use SilverStripe\Control\Controller;
use SilverStripe\View\Requirements;
use SilverStripe\Control\Director;
use SilverStripe\Core\Convert;
use SilverStripe\SiteConfig\SiteConfig;
use SilverStripe\Core\Config\Config;
use Sunnysideup\Ecommerce\Model\Money\EcommercePayment;
use Sunnysideup\Ecommerce\Model\Order;
use Sunnysideup\Ecommerce\Money\Payment\PaymentResults\EcommercePaymentFailure;
use Sunnysideup\Ecommerce\Money\Payment\PaymentResults\EcommercePaymentProcessing;

/**
 * PayPal Express Checkout Payment
 * @author Jeremy Shipman jeremy [at] burnbright.net
 * @author Nicolaas [at] sunnysideup.co.nz
 *
 * Developer documentation:
 * Integration guide: https://cms.paypal.com/cms_content/US/en_US/files/developer/PP_ExpressCheckout_IntegrationGuide.pdf
 * API reference: 	  https://cms.paypal.com/us/cgi-bin/?cmd=_render-content&content_ID=developer/howto_api_reference
 * Uses the Name-Value Pair API protocol
 *
 */



class PayPalExpressCheckoutPayment extends EcommercePayment
{
    private static $debug = false;

    private static $continue_button_text = 'Continue to PayPal';

    /**
     * ### @@@@ START REPLACEMENT @@@@ ###
     * OLD: private static $db
     * EXP: Check that is class indeed extends DataObject and that it is not a data-extension!
     * ### @@@@ STOP REPLACEMENT @@@@ ###
     */

    private static $table_name = 'PayPalExpressCheckoutPayment';

    private static $db = array(
        'Token' => 'Varchar(30)',
        'PayerID' => 'Varchar(30)',
        'TransactionID' => 'Varchar(30)',
        'AuthorisationCode' => 'Text',
        'Debug' => 'HTMLText'
    );
    private static $logo = "ecommerce/images/paymentmethods/paypal.jpg";
    private static $payment_methods = [];

    //PayPal URLs
    private static $test_API_Endpoint = "https://api-3t.sandbox.paypal.com/nvp";
    private static $test_PAYPAL_URL = "https://www.sandbox.paypal.com/webscr?cmd=_express-checkout&token=";
    private static $API_Endpoint = "https://api-3t.paypal.com/nvp";
    private static $PAYPAL_URL = "https://www.paypal.com/cgi-bin/webscr?cmd=_express-checkout&token=";
    private static $privacy_link = "https://www.paypal.com/us/cgi-bin/webscr?cmd=p/gen/ua/policy_privacy-outside";

    //config
    private static $test_mode = true; //on by default
    private static $API_UserName;
    private static $API_Password;
    private static $API_Signature;
    private static $sBNCode = null; // BN Code 	is only applicable for partners
    private static $version = '64';

    //set custom settings
    private static $custom_settings = array(
        //design
        //'HDRIMG' => "http://www.mysite.com/images/logo.jpg", //max size = 750px wide by 90px high, and good to be on secure server
        //'HDRBORDERCOLOR' => 'CCCCCC', //header border
        //'HDRBACKCOLOR' => '00FFFF', //header background
        //'PAYFLOWCOLOR'=> 'AAAAAA' //payflow colour
        //'PAGESTYLE' => //page style set in merchant account settings
        'SOLUTIONTYPE' => 'Sole' //require paypal account, or not. Can be or 'Mark' (required) or 'Sole' (not required)
        //'BRANDNAME'  => 'my site name'//override business name in checkout
        //'CUSTOMERSERVICENUMBER' => '0800 1234 5689'//number to call to resolve payment issues
        //'NOSHIPPING' => 1 //disable showing shipping details
    );

    public function getCMSFields()
    {
        $fields = parent::getCMSFields();
        foreach (array_keys($this->config()->get('db')) as $field) {
            $fields->removeFieldFromTab('Root.Main', $field);
            $fields->addFieldToTab('Root.Advanced', LiteralField::create($field . '_debug', '<h2>' . $field . '</h2><pre>' . $this->$field . '</pre>'));
        }
        return $fields;
    }

    public function getPaymentFormFields($amount = 0, ?Order $order = null): FieldList
    {
        $logo = '<img src="' . $this->Config()->get("logo") . '" alt="Credit card payments powered by PayPal"/>';
        $privacyLink = '<a href="' . $this->Config()->get("privacy_link") . '" target="_blank" title="Read PayPal\'s privacy policy">' . $logo . '</a><br/>';
        return new FieldList(
            new LiteralField('PayPalInfo', $privacyLink),
            new LiteralField(
                'PayPalPaymentsList',

                /**
                 * ### @@@@ START REPLACEMENT @@@@ ###
                 * WHY: automated upgrade
                 * OLD: ->RenderWith( (ignore case)
                 * NEW: ->RenderWith( ...  (COMPLEX)
                 * EXP: Check that the template location is still valid!
                 * ### @@@@ STOP REPLACEMENT @@@@ ###
                 */
                $this->RenderWith("PaymentMethods")
            )
        );
    }

    public function getPaymentFormRequirements(): array
    {
        return [];
    }

    //main processing function
    public function processPayment($data, $form)
    {
        //sanity checks for credentials
        if (!$this->Config()->get("API_UserName") || !$this->Config()->get("API_Password") || !$this->Config()->get("API_Signature")) {
            user_error('You are attempting to make a payment without the necessary credentials set', E_USER_ERROR);
        }
        $data = $this->Order()->BillingAddress()->toMap();
        $paymenturl = $this->getTokenURL($this->Amount->Amount, $this->Amount->Currency, $data);
        $this->Status = "Incomplete";
        $this->write();
        if ($paymenturl) {
            Controller::curr()->redirect($paymenturl); //redirect to payment gateway
            return EcommercePaymentProcessing::create();
        }
        $this->Message = _t('PayPalExpressCheckoutPayment.COULDNOTBECONTACTED', "PayPal could not be contacted");
        $this->Status = 'Failure';
        $this->write();
        return EcommercePaymentFailure::create($this->Message);
    }

    /**
     * @deprecated
     */
    public function PayPalForm()
    {
        user_error("This form is no longer used.");

        /**
         * ### @@@@ START REPLACEMENT @@@@ ###
         * WHY: automated upgrade
         * OLD: THIRDPARTY_DIR . '/jquery/jquery.js'
         * EXP: Check for best usage and inclusion of Jquery
         * ### @@@@ STOP REPLACEMENT @@@@ ###
         */
        Requirements::javascript('sunnysideup/payment_paypal: silverstripe/admin: thirdparty/jquery/jquery.js');

        // 1) Main Information
        $fields = '';
        $order = $this->Order();
        $items = $order->Items();
        $member = $order->Member();

        // 2) Main Settings

        $url = $this->Config()->get("test_mode") ? $this->Config()->get("test_url") : $this->Config()->get("url");
        $inputs['cmd'] = '_cart';
        $inputs['upload'] = '1';

        // 3) Items Informations

        $cpt = 0;
        foreach ($items as $item) {
            $inputs['item_name_' . ++$cpt] = $item->TableTitle();
            // item_number is unnecessary
            $inputs['amount_' . $cpt] = $item->UnitPrice();
            $inputs['quantity_' . $cpt] = $item->Quantity;
        }

        // 4) Payment Informations And Authorisation Code

        $inputs['business'] = $this->Config()->get("test_mode") ? $this->Config()->get("test_account_email") : $this->Config()->get("account_email");
        $inputs['custom'] = $this->ID . '-' . $this->AuthorisationCode;
        // Add Here The Shipping And/Or Taxes
        $inputs['currency_code'] = $this->Currency;

        // 5) Redirection Informations

        $inputs['cancel_return'] = Director::absoluteBaseURL() . PayPalExpressCheckoutPaymentHandler::cancel_link($inputs['custom']);
        $inputs['return'] = Director::absoluteBaseURL() . PayPalExpressCheckoutPaymentHandler::complete_link();
        $inputs['rm'] = '2';
        // Add Here The Notify URL

        // 6) PayPal Pages Style Optional Informations

        if ($this->Config()->get("continue_button_text")) {
            $inputs['cbt'] = $this->Config()->get("continue_button_text");
        }

        if ($this->Config()->get("header_image_url")) {
            $inputs['cpp_header_image'] = urlencode($this->Config()->get("header_image_url"));
        }
        if ($this->Config()->get("header_back_color")) {
            $inputs['cpp_headerback_color'] = $this->Config()->get("header_back_color");
        }
        if ($this->Config()->get("header_border_color")) {
            $inputs['cpp_headerborder_color'] = $this->Config()->get("header_border_color");
        }
        if ($this->Config()->get("payflow_color")) {
            $inputs['cpp_payflow_color'] = $this->Config()->get("payflow_color");
        }
        if ($this->Config()->get("back_color")) {
            $inputs['cs'] = $this->Config()->get("back_color");
        }
        if ($this->Config()->get("image_url")) {
            $inputs['image_url'] = urlencode($this->Config()->get("image_url"));
        }
        if ($this->Config()->get("page_style")) {
            $inputs['page_style'] = $this->Config()->get("page_style");
        }

        // 7) Prepopulating Customer Informations
        $billingAddress = $order->BillingAddress();
        $inputs['first_name'] = $billingAddress->FirstName;
        $inputs['last_name'] = $billingAddress->Surname;
        $inputs['address1'] = $billingAddress->Address;
        $inputs['address2'] = $billingAddress->Address2;
        $inputs['city'] = $billingAddress->City;
        $inputs['zip'] = $billingAddress->PostalCode;
        $inputs['state'] = $billingAddress->Region()->Code;
        $inputs['country'] = $billingAddress->Country;
        $inputs['email'] = $member->Email;

        // 8) Form Creation
        if (is_array($inputs) && count($inputs)) {
            foreach ($inputs as $name => $value) {
                $ATT_value = Convert::raw2att($value);
                $fields .= "<input type=\"hidden\" name=\"$name\" value=\"$ATT_value\" />";
            }
        }

        return <<<HTML
            <form id="PaymentForm" method="post" action="$url">
                $fields
                <input type="submit" value="Submit" />
            </form>
            <script type="text/javascript">
                jQuery(document).ready(function() {
                    jQuery("input[type='submit']").hide();
                    jQuery('#PaymentForm').submit();
                });
            </script>
HTML;
    }

    public function populateDefaults()
    {
        parent::populateDefaults();
        $this->AuthorisationCode = md5(uniqid(rand(), true));
    }




    /**
     * Requests a Token url, based on the provided Name-Value-Pair fields
     * See docs for more detail on these fields:
     * https://cms.paypal.com/us/cgi-bin/?cmd=_render-content&content_ID=developer/e_howto_api_nvp_r_SetExpressCheckout
     *
     * Note: some of these values will override the paypal merchant account settings.
     * Note: not all fields are listed here.
     */
    protected function getTokenURL($paymentAmount, $currencyCodeType, $extradata = array())
    {
        $data = array(
            //payment info
            'PAYMENTREQUEST_0_AMT' => $paymentAmount,
            'PAYMENTREQUEST_0_CURRENCYCODE' => $currencyCodeType, //TODO: check to be sure all currency codes match the SS ones
            //TODO: include individual costs: shipping, shipping discount, insurance, handling, tax??
            //'PAYMENTREQUEST_0_ITEMAMT' => //item(s)
            //'PAYMENTREQUEST_0_SHIPPINGAMT' //shipping
            //'PAYMENTREQUEST_0_SHIPDISCAMT' //shipping discount
            //'PAYMENTREQUEST_0_HANDLINGAMT' //handling
            //'PAYMENTREQUEST_0_TAXAMT' //tax
            //'PAYMENTREQUEST_0_INVNUM' => $this->PaidObjectID //invoice number
            //'PAYMENTREQUEST_0_TRANSACTIONID' //Transaction id
            //'PAYMENTREQUEST_0_DESC' => //description
            //'PAYMENTREQUEST_0_NOTETEXT' => //note to merchant
            //'PAYMENTREQUEST_0_PAYMENTACTION' => , //Sale, Order, or Authorization
            //'PAYMENTREQUEST_0_PAYMENTREQUESTID'
            //return urls
            'RETURNURL' => PayPalExpressCheckoutPaymentHandler::return_link(),
            'CANCELURL' => PayPalExpressCheckoutPaymentHandler::cancel_link(),
            //'PAYMENTREQUEST_0_NOTIFYURL' => //Instant payment notification
            //'CALLBACK'
            //'CALLBACKTIMEOUT'
            //shipping display
            //'REQCONFIRMSHIPPING' //require that paypal account address be confirmed
            'NOSHIPPING' => 1, //show shipping fields, or not 0 = show shipping, 1 = don't show shipping, 2 = use account address, if none passed
            //'ALLOWOVERRIDE' //display only the provided address, not the one stored in paypal
            //TODO: Probably overkill, but you can even include the prices,qty,weight,tax etc for individual sale items
            //other settings
            //'LOCALECODE' => //locale, or default to US
            'LANDINGPAGE' => 'Billing' //can be 'Billing' or 'Login'
        );

        if (!isset($extradata['Name'])) {
            $arr =  array();
            if (isset($extradata['FirstName'])) {
                $arr[] = $extradata['FirstName'];
            }
            if (isset($extradata['MiddleName'])) {
                $arr[] = $extradata['MiddleName'];
            }
            if (isset($extradata['Surname'])) {
                $arr[] = $extradata['Surname'];
            }
            $extradata['Name'] = implode(' ', $arr);
        }
        $extradata["OrderID"] = SiteConfig::current_site_config()->Title . " " . $this->Order()->getTitle();
        //add member & shipping fields, etc ...this will pre-populate the paypal login / create account form
        foreach (
            array(
                'Email' => 'EMAIL',
                'Name' => 'PAYMENTREQUEST_0_SHIPTONAME',
                'Address' => 'PAYMENTREQUEST_0_SHIPTOSTREET',
                'Address2' => 'PAYMENTREQUEST_0_SHIPTOSTREET2',
                'City' => 'PAYMENTREQUEST_0_SHIPTOCITY',
                'PostalCode' => 'PAYMENTREQUEST_0_SHIPTOZIP',
                'Region' => 'PAYMENTREQUEST_0_SHIPTOPHONENUM',
                'Phone' => 'PAYMENTREQUEST_0_SHIPTOPHONENUM',
                'Country' => 'PAYMENTREQUEST_0_SHIPTOCOUNTRYCODE',
                'OrderID' => 'PAYMENTREQUEST_0_DESC'
            ) as $field => $val
        ) {
            if (isset($extradata[$field])) {
                $data[$val] = $extradata[$field];
            } elseif ($this->$field) {
                $data[$val] = $this->$field;
            }
        }
        //set design settings
        $data = array_merge($this->Config()->get("custom_settings"), $data);
        $response = $this->apiCall('SetExpressCheckout', $data);

        /**
         * ### @@@@ START REPLACEMENT @@@@ ###
         * WHY: automated upgrade
         * OLD: Config::inst()->get("
         * NEW: Config::inst()->get(" ...  (COMPLEX)
         * EXP: Check if you should be using Name::class here instead of hard-coded class.
         * ### @@@@ STOP REPLACEMENT @@@@ ###
         */
        $mode = ($this->Config()->get("test_mode") === true) ? "test" : "live";
        if (Config::inst()->get(PayPalExpressCheckoutPayment::class, "debug")) {
            $this->addDebugInfo("RESPONSE: " . print_r($response, 1));
            $debugmessage = "PayPal Debug:" .
                "\nMode: $mode" .
                "\nAPI url: " . $this->getApiEndpoint() .
                "\nRedirect url: " . $this->getPayPalURL($response['TOKEN']) .
                "\nUsername: " . $this->Config()->get("API_UserName") .
                "\nPassword: " . $this->Config()->get("API_Password") .
                "\nSignature: " . $this->Config()->get("API_Signature") .
                "\nRequest Data: " . print_r($data, true) .
                "\nResponse: " . print_r($response, true);
            $this->addDebugInfo("DEBUG MESSAGE: " . $debugmessage);
        }
        if (!isset($response['ACK']) ||  !(strtoupper($response['ACK']) == "SUCCESS" || strtoupper($response['ACK']) == "SUCCESSWITHWARNING")) {
            return null;
        }
        //get and save token for later
        $token = $response['TOKEN'];
        $this->Token = $token;
        $this->write();
        return $this->getPayPalURL($token);
    }

    /**
     * see https://cms.paypal.com/us/cgi-bin/?cmd=_render-content&content_ID=developer/e_howto_api_nvp_r_DoExpressCheckoutPayment
     */
    public function confirmPayment()
    {
        $data = array(
            'PAYERID' => $this->PayerID,
            'TOKEN' => $this->Token,
            'PAYMENTREQUEST_0_PAYMENTACTION' => "Sale",
            'PAYMENTREQUEST_0_AMT' => $this->Amount->Amount,
            'PAYMENTREQUEST_0_CURRENCYCODE' => $this->Amount->Currency,
            'IPADDRESS' => urlencode($_SERVER['SERVER_NAME'])
        );
        $response = $this->apiCall('DoExpressCheckoutPayment', $data);
        if (!isset($response['ACK']) ||  !(strtoupper($response['ACK']) == "SUCCESS" || strtoupper($response['ACK']) == "SUCCESSWITHWARNING")) {
            return null;
        }
        if (isset($response["PAYMENTINFO_0_TRANSACTIONID"])) {
            //' Unique transaction ID of the payment. Note:  If the PaymentAction of the request was Authorization or Order, this value is your AuthorizationID for use with the Authorization & Capture APIs.
            $this->TransactionID    = $response["PAYMENTINFO_0_TRANSACTIONID"];
        }
        //$transactionType 		= $response["PAYMENTINFO_0_TRANSACTIONTYPE"]; //' The type of transaction Possible values: l  cart l  express-checkout
        //$paymentType			= $response["PAYMENTTYPE"];  	//' Indicates whether the payment is instant or delayed. Possible values: l  none l  echeck l  instant
        //$orderTime 				= $response["ORDERTIME"];  		//' Time/date stamp of payment
        //TODO: should these be updated like this?
        //$this->Amount->Amount	= $response["AMT"];  			//' The final amount charged, including any shipping and taxes from your Merchant Profile.
        //$this->Amount->Currency= $response["CURRENCYCODE"];  	//' A three-character currency code for one of the currencies listed in PayPay-Supported Transactional Currencies. Default: USD.
        //TODO: store this extra info locally?
        //$feeAmt					= $response["FEEAMT"];  		//' PayPal fee amount charged for the transaction
        //$settleAmt				= $response["SETTLEAMT"];  		//' Amount deposited in your PayPal account after a currency conversion.
        //$taxAmt					= $response["TAXAMT"];  		//' Tax charged on the transaction.
        //$exchangeRate			= $response["EXCHANGERATE"];  	//' Exchange rate if a currency conversion occurred. Relevant only if your are billing in their non-primary currency. If the customer chooses to pay with a currency other than the non-primary currency, the conversion occurs in the customer's account.
        if (isset($response["PAYMENTINFO_0_PAYMENTSTATUS"])) {
            switch (strtoupper($response["PAYMENTINFO_0_PAYMENTSTATUS"])) {
                case "PROCESSED":
                case "COMPLETED":
                    $this->Status = 'Success';
                    $this->Message = _t('PayPalExpressCheckoutPayment.SUCCESS', "The payment has been completed, and the funds have been successfully transferred");
                    break;
                case "EXPIRED":
                    $this->Message = _t('PayPalExpressCheckoutPayment.AUTHORISATION', "The authorization period for this payment has been reached");
                    $this->Status = 'Failure';
                    break;
                case "DENIED":
                    $this->Message = _t('PayPalExpressCheckoutPayment.FAILURE', "Payment was denied");
                    $this->Status = 'Failure';
                    break;
                case "REVERSED":
                    $this->Status = 'Failure';
                    break;
                case "VOIDED":
                    $this->Message = _t('PayPalExpressCheckoutPayment.VOIDED', "An authorization for this transaction has been voided.");
                    $this->Status = 'Failure';
                    break;
                case "FAILED":
                    $this->Status = 'Failure';
                    break;
                case "CANCEL-REVERSAL": // A reversal has been canceled; for example, when you win a dispute and the funds for the reversal have been returned to you.
                    break;
                case "IN-PROGRESS":
                    $this->Message = _t('PayPalExpressCheckoutPayment.INPROGRESS', "The transaction has not terminated"); //, e.g. an authorization may be awaiting completion.";
                    break;
                case "PARTIALLY-REFUNDED":
                    $this->Message = _t('PayPalExpressCheckoutPayment.PARTIALLYREFUNDED', "The payment has been partially refunded.");
                    break;
                case "PENDING":
                    $this->Message = _t('PayPalExpressCheckoutPayment.PENDING', "The payment is pending.");
                    if (isset($response["PAYMENTINFO_0_PENDINGREASON"])) {
                        $this->Message .= " " . $this->getPendingReason($response["PAYMENTINFO_0_PENDINGREASON"]);
                    }
                    break;
                case "REFUNDED":
                    $this->Message = _t('PayPalExpressCheckoutPayment.REFUNDED', "Payment refunded.");
                    break;
                default:
            }
        }
        //$reasonCode		= $response["REASONCODE"];
        $this->write();
    }

    protected function getPendingReason($reason)
    {
        switch ($reason) {
            case "address":
                return _t('PayPalExpressCheckoutPayment.PENDING.ADDRESS', "A confirmed shipping address was not provided.");
            case "authorization":
                return _t('PayPalExpressCheckoutPayment.PENDING.AUTHORISATION', "Payment has been authorised, but not settled.");
            case "echeck":
                return _t('PayPalExpressCheckoutPayment.PENDING.ECHECK', "eCheck has not cleared.");
            case "intl":
                return _t('PayPalExpressCheckoutPayment.PENDING.INTERNATIONAL', "International: payment must be accepted or denied manually.");
            case "multicurrency":
                return _t('PayPalExpressCheckoutPayment.PENDING.MULTICURRENCY', "Multi-currency: payment must be accepted or denied manually.");
            case "order":
            case "paymentreview":
            case "unilateral":
            case "verify":
            case "other":
        }
    }

    /**
     * Handles actual communication with API server.
     */
    protected function apiCall($method, $data = array())
    {
        $this->addDebugInfo('---------------------------------------');
        $this->addDebugInfo('---------------------------------------');
        $this->addDebugInfo('---------------------------------------');
        $postfields = array(
            'METHOD' => $method,
            'VERSION' => $this->Config()->get("version"),
            'USER' => $this->Config()->get("API_UserName"),
            'PWD' => $this->Config()->get("API_Password"),
            'SIGNATURE' => $this->Config()->get("API_Signature"),
            'BUTTONSOURCE' => $this->Config()->get("sBNCode")
        );

        /**
         * ### @@@@ START REPLACEMENT @@@@ ###
         * WHY: automated upgrade
         * OLD: Config::inst()->get("
         * NEW: Config::inst()->get(" ...  (COMPLEX)
         * EXP: Check if you should be using Name::class here instead of hard-coded class.
         * ### @@@@ STOP REPLACEMENT @@@@ ###
         */
        if (Config::inst()->get(PayPalExpressCheckoutPayment::class, "debug")) {
            $this->addDebugInfo("STANDARD POSTING FIELDS ....  //// : " . print_r($postfields, 1));
            $this->addDebugInfo("ADDITIONAL POSTING FIELDS ....  //// : " . print_r($data, 1));
            $this->addDebugInfo("SENDING TO ....  //// : " . print_r($this->getApiEndpoint(), 1));
        }
        $postfields = array_merge($postfields, $data);
        //Make POST request to Paypal via RESTful service
        $client = new Client([
            'base_uri' => $this->getApiEndpoint(),
            'headers' => [
                'Accept' => 'application/xml',
                'Content-Type' => 'application/x-www-form-urlencoded',
            ],
            'timeout' => 10, // optional
        ]);

        $response = $client->post('', [
            'form_params' => $postfields,
        ]);

        // status and body:
        $status = $response->getStatusCode();
        $body = (string)$response->getBody();

        return [
            'status' => $status,
            'body' => $body,
        ];

        /**
         * ### @@@@ START REPLACEMENT @@@@ ###
         * WHY: automated upgrade
         * OLD: Config::inst()->get("
         * NEW: Config::inst()->get(" ...  (COMPLEX)
         * EXP: Check if you should be using Name::class here instead of hard-coded class.
         * ### @@@@ STOP REPLACEMENT @@@@ ###
         */
        if (Config::inst()->get(PayPalExpressCheckoutPayment::class, "debug")) {
            $this->addDebugInfo('RESPONSE ....  //// : ' . print_r($response, 1));
        }
        return $this->deformatNVP($response->getBody());
    }

    protected function deformatNVP($nvpstr)
    {
        $intial = 0;
        $nvpArray = [];
        while (strlen($nvpstr)) {
            //postion of Key
            $keypos = strpos($nvpstr, '=');
            //position of value
            $valuepos = strpos($nvpstr, '&') ? strpos($nvpstr, '&') : strlen($nvpstr);
            /*getting the Key and Value values and storing in a Associative Array*/
            $keyval = substr($nvpstr, $intial, $keypos);
            $valval = substr($nvpstr, $keypos + 1, $valuepos - $keypos - 1);
            //decoding the respose
            $nvpArray[urldecode($keyval)] = urldecode($valval);
            $nvpstr = substr($nvpstr, $valuepos + 1, strlen($nvpstr));
        }
        return $nvpArray;
    }

    protected function getApiEndpoint()
    {
        return ($this->Config()->get("test_mode") === true) ? $this->Config()->get("test_API_Endpoint") : $this->Config()->get("API_Endpoint");
    }

    protected function getPayPalURL($token)
    {
        $url = ($this->Config()->get("test_mode") === true) ? $this->Config()->get("test_PAYPAL_URL") : $this->Config()->get("PAYPAL_URL");
        return $url . $token . '&useraction=commit'; //useraction=commit ensures the payment is confirmed on PayPal, and not on a merchant confirm page.
    }


    protected function addDebugInfo($msg)
    {
        $this->Debug .= "---------//------------\n\n" . $msg;
        $this->write();
    }
}
PHP Warning:  Undefined array key 265 in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Lexer.php on line 258
PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 194
PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 367
Writing changes for 0 files

# running php upgrade inspect see: https://github.com/silverstripe/silverstripe-upgrader
cd /var/www/upgrades/upgradeto4
php /var/www/ss3/upgrader/vendor/silverstripe/upgrader/bin/upgrade-code inspect /var/www/upgrades/upgradeto4/payment_paypal/src  --root-dir=/var/www/upgrades/upgradeto4 --write -vvv
Writing changes for 0 files
Running post-upgrade on "/var/www/upgrades/upgradeto4/payment_paypal/src"
[2025-07-14 05:46:35] Applying ApiChangeWarningsRule to PayPalExpressCheckoutPaymentHandler.php...
<?php

namespace Sunnysideup\PaymentPaypal;




use SilverStripe\Control\Director;
use SilverStripe\Control\Controller;
use SilverStripe\Core\Config\Config;



/**
 * Handler for responses from the PayPal site
 */
class PayPalExpressCheckoutPaymentHandler extends Controller
{
    private static $url_segment = 'paypalexpresscheckoutpaymenthandler';

    protected $payment = null; //only need to get this once

    private static $allowed_actions = array(
        'confirm',
        'cancel'
    );

    public function Link($action = null)
    {
        return Controller::join_links(
            Director::baseURL(),
            $this->Config()->get("url_segment"),
            $action
        );
    }

    public function payment()
    {
        if ($this->payment) {
            return $this->payment;
        } elseif ($token = Controller::getRequest()->getVar('token')) {
            $payment =  PayPalExpressCheckoutPayment::get()
                ->filter(
                    array(
                        "Token" => $token,
                        "Status" => "Incomplete"
                    )
                )
                ->first();
            $this->payment = $payment;
            $this->payment->init();
            return $this->payment;
        }
        return null;
    }

    public function confirm($request)
    {
        //TODO: pretend the user confirmed, and skip straight to results. (check that this is allowed)
        //TODO: get updated shipping details from paypal??
        if ($payment = $this->payment()) {
            if ($pid = Controller::getRequest()->getVar('PayerID')) {
                $payment->PayerID = $pid;
                $payment->write();
                $payment->confirmPayment();
            }
        } else {
            //something went wrong?	..perhaps trying to pay for a payment that has already been processed
        }
        $this->doRedirect();
        return;
    }

    public function cancel($request)
    {
        if ($payment = $this->payment()) {
            //TODO: do API call to gather further information
            $payment->Status = "Failure";
            $payment->Message = _t('PayPalExpressCheckoutPayment.USERCANCELLED', "User cancelled");
            $payment->write();
        }
        $this->doRedirect();
        return;
    }

    protected function doRedirect()
    {
        $payment = $this->payment();
        if ($payment && $obj = $payment->PaidObject()) {
            $this->redirect($obj->Link());
            return;
        }
        $this->redirect(Director::absoluteURL('home', true)); //TODO: make this customisable in Payment_Controllers
        return;
    }

    public static function return_link()
    {

        /**
         * ### @@@@ START REPLACEMENT @@@@ ###
         * WHY: automated upgrade
         * OLD: Config::inst()->get("
         * NEW: Config::inst()->get(" ...  (COMPLEX)
         * EXP: Check if you should be using Name::class here instead of hard-coded class.
         * ### @@@@ STOP REPLACEMENT @@@@ ###
         */
        return Director::absoluteURL(Config::inst()->get(PayPalExpressCheckoutPaymentHandler::class, "url_segment"), true) . "/confirm/";
    }

    public static function cancel_link()
    {

        /**
         * ### @@@@ START REPLACEMENT @@@@ ###
         * WHY: automated upgrade
         * OLD: Config::inst()->get("
         * NEW: Config::inst()->get(" ...  (COMPLEX)
         * EXP: Check if you should be using Name::class here instead of hard-coded class.
         * ### @@@@ STOP REPLACEMENT @@@@ ###
         */
        return Director::absoluteURL(Config::inst()->get(PayPalExpressCheckoutPaymentHandler::class, "url_segment"), true) . "/cancel/";
    }
    public static function complete_link()
    {

        /**
         * ### @@@@ START REPLACEMENT @@@@ ###
         * WHY: automated upgrade
         * OLD: Config::inst()->get("
         * NEW: Config::inst()->get(" ...  (COMPLEX)
         * EXP: Check if you should be using Name::class here instead of hard-coded class.
         * ### @@@@ STOP REPLACEMENT @@@@ ###
         */
        return Director::absoluteURL(Config::inst()->get(PayPalExpressCheckoutPaymentHandler::class, "url_segment"), true) . "/confirm/";
    }
}
PHP Warning:  Undefined array key 265 in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Lexer.php on line 258
PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 194
PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 367
[2025-07-14 05:46:35] Applying UpdateVisibilityRule to PayPalExpressCheckoutPaymentHandler.php...
<?php

namespace Sunnysideup\PaymentPaypal;




use SilverStripe\Control\Director;
use SilverStripe\Control\Controller;
use SilverStripe\Core\Config\Config;



/**
 * Handler for responses from the PayPal site
 */
class PayPalExpressCheckoutPaymentHandler extends Controller
{
    private static $url_segment = 'paypalexpresscheckoutpaymenthandler';

    protected $payment = null; //only need to get this once

    private static $allowed_actions = array(
        'confirm',
        'cancel'
    );

    public function Link($action = null)
    {
        return Controller::join_links(
            Director::baseURL(),
            $this->Config()->get("url_segment"),
            $action
        );
    }

    public function payment()
    {
        if ($this->payment) {
            return $this->payment;
        } elseif ($token = Controller::getRequest()->getVar('token')) {
            $payment =  PayPalExpressCheckoutPayment::get()
                ->filter(
                    array(
                        "Token" => $token,
                        "Status" => "Incomplete"
                    )
                )
                ->first();
            $this->payment = $payment;
            $this->payment->init();
            return $this->payment;
        }
        return null;
    }

    public function confirm($request)
    {
        //TODO: pretend the user confirmed, and skip straight to results. (check that this is allowed)
        //TODO: get updated shipping details from paypal??
        if ($payment = $this->payment()) {
            if ($pid = Controller::getRequest()->getVar('PayerID')) {
                $payment->PayerID = $pid;
                $payment->write();
                $payment->confirmPayment();
            }
        } else {
            //something went wrong?	..perhaps trying to pay for a payment that has already been processed
        }
        $this->doRedirect();
        return;
    }

    public function cancel($request)
    {
        if ($payment = $this->payment()) {
            //TODO: do API call to gather further information
            $payment->Status = "Failure";
            $payment->Message = _t('PayPalExpressCheckoutPayment.USERCANCELLED', "User cancelled");
            $payment->write();
        }
        $this->doRedirect();
        return;
    }

    protected function doRedirect()
    {
        $payment = $this->payment();
        if ($payment && $obj = $payment->PaidObject()) {
            $this->redirect($obj->Link());
            return;
        }
        $this->redirect(Director::absoluteURL('home', true)); //TODO: make this customisable in Payment_Controllers
        return;
    }

    public static function return_link()
    {

        /**
         * ### @@@@ START REPLACEMENT @@@@ ###
         * WHY: automated upgrade
         * OLD: Config::inst()->get("
         * NEW: Config::inst()->get(" ...  (COMPLEX)
         * EXP: Check if you should be using Name::class here instead of hard-coded class.
         * ### @@@@ STOP REPLACEMENT @@@@ ###
         */
        return Director::absoluteURL(Config::inst()->get(PayPalExpressCheckoutPaymentHandler::class, "url_segment"), true) . "/confirm/";
    }

    public static function cancel_link()
    {

        /**
         * ### @@@@ START REPLACEMENT @@@@ ###
         * WHY: automated upgrade
         * OLD: Config::inst()->get("
         * NEW: Config::inst()->get(" ...  (COMPLEX)
         * EXP: Check if you should be using Name::class here instead of hard-coded class.
         * ### @@@@ STOP REPLACEMENT @@@@ ###
         */
        return Director::absoluteURL(Config::inst()->get(PayPalExpressCheckoutPaymentHandler::class, "url_segment"), true) . "/cancel/";
    }
    public static function complete_link()
    {

        /**
         * ### @@@@ START REPLACEMENT @@@@ ###
         * WHY: automated upgrade
         * OLD: Config::inst()->get("
         * NEW: Config::inst()->get(" ...  (COMPLEX)
         * EXP: Check if you should be using Name::class here instead of hard-coded class.
         * ### @@@@ STOP REPLACEMENT @@@@ ###
         */
        return Director::absoluteURL(Config::inst()->get(PayPalExpressCheckoutPaymentHandler::class, "url_segment"), true) . "/confirm/";
    }
}
PHP Warning:  Undefined array key 265 in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Lexer.php on line 258
PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 194
PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 367
[2025-07-14 05:46:35] Applying ApiChangeWarningsRule to PayPalExpressCheckoutPayment.php...
<?php

namespace Sunnysideup\PaymentPaypal;

use GuzzleHttp\Client;
use SilverStripe\Forms\LiteralField;
use SilverStripe\Forms\FieldList;
use SilverStripe\Control\Controller;
use SilverStripe\View\Requirements;
use SilverStripe\Control\Director;
use SilverStripe\Core\Convert;
use SilverStripe\SiteConfig\SiteConfig;
use SilverStripe\Core\Config\Config;
use Sunnysideup\Ecommerce\Model\Money\EcommercePayment;
use Sunnysideup\Ecommerce\Model\Order;
use Sunnysideup\Ecommerce\Money\Payment\PaymentResults\EcommercePaymentFailure;
use Sunnysideup\Ecommerce\Money\Payment\PaymentResults\EcommercePaymentProcessing;

/**
 * PayPal Express Checkout Payment
 * @author Jeremy Shipman jeremy [at] burnbright.net
 * @author Nicolaas [at] sunnysideup.co.nz
 *
 * Developer documentation:
 * Integration guide: https://cms.paypal.com/cms_content/US/en_US/files/developer/PP_ExpressCheckout_IntegrationGuide.pdf
 * API reference: 	  https://cms.paypal.com/us/cgi-bin/?cmd=_render-content&content_ID=developer/howto_api_reference
 * Uses the Name-Value Pair API protocol
 *
 */



class PayPalExpressCheckoutPayment extends EcommercePayment
{
    private static $debug = false;

    private static $continue_button_text = 'Continue to PayPal';

    /**
     * ### @@@@ START REPLACEMENT @@@@ ###
     * OLD: private static $db
     * EXP: Check that is class indeed extends DataObject and that it is not a data-extension!
     * ### @@@@ STOP REPLACEMENT @@@@ ###
     */

    private static $table_name = 'PayPalExpressCheckoutPayment';

    private static $db = array(
        'Token' => 'Varchar(30)',
        'PayerID' => 'Varchar(30)',
        'TransactionID' => 'Varchar(30)',
        'AuthorisationCode' => 'Text',
        'Debug' => 'HTMLText'
    );
    private static $logo = "ecommerce/images/paymentmethods/paypal.jpg";
    private static $payment_methods = [];

    //PayPal URLs
    private static $test_API_Endpoint = "https://api-3t.sandbox.paypal.com/nvp";
    private static $test_PAYPAL_URL = "https://www.sandbox.paypal.com/webscr?cmd=_express-checkout&token=";
    private static $API_Endpoint = "https://api-3t.paypal.com/nvp";
    private static $PAYPAL_URL = "https://www.paypal.com/cgi-bin/webscr?cmd=_express-checkout&token=";
    private static $privacy_link = "https://www.paypal.com/us/cgi-bin/webscr?cmd=p/gen/ua/policy_privacy-outside";

    //config
    private static $test_mode = true; //on by default
    private static $API_UserName;
    private static $API_Password;
    private static $API_Signature;
    private static $sBNCode = null; // BN Code 	is only applicable for partners
    private static $version = '64';

    //set custom settings
    private static $custom_settings = array(
        //design
        //'HDRIMG' => "http://www.mysite.com/images/logo.jpg", //max size = 750px wide by 90px high, and good to be on secure server
        //'HDRBORDERCOLOR' => 'CCCCCC', //header border
        //'HDRBACKCOLOR' => '00FFFF', //header background
        //'PAYFLOWCOLOR'=> 'AAAAAA' //payflow colour
        //'PAGESTYLE' => //page style set in merchant account settings
        'SOLUTIONTYPE' => 'Sole' //require paypal account, or not. Can be or 'Mark' (required) or 'Sole' (not required)
        //'BRANDNAME'  => 'my site name'//override business name in checkout
        //'CUSTOMERSERVICENUMBER' => '0800 1234 5689'//number to call to resolve payment issues
        //'NOSHIPPING' => 1 //disable showing shipping details
    );

    public function getCMSFields()
    {
        $fields = parent::getCMSFields();
        foreach (array_keys($this->config()->get('db')) as $field) {
            $fields->removeFieldFromTab('Root.Main', $field);
            $fields->addFieldToTab('Root.Advanced', LiteralField::create($field . '_debug', '<h2>' . $field . '</h2><pre>' . $this->$field . '</pre>'));
        }
        return $fields;
    }

    public function getPaymentFormFields($amount = 0, ?Order $order = null): FieldList
    {
        $logo = '<img src="' . $this->Config()->get("logo") . '" alt="Credit card payments powered by PayPal"/>';
        $privacyLink = '<a href="' . $this->Config()->get("privacy_link") . '" target="_blank" title="Read PayPal\'s privacy policy">' . $logo . '</a><br/>';
        return new FieldList(
            new LiteralField('PayPalInfo', $privacyLink),
            new LiteralField(
                'PayPalPaymentsList',

                /**
                 * ### @@@@ START REPLACEMENT @@@@ ###
                 * WHY: automated upgrade
                 * OLD: ->RenderWith( (ignore case)
                 * NEW: ->RenderWith( ...  (COMPLEX)
                 * EXP: Check that the template location is still valid!
                 * ### @@@@ STOP REPLACEMENT @@@@ ###
                 */
                $this->RenderWith("PaymentMethods")
            )
        );
    }

    public function getPaymentFormRequirements(): array
    {
        return [];
    }

    //main processing function
    public function processPayment($data, $form)
    {
        //sanity checks for credentials
        if (!$this->Config()->get("API_UserName") || !$this->Config()->get("API_Password") || !$this->Config()->get("API_Signature")) {
            user_error('You are attempting to make a payment without the necessary credentials set', E_USER_ERROR);
        }
        $data = $this->Order()->BillingAddress()->toMap();
        $paymenturl = $this->getTokenURL($this->Amount->Amount, $this->Amount->Currency, $data);
        $this->Status = "Incomplete";
        $this->write();
        if ($paymenturl) {
            Controller::curr()->redirect($paymenturl); //redirect to payment gateway
            return EcommercePaymentProcessing::create();
        }
        $this->Message = _t('PayPalExpressCheckoutPayment.COULDNOTBECONTACTED', "PayPal could not be contacted");
        $this->Status = 'Failure';
        $this->write();
        return EcommercePaymentFailure::create($this->Message);
    }

    /**
     * @deprecated
     */
    public function PayPalForm()
    {
        user_error("This form is no longer used.");

        /**
         * ### @@@@ START REPLACEMENT @@@@ ###
         * WHY: automated upgrade
         * OLD: THIRDPARTY_DIR . '/jquery/jquery.js'
         * EXP: Check for best usage and inclusion of Jquery
         * ### @@@@ STOP REPLACEMENT @@@@ ###
         */
        Requirements::javascript('sunnysideup/payment_paypal: silverstripe/admin: thirdparty/jquery/jquery.js');

        // 1) Main Information
        $fields = '';
        $order = $this->Order();
        $items = $order->Items();
        $member = $order->Member();

        // 2) Main Settings

        $url = $this->Config()->get("test_mode") ? $this->Config()->get("test_url") : $this->Config()->get("url");
        $inputs['cmd'] = '_cart';
        $inputs['upload'] = '1';

        // 3) Items Informations

        $cpt = 0;
        foreach ($items as $item) {
            $inputs['item_name_' . ++$cpt] = $item->TableTitle();
            // item_number is unnecessary
            $inputs['amount_' . $cpt] = $item->UnitPrice();
            $inputs['quantity_' . $cpt] = $item->Quantity;
        }

        // 4) Payment Informations And Authorisation Code

        $inputs['business'] = $this->Config()->get("test_mode") ? $this->Config()->get("test_account_email") : $this->Config()->get("account_email");
        $inputs['custom'] = $this->ID . '-' . $this->AuthorisationCode;
        // Add Here The Shipping And/Or Taxes
        $inputs['currency_code'] = $this->Currency;

        // 5) Redirection Informations

        $inputs['cancel_return'] = Director::absoluteBaseURL() . PayPalExpressCheckoutPaymentHandler::cancel_link($inputs['custom']);
        $inputs['return'] = Director::absoluteBaseURL() . PayPalExpressCheckoutPaymentHandler::complete_link();
        $inputs['rm'] = '2';
        // Add Here The Notify URL

        // 6) PayPal Pages Style Optional Informations

        if ($this->Config()->get("continue_button_text")) {
            $inputs['cbt'] = $this->Config()->get("continue_button_text");
        }

        if ($this->Config()->get("header_image_url")) {
            $inputs['cpp_header_image'] = urlencode($this->Config()->get("header_image_url"));
        }
        if ($this->Config()->get("header_back_color")) {
            $inputs['cpp_headerback_color'] = $this->Config()->get("header_back_color");
        }
        if ($this->Config()->get("header_border_color")) {
            $inputs['cpp_headerborder_color'] = $this->Config()->get("header_border_color");
        }
        if ($this->Config()->get("payflow_color")) {
            $inputs['cpp_payflow_color'] = $this->Config()->get("payflow_color");
        }
        if ($this->Config()->get("back_color")) {
            $inputs['cs'] = $this->Config()->get("back_color");
        }
        if ($this->Config()->get("image_url")) {
            $inputs['image_url'] = urlencode($this->Config()->get("image_url"));
        }
        if ($this->Config()->get("page_style")) {
            $inputs['page_style'] = $this->Config()->get("page_style");
        }

        // 7) Prepopulating Customer Informations
        $billingAddress = $order->BillingAddress();
        $inputs['first_name'] = $billingAddress->FirstName;
        $inputs['last_name'] = $billingAddress->Surname;
        $inputs['address1'] = $billingAddress->Address;
        $inputs['address2'] = $billingAddress->Address2;
        $inputs['city'] = $billingAddress->City;
        $inputs['zip'] = $billingAddress->PostalCode;
        $inputs['state'] = $billingAddress->Region()->Code;
        $inputs['country'] = $billingAddress->Country;
        $inputs['email'] = $member->Email;

        // 8) Form Creation
        if (is_array($inputs) && count($inputs)) {
            foreach ($inputs as $name => $value) {
                $ATT_value = Convert::raw2att($value);
                $fields .= "<input type=\"hidden\" name=\"$name\" value=\"$ATT_value\" />";
            }
        }

        return <<<HTML
            <form id="PaymentForm" method="post" action="$url">
                $fields
                <input type="submit" value="Submit" />
            </form>
            <script type="text/javascript">
                jQuery(document).ready(function() {
                    jQuery("input[type='submit']").hide();
                    jQuery('#PaymentForm').submit();
                });
            </script>
HTML;
    }

    public function populateDefaults()
    {
        parent::populateDefaults();
        $this->AuthorisationCode = md5(uniqid(rand(), true));
    }




    /**
     * Requests a Token url, based on the provided Name-Value-Pair fields
     * See docs for more detail on these fields:
     * https://cms.paypal.com/us/cgi-bin/?cmd=_render-content&content_ID=developer/e_howto_api_nvp_r_SetExpressCheckout
     *
     * Note: some of these values will override the paypal merchant account settings.
     * Note: not all fields are listed here.
     */
    protected function getTokenURL($paymentAmount, $currencyCodeType, $extradata = array())
    {
        $data = array(
            //payment info
            'PAYMENTREQUEST_0_AMT' => $paymentAmount,
            'PAYMENTREQUEST_0_CURRENCYCODE' => $currencyCodeType, //TODO: check to be sure all currency codes match the SS ones
            //TODO: include individual costs: shipping, shipping discount, insurance, handling, tax??
            //'PAYMENTREQUEST_0_ITEMAMT' => //item(s)
            //'PAYMENTREQUEST_0_SHIPPINGAMT' //shipping
            //'PAYMENTREQUEST_0_SHIPDISCAMT' //shipping discount
            //'PAYMENTREQUEST_0_HANDLINGAMT' //handling
            //'PAYMENTREQUEST_0_TAXAMT' //tax
            //'PAYMENTREQUEST_0_INVNUM' => $this->PaidObjectID //invoice number
            //'PAYMENTREQUEST_0_TRANSACTIONID' //Transaction id
            //'PAYMENTREQUEST_0_DESC' => //description
            //'PAYMENTREQUEST_0_NOTETEXT' => //note to merchant
            //'PAYMENTREQUEST_0_PAYMENTACTION' => , //Sale, Order, or Authorization
            //'PAYMENTREQUEST_0_PAYMENTREQUESTID'
            //return urls
            'RETURNURL' => PayPalExpressCheckoutPaymentHandler::return_link(),
            'CANCELURL' => PayPalExpressCheckoutPaymentHandler::cancel_link(),
            //'PAYMENTREQUEST_0_NOTIFYURL' => //Instant payment notification
            //'CALLBACK'
            //'CALLBACKTIMEOUT'
            //shipping display
            //'REQCONFIRMSHIPPING' //require that paypal account address be confirmed
            'NOSHIPPING' => 1, //show shipping fields, or not 0 = show shipping, 1 = don't show shipping, 2 = use account address, if none passed
            //'ALLOWOVERRIDE' //display only the provided address, not the one stored in paypal
            //TODO: Probably overkill, but you can even include the prices,qty,weight,tax etc for individual sale items
            //other settings
            //'LOCALECODE' => //locale, or default to US
            'LANDINGPAGE' => 'Billing' //can be 'Billing' or 'Login'
        );

        if (!isset($extradata['Name'])) {
            $arr =  array();
            if (isset($extradata['FirstName'])) {
                $arr[] = $extradata['FirstName'];
            }
            if (isset($extradata['MiddleName'])) {
                $arr[] = $extradata['MiddleName'];
            }
            if (isset($extradata['Surname'])) {
                $arr[] = $extradata['Surname'];
            }
            $extradata['Name'] = implode(' ', $arr);
        }
        $extradata["OrderID"] = SiteConfig::current_site_config()->Title . " " . $this->Order()->getTitle();
        //add member & shipping fields, etc ...this will pre-populate the paypal login / create account form
        foreach (
            array(
                'Email' => 'EMAIL',
                'Name' => 'PAYMENTREQUEST_0_SHIPTONAME',
                'Address' => 'PAYMENTREQUEST_0_SHIPTOSTREET',
                'Address2' => 'PAYMENTREQUEST_0_SHIPTOSTREET2',
                'City' => 'PAYMENTREQUEST_0_SHIPTOCITY',
                'PostalCode' => 'PAYMENTREQUEST_0_SHIPTOZIP',
                'Region' => 'PAYMENTREQUEST_0_SHIPTOPHONENUM',
                'Phone' => 'PAYMENTREQUEST_0_SHIPTOPHONENUM',
                'Country' => 'PAYMENTREQUEST_0_SHIPTOCOUNTRYCODE',
                'OrderID' => 'PAYMENTREQUEST_0_DESC'
            ) as $field => $val
        ) {
            if (isset($extradata[$field])) {
                $data[$val] = $extradata[$field];
            } elseif ($this->$field) {
                $data[$val] = $this->$field;
            }
        }
        //set design settings
        $data = array_merge($this->Config()->get("custom_settings"), $data);
        $response = $this->apiCall('SetExpressCheckout', $data);

        /**
         * ### @@@@ START REPLACEMENT @@@@ ###
         * WHY: automated upgrade
         * OLD: Config::inst()->get("
         * NEW: Config::inst()->get(" ...  (COMPLEX)
         * EXP: Check if you should be using Name::class here instead of hard-coded class.
         * ### @@@@ STOP REPLACEMENT @@@@ ###
         */
        $mode = ($this->Config()->get("test_mode") === true) ? "test" : "live";
        if (Config::inst()->get(PayPalExpressCheckoutPayment::class, "debug")) {
            $this->addDebugInfo("RESPONSE: " . print_r($response, 1));
            $debugmessage = "PayPal Debug:" .
                "\nMode: $mode" .
                "\nAPI url: " . $this->getApiEndpoint() .
                "\nRedirect url: " . $this->getPayPalURL($response['TOKEN']) .
                "\nUsername: " . $this->Config()->get("API_UserName") .
                "\nPassword: " . $this->Config()->get("API_Password") .
                "\nSignature: " . $this->Config()->get("API_Signature") .
                "\nRequest Data: " . print_r($data, true) .
                "\nResponse: " . print_r($response, true);
            $this->addDebugInfo("DEBUG MESSAGE: " . $debugmessage);
        }
        if (!isset($response['ACK']) ||  !(strtoupper($response['ACK']) == "SUCCESS" || strtoupper($response['ACK']) == "SUCCESSWITHWARNING")) {
            return null;
        }
        //get and save token for later
        $token = $response['TOKEN'];
        $this->Token = $token;
        $this->write();
        return $this->getPayPalURL($token);
    }

    /**
     * see https://cms.paypal.com/us/cgi-bin/?cmd=_render-content&content_ID=developer/e_howto_api_nvp_r_DoExpressCheckoutPayment
     */
    public function confirmPayment()
    {
        $data = array(
            'PAYERID' => $this->PayerID,
            'TOKEN' => $this->Token,
            'PAYMENTREQUEST_0_PAYMENTACTION' => "Sale",
            'PAYMENTREQUEST_0_AMT' => $this->Amount->Amount,
            'PAYMENTREQUEST_0_CURRENCYCODE' => $this->Amount->Currency,
            'IPADDRESS' => urlencode($_SERVER['SERVER_NAME'])
        );
        $response = $this->apiCall('DoExpressCheckoutPayment', $data);
        if (!isset($response['ACK']) ||  !(strtoupper($response['ACK']) == "SUCCESS" || strtoupper($response['ACK']) == "SUCCESSWITHWARNING")) {
            return null;
        }
        if (isset($response["PAYMENTINFO_0_TRANSACTIONID"])) {
            //' Unique transaction ID of the payment. Note:  If the PaymentAction of the request was Authorization or Order, this value is your AuthorizationID for use with the Authorization & Capture APIs.
            $this->TransactionID    = $response["PAYMENTINFO_0_TRANSACTIONID"];
        }
        //$transactionType 		= $response["PAYMENTINFO_0_TRANSACTIONTYPE"]; //' The type of transaction Possible values: l  cart l  express-checkout
        //$paymentType			= $response["PAYMENTTYPE"];  	//' Indicates whether the payment is instant or delayed. Possible values: l  none l  echeck l  instant
        //$orderTime 				= $response["ORDERTIME"];  		//' Time/date stamp of payment
        //TODO: should these be updated like this?
        //$this->Amount->Amount	= $response["AMT"];  			//' The final amount charged, including any shipping and taxes from your Merchant Profile.
        //$this->Amount->Currency= $response["CURRENCYCODE"];  	//' A three-character currency code for one of the currencies listed in PayPay-Supported Transactional Currencies. Default: USD.
        //TODO: store this extra info locally?
        //$feeAmt					= $response["FEEAMT"];  		//' PayPal fee amount charged for the transaction
        //$settleAmt				= $response["SETTLEAMT"];  		//' Amount deposited in your PayPal account after a currency conversion.
        //$taxAmt					= $response["TAXAMT"];  		//' Tax charged on the transaction.
        //$exchangeRate			= $response["EXCHANGERATE"];  	//' Exchange rate if a currency conversion occurred. Relevant only if your are billing in their non-primary currency. If the customer chooses to pay with a currency other than the non-primary currency, the conversion occurs in the customer's account.
        if (isset($response["PAYMENTINFO_0_PAYMENTSTATUS"])) {
            switch (strtoupper($response["PAYMENTINFO_0_PAYMENTSTATUS"])) {
                case "PROCESSED":
                case "COMPLETED":
                    $this->Status = 'Success';
                    $this->Message = _t('PayPalExpressCheckoutPayment.SUCCESS', "The payment has been completed, and the funds have been successfully transferred");
                    break;
                case "EXPIRED":
                    $this->Message = _t('PayPalExpressCheckoutPayment.AUTHORISATION', "The authorization period for this payment has been reached");
                    $this->Status = 'Failure';
                    break;
                case "DENIED":
                    $this->Message = _t('PayPalExpressCheckoutPayment.FAILURE', "Payment was denied");
                    $this->Status = 'Failure';
                    break;
                case "REVERSED":
                    $this->Status = 'Failure';
                    break;
                case "VOIDED":
                    $this->Message = _t('PayPalExpressCheckoutPayment.VOIDED', "An authorization for this transaction has been voided.");
                    $this->Status = 'Failure';
                    break;
                case "FAILED":
                    $this->Status = 'Failure';
                    break;
                case "CANCEL-REVERSAL": // A reversal has been canceled; for example, when you win a dispute and the funds for the reversal have been returned to you.
                    break;
                case "IN-PROGRESS":
                    $this->Message = _t('PayPalExpressCheckoutPayment.INPROGRESS', "The transaction has not terminated"); //, e.g. an authorization may be awaiting completion.";
                    break;
                case "PARTIALLY-REFUNDED":
                    $this->Message = _t('PayPalExpressCheckoutPayment.PARTIALLYREFUNDED', "The payment has been partially refunded.");
                    break;
                case "PENDING":
                    $this->Message = _t('PayPalExpressCheckoutPayment.PENDING', "The payment is pending.");
                    if (isset($response["PAYMENTINFO_0_PENDINGREASON"])) {
                        $this->Message .= " " . $this->getPendingReason($response["PAYMENTINFO_0_PENDINGREASON"]);
                    }
                    break;
                case "REFUNDED":
                    $this->Message = _t('PayPalExpressCheckoutPayment.REFUNDED', "Payment refunded.");
                    break;
                default:
            }
        }
        //$reasonCode		= $response["REASONCODE"];
        $this->write();
    }

    protected function getPendingReason($reason)
    {
        switch ($reason) {
            case "address":
                return _t('PayPalExpressCheckoutPayment.PENDING.ADDRESS', "A confirmed shipping address was not provided.");
            case "authorization":
                return _t('PayPalExpressCheckoutPayment.PENDING.AUTHORISATION', "Payment has been authorised, but not settled.");
            case "echeck":
                return _t('PayPalExpressCheckoutPayment.PENDING.ECHECK', "eCheck has not cleared.");
            case "intl":
                return _t('PayPalExpressCheckoutPayment.PENDING.INTERNATIONAL', "International: payment must be accepted or denied manually.");
            case "multicurrency":
                return _t('PayPalExpressCheckoutPayment.PENDING.MULTICURRENCY', "Multi-currency: payment must be accepted or denied manually.");
            case "order":
            case "paymentreview":
            case "unilateral":
            case "verify":
            case "other":
        }
    }

    /**
     * Handles actual communication with API server.
     */
    protected function apiCall($method, $data = array())
    {
        $this->addDebugInfo('---------------------------------------');
        $this->addDebugInfo('---------------------------------------');
        $this->addDebugInfo('---------------------------------------');
        $postfields = array(
            'METHOD' => $method,
            'VERSION' => $this->Config()->get("version"),
            'USER' => $this->Config()->get("API_UserName"),
            'PWD' => $this->Config()->get("API_Password"),
            'SIGNATURE' => $this->Config()->get("API_Signature"),
            'BUTTONSOURCE' => $this->Config()->get("sBNCode")
        );

        /**
         * ### @@@@ START REPLACEMENT @@@@ ###
         * WHY: automated upgrade
         * OLD: Config::inst()->get("
         * NEW: Config::inst()->get(" ...  (COMPLEX)
         * EXP: Check if you should be using Name::class here instead of hard-coded class.
         * ### @@@@ STOP REPLACEMENT @@@@ ###
         */
        if (Config::inst()->get(PayPalExpressCheckoutPayment::class, "debug")) {
            $this->addDebugInfo("STANDARD POSTING FIELDS ....  //// : " . print_r($postfields, 1));
            $this->addDebugInfo("ADDITIONAL POSTING FIELDS ....  //// : " . print_r($data, 1));
            $this->addDebugInfo("SENDING TO ....  //// : " . print_r($this->getApiEndpoint(), 1));
        }
        $postfields = array_merge($postfields, $data);
        //Make POST request to Paypal via RESTful service
        $client = new Client([
            'base_uri' => $this->getApiEndpoint(),
            'headers' => [
                'Accept' => 'application/xml',
                'Content-Type' => 'application/x-www-form-urlencoded',
            ],
            'timeout' => 10, // optional
        ]);

        $response = $client->post('', [
            'form_params' => $postfields,
        ]);

        // status and body:
        $status = $response->getStatusCode();
        $body = (string)$response->getBody();

        return [
            'status' => $status,
            'body' => $body,
        ];

        /**
         * ### @@@@ START REPLACEMENT @@@@ ###
         * WHY: automated upgrade
         * OLD: Config::inst()->get("
         * NEW: Config::inst()->get(" ...  (COMPLEX)
         * EXP: Check if you should be using Name::class here instead of hard-coded class.
         * ### @@@@ STOP REPLACEMENT @@@@ ###
         */
        if (Config::inst()->get(PayPalExpressCheckoutPayment::class, "debug")) {
            $this->addDebugInfo('RESPONSE ....  //// : ' . print_r($response, 1));
        }
        return $this->deformatNVP($response->getBody());
    }

    protected function deformatNVP($nvpstr)
    {
        $intial = 0;
        $nvpArray = [];
        while (strlen($nvpstr)) {
            //postion of Key
            $keypos = strpos($nvpstr, '=');
            //position of value
            $valuepos = strpos($nvpstr, '&') ? strpos($nvpstr, '&') : strlen($nvpstr);
            /*getting the Key and Value values and storing in a Associative Array*/
            $keyval = substr($nvpstr, $intial, $keypos);
            $valval = substr($nvpstr, $keypos + 1, $valuepos - $keypos - 1);
            //decoding the respose
            $nvpArray[urldecode($keyval)] = urldecode($valval);
            $nvpstr = substr($nvpstr, $valuepos + 1, strlen($nvpstr));
        }
        return $nvpArray;
    }

    protected function getApiEndpoint()
    {
        return ($this->Config()->get("test_mode") === true) ? $this->Config()->get("test_API_Endpoint") : $this->Config()->get("API_Endpoint");
    }

    protected function getPayPalURL($token)
    {
        $url = ($this->Config()->get("test_mode") === true) ? $this->Config()->get("test_PAYPAL_URL") : $this->Config()->get("PAYPAL_URL");
        return $url . $token . '&useraction=commit'; //useraction=commit ensures the payment is confirmed on PayPal, and not on a merchant confirm page.
    }


    protected function addDebugInfo($msg)
    {
        $this->Debug .= "---------//------------\n\n" . $msg;
        $this->write();
    }
}
PHP Warning:  Undefined array key 265 in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Lexer.php on line 258
PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 194
PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 367
[2025-07-14 05:46:35] Applying UpdateVisibilityRule to PayPalExpressCheckoutPayment.php...
<?php

namespace Sunnysideup\PaymentPaypal;

use GuzzleHttp\Client;
use SilverStripe\Forms\LiteralField;
use SilverStripe\Forms\FieldList;
use SilverStripe\Control\Controller;
use SilverStripe\View\Requirements;
use SilverStripe\Control\Director;
use SilverStripe\Core\Convert;
use SilverStripe\SiteConfig\SiteConfig;
use SilverStripe\Core\Config\Config;
use Sunnysideup\Ecommerce\Model\Money\EcommercePayment;
use Sunnysideup\Ecommerce\Model\Order;
use Sunnysideup\Ecommerce\Money\Payment\PaymentResults\EcommercePaymentFailure;
use Sunnysideup\Ecommerce\Money\Payment\PaymentResults\EcommercePaymentProcessing;

/**
 * PayPal Express Checkout Payment
 * @author Jeremy Shipman jeremy [at] burnbright.net
 * @author Nicolaas [at] sunnysideup.co.nz
 *
 * Developer documentation:
 * Integration guide: https://cms.paypal.com/cms_content/US/en_US/files/developer/PP_ExpressCheckout_IntegrationGuide.pdf
 * API reference: 	  https://cms.paypal.com/us/cgi-bin/?cmd=_render-content&content_ID=developer/howto_api_reference
 * Uses the Name-Value Pair API protocol
 *
 */



class PayPalExpressCheckoutPayment extends EcommercePayment
{
    private static $debug = false;

    private static $continue_button_text = 'Continue to PayPal';

    /**
     * ### @@@@ START REPLACEMENT @@@@ ###
     * OLD: private static $db
     * EXP: Check that is class indeed extends DataObject and that it is not a data-extension!
     * ### @@@@ STOP REPLACEMENT @@@@ ###
     */

    private static $table_name = 'PayPalExpressCheckoutPayment';

    private static $db = array(
        'Token' => 'Varchar(30)',
        'PayerID' => 'Varchar(30)',
        'TransactionID' => 'Varchar(30)',
        'AuthorisationCode' => 'Text',
        'Debug' => 'HTMLText'
    );
    private static $logo = "ecommerce/images/paymentmethods/paypal.jpg";
    private static $payment_methods = [];

    //PayPal URLs
    private static $test_API_Endpoint = "https://api-3t.sandbox.paypal.com/nvp";
    private static $test_PAYPAL_URL = "https://www.sandbox.paypal.com/webscr?cmd=_express-checkout&token=";
    private static $API_Endpoint = "https://api-3t.paypal.com/nvp";
    private static $PAYPAL_URL = "https://www.paypal.com/cgi-bin/webscr?cmd=_express-checkout&token=";
    private static $privacy_link = "https://www.paypal.com/us/cgi-bin/webscr?cmd=p/gen/ua/policy_privacy-outside";

    //config
    private static $test_mode = true; //on by default
    private static $API_UserName;
    private static $API_Password;
    private static $API_Signature;
    private static $sBNCode = null; // BN Code 	is only applicable for partners
    private static $version = '64';

    //set custom settings
    private static $custom_settings = array(
        //design
        //'HDRIMG' => "http://www.mysite.com/images/logo.jpg", //max size = 750px wide by 90px high, and good to be on secure server
        //'HDRBORDERCOLOR' => 'CCCCCC', //header border
        //'HDRBACKCOLOR' => '00FFFF', //header background
        //'PAYFLOWCOLOR'=> 'AAAAAA' //payflow colour
        //'PAGESTYLE' => //page style set in merchant account settings
        'SOLUTIONTYPE' => 'Sole' //require paypal account, or not. Can be or 'Mark' (required) or 'Sole' (not required)
        //'BRANDNAME'  => 'my site name'//override business name in checkout
        //'CUSTOMERSERVICENUMBER' => '0800 1234 5689'//number to call to resolve payment issues
        //'NOSHIPPING' => 1 //disable showing shipping details
    );

    public function getCMSFields()
    {
        $fields = parent::getCMSFields();
        foreach (array_keys($this->config()->get('db')) as $field) {
            $fields->removeFieldFromTab('Root.Main', $field);
            $fields->addFieldToTab('Root.Advanced', LiteralField::create($field . '_debug', '<h2>' . $field . '</h2><pre>' . $this->$field . '</pre>'));
        }
        return $fields;
    }

    public function getPaymentFormFields($amount = 0, ?Order $order = null): FieldList
    {
        $logo = '<img src="' . $this->Config()->get("logo") . '" alt="Credit card payments powered by PayPal"/>';
        $privacyLink = '<a href="' . $this->Config()->get("privacy_link") . '" target="_blank" title="Read PayPal\'s privacy policy">' . $logo . '</a><br/>';
        return new FieldList(
            new LiteralField('PayPalInfo', $privacyLink),
            new LiteralField(
                'PayPalPaymentsList',

                /**
                 * ### @@@@ START REPLACEMENT @@@@ ###
                 * WHY: automated upgrade
                 * OLD: ->RenderWith( (ignore case)
                 * NEW: ->RenderWith( ...  (COMPLEX)
                 * EXP: Check that the template location is still valid!
                 * ### @@@@ STOP REPLACEMENT @@@@ ###
                 */
                $this->RenderWith("PaymentMethods")
            )
        );
    }

    public function getPaymentFormRequirements(): array
    {
        return [];
    }

    //main processing function
    public function processPayment($data, $form)
    {
        //sanity checks for credentials
        if (!$this->Config()->get("API_UserName") || !$this->Config()->get("API_Password") || !$this->Config()->get("API_Signature")) {
            user_error('You are attempting to make a payment without the necessary credentials set', E_USER_ERROR);
        }
        $data = $this->Order()->BillingAddress()->toMap();
        $paymenturl = $this->getTokenURL($this->Amount->Amount, $this->Amount->Currency, $data);
        $this->Status = "Incomplete";
        $this->write();
        if ($paymenturl) {
            Controller::curr()->redirect($paymenturl); //redirect to payment gateway
            return EcommercePaymentProcessing::create();
        }
        $this->Message = _t('PayPalExpressCheckoutPayment.COULDNOTBECONTACTED', "PayPal could not be contacted");
        $this->Status = 'Failure';
        $this->write();
        return EcommercePaymentFailure::create($this->Message);
    }

    /**
     * @deprecated
     */
    public function PayPalForm()
    {
        user_error("This form is no longer used.");

        /**
         * ### @@@@ START REPLACEMENT @@@@ ###
         * WHY: automated upgrade
         * OLD: THIRDPARTY_DIR . '/jquery/jquery.js'
         * EXP: Check for best usage and inclusion of Jquery
         * ### @@@@ STOP REPLACEMENT @@@@ ###
         */
        Requirements::javascript('sunnysideup/payment_paypal: silverstripe/admin: thirdparty/jquery/jquery.js');

        // 1) Main Information
        $fields = '';
        $order = $this->Order();
        $items = $order->Items();
        $member = $order->Member();

        // 2) Main Settings

        $url = $this->Config()->get("test_mode") ? $this->Config()->get("test_url") : $this->Config()->get("url");
        $inputs['cmd'] = '_cart';
        $inputs['upload'] = '1';

        // 3) Items Informations

        $cpt = 0;
        foreach ($items as $item) {
            $inputs['item_name_' . ++$cpt] = $item->TableTitle();
            // item_number is unnecessary
            $inputs['amount_' . $cpt] = $item->UnitPrice();
            $inputs['quantity_' . $cpt] = $item->Quantity;
        }

        // 4) Payment Informations And Authorisation Code

        $inputs['business'] = $this->Config()->get("test_mode") ? $this->Config()->get("test_account_email") : $this->Config()->get("account_email");
        $inputs['custom'] = $this->ID . '-' . $this->AuthorisationCode;
        // Add Here The Shipping And/Or Taxes
        $inputs['currency_code'] = $this->Currency;

        // 5) Redirection Informations

        $inputs['cancel_return'] = Director::absoluteBaseURL() . PayPalExpressCheckoutPaymentHandler::cancel_link($inputs['custom']);
        $inputs['return'] = Director::absoluteBaseURL() . PayPalExpressCheckoutPaymentHandler::complete_link();
        $inputs['rm'] = '2';
        // Add Here The Notify URL

        // 6) PayPal Pages Style Optional Informations

        if ($this->Config()->get("continue_button_text")) {
            $inputs['cbt'] = $this->Config()->get("continue_button_text");
        }

        if ($this->Config()->get("header_image_url")) {
            $inputs['cpp_header_image'] = urlencode($this->Config()->get("header_image_url"));
        }
        if ($this->Config()->get("header_back_color")) {
            $inputs['cpp_headerback_color'] = $this->Config()->get("header_back_color");
        }
        if ($this->Config()->get("header_border_color")) {
            $inputs['cpp_headerborder_color'] = $this->Config()->get("header_border_color");
        }
        if ($this->Config()->get("payflow_color")) {
            $inputs['cpp_payflow_color'] = $this->Config()->get("payflow_color");
        }
        if ($this->Config()->get("back_color")) {
            $inputs['cs'] = $this->Config()->get("back_color");
        }
        if ($this->Config()->get("image_url")) {
            $inputs['image_url'] = urlencode($this->Config()->get("image_url"));
        }
        if ($this->Config()->get("page_style")) {
            $inputs['page_style'] = $this->Config()->get("page_style");
        }

        // 7) Prepopulating Customer Informations
        $billingAddress = $order->BillingAddress();
        $inputs['first_name'] = $billingAddress->FirstName;
        $inputs['last_name'] = $billingAddress->Surname;
        $inputs['address1'] = $billingAddress->Address;
        $inputs['address2'] = $billingAddress->Address2;
        $inputs['city'] = $billingAddress->City;
        $inputs['zip'] = $billingAddress->PostalCode;
        $inputs['state'] = $billingAddress->Region()->Code;
        $inputs['country'] = $billingAddress->Country;
        $inputs['email'] = $member->Email;

        // 8) Form Creation
        if (is_array($inputs) && count($inputs)) {
            foreach ($inputs as $name => $value) {
                $ATT_value = Convert::raw2att($value);
                $fields .= "<input type=\"hidden\" name=\"$name\" value=\"$ATT_value\" />";
            }
        }

        return <<<HTML
            <form id="PaymentForm" method="post" action="$url">
                $fields
                <input type="submit" value="Submit" />
            </form>
            <script type="text/javascript">
                jQuery(document).ready(function() {
                    jQuery("input[type='submit']").hide();
                    jQuery('#PaymentForm').submit();
                });
            </script>
HTML;
    }

    public function populateDefaults()
    {
        parent::populateDefaults();
        $this->AuthorisationCode = md5(uniqid(rand(), true));
    }




    /**
     * Requests a Token url, based on the provided Name-Value-Pair fields
     * See docs for more detail on these fields:
     * https://cms.paypal.com/us/cgi-bin/?cmd=_render-content&content_ID=developer/e_howto_api_nvp_r_SetExpressCheckout
     *
     * Note: some of these values will override the paypal merchant account settings.
     * Note: not all fields are listed here.
     */
    protected function getTokenURL($paymentAmount, $currencyCodeType, $extradata = array())
    {
        $data = array(
            //payment info
            'PAYMENTREQUEST_0_AMT' => $paymentAmount,
            'PAYMENTREQUEST_0_CURRENCYCODE' => $currencyCodeType, //TODO: check to be sure all currency codes match the SS ones
            //TODO: include individual costs: shipping, shipping discount, insurance, handling, tax??
            //'PAYMENTREQUEST_0_ITEMAMT' => //item(s)
            //'PAYMENTREQUEST_0_SHIPPINGAMT' //shipping
            //'PAYMENTREQUEST_0_SHIPDISCAMT' //shipping discount
            //'PAYMENTREQUEST_0_HANDLINGAMT' //handling
            //'PAYMENTREQUEST_0_TAXAMT' //tax
            //'PAYMENTREQUEST_0_INVNUM' => $this->PaidObjectID //invoice number
            //'PAYMENTREQUEST_0_TRANSACTIONID' //Transaction id
            //'PAYMENTREQUEST_0_DESC' => //description
            //'PAYMENTREQUEST_0_NOTETEXT' => //note to merchant
            //'PAYMENTREQUEST_0_PAYMENTACTION' => , //Sale, Order, or Authorization
            //'PAYMENTREQUEST_0_PAYMENTREQUESTID'
            //return urls
            'RETURNURL' => PayPalExpressCheckoutPaymentHandler::return_link(),
            'CANCELURL' => PayPalExpressCheckoutPaymentHandler::cancel_link(),
            //'PAYMENTREQUEST_0_NOTIFYURL' => //Instant payment notification
            //'CALLBACK'
            //'CALLBACKTIMEOUT'
            //shipping display
            //'REQCONFIRMSHIPPING' //require that paypal account address be confirmed
            'NOSHIPPING' => 1, //show shipping fields, or not 0 = show shipping, 1 = don't show shipping, 2 = use account address, if none passed
            //'ALLOWOVERRIDE' //display only the provided address, not the one stored in paypal
            //TODO: Probably overkill, but you can even include the prices,qty,weight,tax etc for individual sale items
            //other settings
            //'LOCALECODE' => //locale, or default to US
            'LANDINGPAGE' => 'Billing' //can be 'Billing' or 'Login'
        );

        if (!isset($extradata['Name'])) {
            $arr =  array();
            if (isset($extradata['FirstName'])) {
                $arr[] = $extradata['FirstName'];
            }
            if (isset($extradata['MiddleName'])) {
                $arr[] = $extradata['MiddleName'];
            }
            if (isset($extradata['Surname'])) {
                $arr[] = $extradata['Surname'];
            }
            $extradata['Name'] = implode(' ', $arr);
        }
        $extradata["OrderID"] = SiteConfig::current_site_config()->Title . " " . $this->Order()->getTitle();
        //add member & shipping fields, etc ...this will pre-populate the paypal login / create account form
        foreach (
            array(
                'Email' => 'EMAIL',
                'Name' => 'PAYMENTREQUEST_0_SHIPTONAME',
                'Address' => 'PAYMENTREQUEST_0_SHIPTOSTREET',
                'Address2' => 'PAYMENTREQUEST_0_SHIPTOSTREET2',
                'City' => 'PAYMENTREQUEST_0_SHIPTOCITY',
                'PostalCode' => 'PAYMENTREQUEST_0_SHIPTOZIP',
                'Region' => 'PAYMENTREQUEST_0_SHIPTOPHONENUM',
                'Phone' => 'PAYMENTREQUEST_0_SHIPTOPHONENUM',
                'Country' => 'PAYMENTREQUEST_0_SHIPTOCOUNTRYCODE',
                'OrderID' => 'PAYMENTREQUEST_0_DESC'
            ) as $field => $val
        ) {
            if (isset($extradata[$field])) {
                $data[$val] = $extradata[$field];
            } elseif ($this->$field) {
                $data[$val] = $this->$field;
            }
        }
        //set design settings
        $data = array_merge($this->Config()->get("custom_settings"), $data);
        $response = $this->apiCall('SetExpressCheckout', $data);

        /**
         * ### @@@@ START REPLACEMENT @@@@ ###
         * WHY: automated upgrade
         * OLD: Config::inst()->get("
         * NEW: Config::inst()->get(" ...  (COMPLEX)
         * EXP: Check if you should be using Name::class here instead of hard-coded class.
         * ### @@@@ STOP REPLACEMENT @@@@ ###
         */
        $mode = ($this->Config()->get("test_mode") === true) ? "test" : "live";
        if (Config::inst()->get(PayPalExpressCheckoutPayment::class, "debug")) {
            $this->addDebugInfo("RESPONSE: " . print_r($response, 1));
            $debugmessage = "PayPal Debug:" .
                "\nMode: $mode" .
                "\nAPI url: " . $this->getApiEndpoint() .
                "\nRedirect url: " . $this->getPayPalURL($response['TOKEN']) .
                "\nUsername: " . $this->Config()->get("API_UserName") .
                "\nPassword: " . $this->Config()->get("API_Password") .
                "\nSignature: " . $this->Config()->get("API_Signature") .
                "\nRequest Data: " . print_r($data, true) .
                "\nResponse: " . print_r($response, true);
            $this->addDebugInfo("DEBUG MESSAGE: " . $debugmessage);
        }
        if (!isset($response['ACK']) ||  !(strtoupper($response['ACK']) == "SUCCESS" || strtoupper($response['ACK']) == "SUCCESSWITHWARNING")) {
            return null;
        }
        //get and save token for later
        $token = $response['TOKEN'];
        $this->Token = $token;
        $this->write();
        return $this->getPayPalURL($token);
    }

    /**
     * see https://cms.paypal.com/us/cgi-bin/?cmd=_render-content&content_ID=developer/e_howto_api_nvp_r_DoExpressCheckoutPayment
     */
    public function confirmPayment()
    {
        $data = array(
            'PAYERID' => $this->PayerID,
            'TOKEN' => $this->Token,
            'PAYMENTREQUEST_0_PAYMENTACTION' => "Sale",
            'PAYMENTREQUEST_0_AMT' => $this->Amount->Amount,
            'PAYMENTREQUEST_0_CURRENCYCODE' => $this->Amount->Currency,
            'IPADDRESS' => urlencode($_SERVER['SERVER_NAME'])
        );
        $response = $this->apiCall('DoExpressCheckoutPayment', $data);
        if (!isset($response['ACK']) ||  !(strtoupper($response['ACK']) == "SUCCESS" || strtoupper($response['ACK']) == "SUCCESSWITHWARNING")) {
            return null;
        }
        if (isset($response["PAYMENTINFO_0_TRANSACTIONID"])) {
            //' Unique transaction ID of the payment. Note:  If the PaymentAction of the request was Authorization or Order, this value is your AuthorizationID for use with the Authorization & Capture APIs.
            $this->TransactionID    = $response["PAYMENTINFO_0_TRANSACTIONID"];
        }
        //$transactionType 		= $response["PAYMENTINFO_0_TRANSACTIONTYPE"]; //' The type of transaction Possible values: l  cart l  express-checkout
        //$paymentType			= $response["PAYMENTTYPE"];  	//' Indicates whether the payment is instant or delayed. Possible values: l  none l  echeck l  instant
        //$orderTime 				= $response["ORDERTIME"];  		//' Time/date stamp of payment
        //TODO: should these be updated like this?
        //$this->Amount->Amount	= $response["AMT"];  			//' The final amount charged, including any shipping and taxes from your Merchant Profile.
        //$this->Amount->Currency= $response["CURRENCYCODE"];  	//' A three-character currency code for one of the currencies listed in PayPay-Supported Transactional Currencies. Default: USD.
        //TODO: store this extra info locally?
        //$feeAmt					= $response["FEEAMT"];  		//' PayPal fee amount charged for the transaction
        //$settleAmt				= $response["SETTLEAMT"];  		//' Amount deposited in your PayPal account after a currency conversion.
        //$taxAmt					= $response["TAXAMT"];  		//' Tax charged on the transaction.
        //$exchangeRate			= $response["EXCHANGERATE"];  	//' Exchange rate if a currency conversion occurred. Relevant only if your are billing in their non-primary currency. If the customer chooses to pay with a currency other than the non-primary currency, the conversion occurs in the customer's account.
        if (isset($response["PAYMENTINFO_0_PAYMENTSTATUS"])) {
            switch (strtoupper($response["PAYMENTINFO_0_PAYMENTSTATUS"])) {
                case "PROCESSED":
                case "COMPLETED":
                    $this->Status = 'Success';
                    $this->Message = _t('PayPalExpressCheckoutPayment.SUCCESS', "The payment has been completed, and the funds have been successfully transferred");
                    break;
                case "EXPIRED":
                    $this->Message = _t('PayPalExpressCheckoutPayment.AUTHORISATION', "The authorization period for this payment has been reached");
                    $this->Status = 'Failure';
                    break;
                case "DENIED":
                    $this->Message = _t('PayPalExpressCheckoutPayment.FAILURE', "Payment was denied");
                    $this->Status = 'Failure';
                    break;
                case "REVERSED":
                    $this->Status = 'Failure';
                    break;
                case "VOIDED":
                    $this->Message = _t('PayPalExpressCheckoutPayment.VOIDED', "An authorization for this transaction has been voided.");
                    $this->Status = 'Failure';
                    break;
                case "FAILED":
                    $this->Status = 'Failure';
                    break;
                case "CANCEL-REVERSAL": // A reversal has been canceled; for example, when you win a dispute and the funds for the reversal have been returned to you.
                    break;
                case "IN-PROGRESS":
                    $this->Message = _t('PayPalExpressCheckoutPayment.INPROGRESS', "The transaction has not terminated"); //, e.g. an authorization may be awaiting completion.";
                    break;
                case "PARTIALLY-REFUNDED":
                    $this->Message = _t('PayPalExpressCheckoutPayment.PARTIALLYREFUNDED', "The payment has been partially refunded.");
                    break;
                case "PENDING":
                    $this->Message = _t('PayPalExpressCheckoutPayment.PENDING', "The payment is pending.");
                    if (isset($response["PAYMENTINFO_0_PENDINGREASON"])) {
                        $this->Message .= " " . $this->getPendingReason($response["PAYMENTINFO_0_PENDINGREASON"]);
                    }
                    break;
                case "REFUNDED":
                    $this->Message = _t('PayPalExpressCheckoutPayment.REFUNDED', "Payment refunded.");
                    break;
                default:
            }
        }
        //$reasonCode		= $response["REASONCODE"];
        $this->write();
    }

    protected function getPendingReason($reason)
    {
        switch ($reason) {
            case "address":
                return _t('PayPalExpressCheckoutPayment.PENDING.ADDRESS', "A confirmed shipping address was not provided.");
            case "authorization":
                return _t('PayPalExpressCheckoutPayment.PENDING.AUTHORISATION', "Payment has been authorised, but not settled.");
            case "echeck":
                return _t('PayPalExpressCheckoutPayment.PENDING.ECHECK', "eCheck has not cleared.");
            case "intl":
                return _t('PayPalExpressCheckoutPayment.PENDING.INTERNATIONAL', "International: payment must be accepted or denied manually.");
            case "multicurrency":
                return _t('PayPalExpressCheckoutPayment.PENDING.MULTICURRENCY', "Multi-currency: payment must be accepted or denied manually.");
            case "order":
            case "paymentreview":
            case "unilateral":
            case "verify":
            case "other":
        }
    }

    /**
     * Handles actual communication with API server.
     */
    protected function apiCall($method, $data = array())
    {
        $this->addDebugInfo('---------------------------------------');
        $this->addDebugInfo('---------------------------------------');
        $this->addDebugInfo('---------------------------------------');
        $postfields = array(
            'METHOD' => $method,
            'VERSION' => $this->Config()->get("version"),
            'USER' => $this->Config()->get("API_UserName"),
            'PWD' => $this->Config()->get("API_Password"),
            'SIGNATURE' => $this->Config()->get("API_Signature"),
            'BUTTONSOURCE' => $this->Config()->get("sBNCode")
        );

        /**
         * ### @@@@ START REPLACEMENT @@@@ ###
         * WHY: automated upgrade
         * OLD: Config::inst()->get("
         * NEW: Config::inst()->get(" ...  (COMPLEX)
         * EXP: Check if you should be using Name::class here instead of hard-coded class.
         * ### @@@@ STOP REPLACEMENT @@@@ ###
         */
        if (Config::inst()->get(PayPalExpressCheckoutPayment::class, "debug")) {
            $this->addDebugInfo("STANDARD POSTING FIELDS ....  //// : " . print_r($postfields, 1));
            $this->addDebugInfo("ADDITIONAL POSTING FIELDS ....  //// : " . print_r($data, 1));
            $this->addDebugInfo("SENDING TO ....  //// : " . print_r($this->getApiEndpoint(), 1));
        }
        $postfields = array_merge($postfields, $data);
        //Make POST request to Paypal via RESTful service
        $client = new Client([
            'base_uri' => $this->getApiEndpoint(),
            'headers' => [
                'Accept' => 'application/xml',
                'Content-Type' => 'application/x-www-form-urlencoded',
            ],
            'timeout' => 10, // optional
        ]);

        $response = $client->post('', [
            'form_params' => $postfields,
        ]);

        // status and body:
        $status = $response->getStatusCode();
        $body = (string)$response->getBody();

        return [
            'status' => $status,
            'body' => $body,
        ];

        /**
         * ### @@@@ START REPLACEMENT @@@@ ###
         * WHY: automated upgrade
         * OLD: Config::inst()->get("
         * NEW: Config::inst()->get(" ...  (COMPLEX)
         * EXP: Check if you should be using Name::class here instead of hard-coded class.
         * ### @@@@ STOP REPLACEMENT @@@@ ###
         */
        if (Config::inst()->get(PayPalExpressCheckoutPayment::class, "debug")) {
            $this->addDebugInfo('RESPONSE ....  //// : ' . print_r($response, 1));
        }
        return $this->deformatNVP($response->getBody());
    }

    protected function deformatNVP($nvpstr)
    {
        $intial = 0;
        $nvpArray = [];
        while (strlen($nvpstr)) {
            //postion of Key
            $keypos = strpos($nvpstr, '=');
            //position of value
            $valuepos = strpos($nvpstr, '&') ? strpos($nvpstr, '&') : strlen($nvpstr);
            /*getting the Key and Value values and storing in a Associative Array*/
            $keyval = substr($nvpstr, $intial, $keypos);
            $valval = substr($nvpstr, $keypos + 1, $valuepos - $keypos - 1);
            //decoding the respose
            $nvpArray[urldecode($keyval)] = urldecode($valval);
            $nvpstr = substr($nvpstr, $valuepos + 1, strlen($nvpstr));
        }
        return $nvpArray;
    }

    protected function getApiEndpoint()
    {
        return ($this->Config()->get("test_mode") === true) ? $this->Config()->get("test_API_Endpoint") : $this->Config()->get("API_Endpoint");
    }

    protected function getPayPalURL($token)
    {
        $url = ($this->Config()->get("test_mode") === true) ? $this->Config()->get("test_PAYPAL_URL") : $this->Config()->get("PAYPAL_URL");
        return $url . $token . '&useraction=commit'; //useraction=commit ensures the payment is confirmed on PayPal, and not on a merchant confirm page.
    }


    protected function addDebugInfo($msg)
    {
        $this->Debug .= "---------//------------\n\n" . $msg;
        $this->write();
    }
}
PHP Warning:  Undefined array key 265 in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/Lexer.php on line 258
PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 194
PHP Warning:  Undefined array key "" in /var/www/ss3/upgrader/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 367
Writing changes for 0 files
